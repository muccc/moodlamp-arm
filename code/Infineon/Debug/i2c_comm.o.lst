   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 4
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"i2c_comm.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.USIC0_1_IRQHandler,"ax",%progbits
  18              		.align	1
  19              		.global	USIC0_1_IRQHandler
  20              		.code	16
  21              		.thumb_func
  23              	USIC0_1_IRQHandler:
  24              	.LFB38:
  25              		.file 1 "../i2c_comm.c"
   1:../i2c_comm.c **** /*
   2:../i2c_comm.c ****  * itwoc.c
   3:../i2c_comm.c ****  *
   4:../i2c_comm.c ****  *  Created on: Jul 14, 2014
   5:../i2c_comm.c ****  *      Author: ChiaJiaY
   6:../i2c_comm.c ****  */
   7:../i2c_comm.c **** 
   8:../i2c_comm.c **** 
   9:../i2c_comm.c **** #include "i2c_comm.h"
  10:../i2c_comm.c **** #include <Dave3.h>
  11:../i2c_comm.c **** 
  12:../i2c_comm.c **** 
  13:../i2c_comm.c **** #define GET_MASK_FOR_1CHANNEL(N1) (1UL<<N1)
  14:../i2c_comm.c **** #define INTENSITY_RED             (0x11U) //0
  15:../i2c_comm.c **** #define INTENSITY_GREEN           (0x12U) //1
  16:../i2c_comm.c **** #define INTENSITY_BLUE			  (0x13U) //2
  17:../i2c_comm.c **** #define INTENSITY_RGB             (0x14U)
  18:../i2c_comm.c **** #define CURRENT_RED               (0x21U) //3
  19:../i2c_comm.c **** #define CURRENT_GREEN             (0x22U) //4
  20:../i2c_comm.c **** #define CURRENT_BLUE              (0x23U) //5
  21:../i2c_comm.c **** #define CURRENT_RGB               (0x24U)
  22:../i2c_comm.c **** #define DMX0FF					  (0x30U) //6
  23:../i2c_comm.c **** #define DMXON             		  (0x31U)
  24:../i2c_comm.c **** #define DMXSLOT					  (0x32U) //7
  25:../i2c_comm.c **** #define DMX8BIT                   (0x33U) //8 9 10 11
  26:../i2c_comm.c **** #define DMX16BIT                  (0x34U)
  27:../i2c_comm.c **** #define OFFTIME_RED               (0x41U) //12
  28:../i2c_comm.c **** #define OFFTIME_GREEN             (0x42U) //13
  29:../i2c_comm.c **** #define OFFTIME_BLUE		   	  (0x43U) //14
  30:../i2c_comm.c **** #define WALKTIME                  (0x50U) //15
  31:../i2c_comm.c **** #define DIMMINGLEVEL              (0x60U) //16
  32:../i2c_comm.c **** #define FADERATE                  (0x61U) //17
  33:../i2c_comm.c **** #define CHANGEADDRESS             (0x70U) //18
  34:../i2c_comm.c **** 
  35:../i2c_comm.c **** #define READ_CONFIG               (0x80U)
  36:../i2c_comm.c **** #define READ_INTENSITY_RED        (0x81U)
  37:../i2c_comm.c **** #define READ_INTENSITY_GREEN      (0x82U)
  38:../i2c_comm.c **** #define READ_INTENSITY_BLUE		  (0x83U)
  39:../i2c_comm.c **** #define READ_CURRENT_RED          (0x84U)
  40:../i2c_comm.c **** #define READ_CURRENT_GREEN        (0x85U)
  41:../i2c_comm.c **** #define READ_CURRENT_BLUE         (0x86U)
  42:../i2c_comm.c **** #define READ_OFFTIME_RED          (0x87U)
  43:../i2c_comm.c **** #define READ_OFFTIME_GREEN        (0x88U)
  44:../i2c_comm.c **** #define READ_OFFTIME_BLUE		  (0x89U)
  45:../i2c_comm.c **** #define READ_WALKTIME             (0x8AU)
  46:../i2c_comm.c **** #define READ_DIMMINGLEVEL         (0x8BU)
  47:../i2c_comm.c **** #define READ_FADERATE             (0x8CU)
  48:../i2c_comm.c **** #define READ_DMX             	  (0x8DU)
  49:../i2c_comm.c **** #define READ_DMXSLOT			  (0x8EU)
  50:../i2c_comm.c **** #define READ_DMXBIT               (0x8FU)
  51:../i2c_comm.c **** #define READ_DMXREDH              (0x94U)
  52:../i2c_comm.c **** #define READ_DMXREDL              (0x95U)
  53:../i2c_comm.c **** #define READ_DMXGREENH            (0x96U)
  54:../i2c_comm.c **** #define READ_DMXGREENL            (0x97U)
  55:../i2c_comm.c **** #define READ_DMXBLUEH             (0x98U)
  56:../i2c_comm.c **** #define READ_DMXBLUEL             (0x99U)
  57:../i2c_comm.c **** 
  58:../i2c_comm.c **** 
  59:../i2c_comm.c **** #define DIRECTACCESS_READ         (0x90U)
  60:../i2c_comm.c **** #define DIRECTACCESS_MOVE   	  (0x91U)
  61:../i2c_comm.c **** #define DIRECTACCESS_AND          (0x92U)
  62:../i2c_comm.c **** #define DIRECTACCESS_OR           (0x93U)
  63:../i2c_comm.c **** 
  64:../i2c_comm.c **** #define SAVEPARAMETERS            (0xA0U)
  65:../i2c_comm.c **** 
  66:../i2c_comm.c **** I2C003_DataType data1, data2, data3, data4, data5;
  67:../i2c_comm.c **** 
  68:../i2c_comm.c **** /*******************************************************************************
  69:../i2c_comm.c ****  ** Syntax          :                                                          **
  70:../i2c_comm.c ****  **                                                                            **
  71:../i2c_comm.c ****  ** Sync /Async     : Synchronous                                              **
  72:../i2c_comm.c ****  **                                                                            **
  73:../i2c_comm.c ****  ** Reentrant       : Non reentrant                                            **
  74:../i2c_comm.c ****  **                                                                            **
  75:../i2c_comm.c ****  ** Parameters(IN)  : None                                                     **
  76:../i2c_comm.c ****  **                                                                            **
  77:../i2c_comm.c ****  ** Parameters(OUT) : Data received from shield on I2C bus                     **
  78:../i2c_comm.c ****  **                                                                            **
  79:../i2c_comm.c ****  ** Return value    : None                                                     **
  80:../i2c_comm.c ****  **                                                                            **
  81:../i2c_comm.c ****  ** Description     : This function is the interrupt service routine when the  **
  82:../i2c_comm.c ****  **                   shield receives data. The received data is stored in     **
  83:../i2c_comm.c ****  **                   global variable DataReceived and DataTotal. The function **
  84:../i2c_comm.c ****  **                   checks the received data against the defined command     **
  85:../i2c_comm.c ****  **                   words                                                    **
  86:../i2c_comm.c ****  *******************************************************************************/
  87:../i2c_comm.c **** void FIFO_Receive_Int_Handler(void)
  88:../i2c_comm.c **** {
  26              		.loc 1 88 0
  27              		.cfi_startproc
  28 0000 F0B5     		push	{r4, r5, r6, r7, lr}
  29              	.LCFI0:
  30              		.cfi_def_cfa_offset 20
  31              		.cfi_offset 4, -20
  32              		.cfi_offset 5, -16
  33              		.cfi_offset 6, -12
  34              		.cfi_offset 7, -8
  35              		.cfi_offset 14, -4
  89:../i2c_comm.c **** 	uint8_t DataReceived = 0x00;
  90:../i2c_comm.c **** 	I2C003_ClearFlag(&I2C003_Handle0, I2C003_FLAG_RIF);
  36              		.loc 1 90 0
  37 0002 C54C     		ldr	r4, .L95
  88:../i2c_comm.c **** {
  38              		.loc 1 88 0
  39 0004 85B0     		sub	sp, sp, #20
  40              	.LCFI1:
  41              		.cfi_def_cfa_offset 40
  89:../i2c_comm.c **** 	uint8_t DataReceived = 0x00;
  42              		.loc 1 89 0
  43 0006 6E46     		mov	r6, sp
  44 0008 0023     		mov	r3, #0
  45              		.loc 1 90 0
  46 000a 201C     		mov	r0, r4
  89:../i2c_comm.c **** 	uint8_t DataReceived = 0x00;
  47              		.loc 1 89 0
  48 000c 0F36     		add	r6, r6, #15
  49              		.loc 1 90 0
  50 000e 0421     		mov	r1, #4
  89:../i2c_comm.c **** 	uint8_t DataReceived = 0x00;
  51              		.loc 1 89 0
  52 0010 3370     		strb	r3, [r6]
  53              	.LVL0:
  54              		.loc 1 90 0
  55 0012 FFF7FEFF 		bl	I2C003_ClearFlag
  56              	.LVL1:
  91:../i2c_comm.c **** 	I2C003_Handle0.I2CRegs->TRBSCR |= USIC_CH_TRBSCR_CSRBI_Msk;
  57              		.loc 1 91 0
  58 0016 2568     		ldr	r5, [r4]
  59 0018 0127     		mov	r7, #1
  60 001a 281C     		mov	r0, r5
  61 001c FC30     		add	r0, r0, #252
  62 001e C269     		ldr	r2, [r0, #28]
  92:../i2c_comm.c **** 	I2C003_ReadData(&I2C003_Handle0,&DataReceived);  // Read receive FIFO buffer, put the data in Data
  63              		.loc 1 92 0
  64 0020 311C     		mov	r1, r6
  91:../i2c_comm.c **** 	I2C003_Handle0.I2CRegs->TRBSCR |= USIC_CH_TRBSCR_CSRBI_Msk;
  65              		.loc 1 91 0
  66 0022 3A43     		orr	r2, r7
  67 0024 C261     		str	r2, [r0, #28]
  68              		.loc 1 92 0
  69 0026 201C     		mov	r0, r4
  70 0028 FFF7FEFF 		bl	I2C003_ReadData
  71              	.LVL2:
  93:../i2c_comm.c **** 
  94:../i2c_comm.c **** 	if (byteCount == 0) // Taking in Command
  72              		.loc 1 94 0
  73 002c BB4C     		ldr	r4, .L95+4
  74 002e 2368     		ldr	r3, [r4]
  75 0030 002B     		cmp	r3, #0
  76 0032 22D1     		bne	.L2
  95:../i2c_comm.c **** 	{
  96:../i2c_comm.c **** 		Command = (DataReceived & 0x00FF);
  77              		.loc 1 96 0
  78 0034 3278     		ldrb	r2, [r6]
  79 0036 BA49     		ldr	r1, .L95+8
  97:../i2c_comm.c **** 		DataUpper = 0x00;
  80              		.loc 1 97 0
  81 0038 BA4E     		ldr	r6, .L95+12
  98:../i2c_comm.c **** 		DataLower = 0x00;
  82              		.loc 1 98 0
  83 003a BB48     		ldr	r0, .L95+16
  96:../i2c_comm.c **** 		Command = (DataReceived & 0x00FF);
  84              		.loc 1 96 0
  85 003c 0A70     		strb	r2, [r1]
  97:../i2c_comm.c **** 		DataUpper = 0x00;
  86              		.loc 1 97 0
  87 003e 3370     		strb	r3, [r6]
  88              		.loc 1 98 0
  89 0040 0370     		strb	r3, [r0]
  99:../i2c_comm.c **** 		byteCount++;
  90              		.loc 1 99 0
  91 0042 2760     		str	r7, [r4]
 100:../i2c_comm.c **** 
 101:../i2c_comm.c **** 		if (Command == DMX0FF) // If DMXOFF sent, off the DMX control
  92              		.loc 1 101 0
  93 0044 302A     		cmp	r2, #48
  94 0046 05D1     		bne	.L3
 102:../i2c_comm.c **** 		{
 103:../i2c_comm.c **** 			DMXControl = 0;
  95              		.loc 1 103 0
  96 0048 B84F     		ldr	r7, .L95+20
 104:../i2c_comm.c **** 			byteCount = 0;
 105:../i2c_comm.c **** 			flashBuffer[7] = 0; // writing to buffer maintaining flash parameters
  97              		.loc 1 105 0
  98 004a B949     		ldr	r1, .L95+24
 103:../i2c_comm.c **** 			DMXControl = 0;
  99              		.loc 1 103 0
 100 004c 3B60     		str	r3, [r7]
 104:../i2c_comm.c **** 			byteCount = 0;
 101              		.loc 1 104 0
 102 004e 2360     		str	r3, [r4]
 103              		.loc 1 105 0
 104 0050 CB61     		str	r3, [r1, #28]
 105 0052 39E0     		b	.L4
 106              	.L3:
 106:../i2c_comm.c **** 		}
 107:../i2c_comm.c **** 
 108:../i2c_comm.c **** 		else if (Command == DMXON)
 107              		.loc 1 108 0
 108 0054 312A     		cmp	r2, #49
 109 0056 05D1     		bne	.L5
 109:../i2c_comm.c **** 		{
 110:../i2c_comm.c **** 			DMXControl = 1;
 110              		.loc 1 110 0
 111 0058 B44A     		ldr	r2, .L95+20
 111:../i2c_comm.c **** 			byteCount = 0;
 112:../i2c_comm.c **** 			flashBuffer[7] = 1;
 112              		.loc 1 112 0
 113 005a B548     		ldr	r0, .L95+24
 110:../i2c_comm.c **** 			DMXControl = 1;
 114              		.loc 1 110 0
 115 005c 1760     		str	r7, [r2]
 111:../i2c_comm.c **** 			byteCount = 0;
 116              		.loc 1 111 0
 117 005e 2360     		str	r3, [r4]
 118              		.loc 1 112 0
 119 0060 C761     		str	r7, [r0, #28]
 120 0062 31E0     		b	.L4
 121              	.L5:
 113:../i2c_comm.c **** 		}
 114:../i2c_comm.c **** 
 115:../i2c_comm.c **** 		else if (Command == 0x80 || Command == 0x81 || Command == 0x82 || Command == 0x83 || Command == 0
 122              		.loc 1 115 0
 123 0064 111C     		mov	r1, r2
 124 0066 8039     		sub	r1, r1, #128
 125 0068 CEB2     		uxtb	r6, r1
 126 006a 0F2E     		cmp	r6, #15
 127 006c 2BD9     		bls	.L83
 128              	.L6:
 116:../i2c_comm.c **** 		{
 117:../i2c_comm.c **** 
 118:../i2c_comm.c **** 			byteCount = 0;
 119:../i2c_comm.c **** 			// Commands for slave to send back relevant data to master
 120:../i2c_comm.c **** 			// 0x71 0x72 0x73: RGB Intensity
 121:../i2c_comm.c **** 			// 0x74 0x75 0x76: RGB Current
 122:../i2c_comm.c **** 			// 0x77: Walktime
 123:../i2c_comm.c **** 			// 0x78: Dimming
 124:../i2c_comm.c **** 			// 0x79: Fade Rate
 125:../i2c_comm.c **** 		}
 126:../i2c_comm.c **** 
 127:../i2c_comm.c **** 		else if (Command == SAVEPARAMETERS)
 129              		.loc 1 127 0
 130 006e A02A     		cmp	r2, #160
 131 0070 2AD1     		bne	.L4
 128:../i2c_comm.c **** 		{
 129:../i2c_comm.c **** 			byteCount = 0;
 132              		.loc 1 129 0
 133 0072 2360     		str	r3, [r4]
 130:../i2c_comm.c **** 			writeToFlash = 1;
 134              		.loc 1 130 0
 135 0074 AF4B     		ldr	r3, .L95+28
 136 0076 1F60     		str	r7, [r3]
 137 0078 26E0     		b	.L4
 138              	.L2:
 131:../i2c_comm.c **** 		}
 132:../i2c_comm.c **** 
 133:../i2c_comm.c **** 	}
 134:../i2c_comm.c **** 
 135:../i2c_comm.c **** 	else if (byteCount == 1 || byteCount == 3 || byteCount == 5 || byteCount == 7 || byteCount == 9 ||
 139              		.loc 1 135 0
 140 007a 012B     		cmp	r3, #1
 141 007c 09D0     		beq	.L8
 142              		.loc 1 135 0 is_stmt 0 discriminator 1
 143 007e 032B     		cmp	r3, #3
 144 0080 07D0     		beq	.L8
 145 0082 052B     		cmp	r3, #5
 146 0084 05D0     		beq	.L8
 147 0086 072B     		cmp	r3, #7
 148 0088 03D0     		beq	.L8
 149 008a 092B     		cmp	r3, #9
 150 008c 01D0     		beq	.L8
 151 008e 0B2B     		cmp	r3, #11
 152 0090 03D1     		bne	.L9
 153              	.L8:
 136:../i2c_comm.c **** 	{
 137:../i2c_comm.c **** 		DataUpper = (DataReceived & 0x00FF);
 154              		.loc 1 137 0 is_stmt 1
 155 0092 3678     		ldrb	r6, [r6]
 156              	.LVL3:
 157 0094 A348     		ldr	r0, .L95+12
 158              	.LVL4:
 159 0096 0670     		strb	r6, [r0]
 160 0098 14E0     		b	.L84
 161              	.LVL5:
 162              	.L9:
 138:../i2c_comm.c **** 		byteCount++;
 139:../i2c_comm.c **** 
 140:../i2c_comm.c **** 	}
 141:../i2c_comm.c **** 	else if (byteCount == 2 || byteCount == 4 || byteCount == 6 || byteCount == 8 || byteCount == 10 |
 163              		.loc 1 141 0
 164 009a 022B     		cmp	r3, #2
 165 009c 09D0     		beq	.L10
 166              		.loc 1 141 0 is_stmt 0 discriminator 1
 167 009e 042B     		cmp	r3, #4
 168 00a0 07D0     		beq	.L10
 169 00a2 062B     		cmp	r3, #6
 170 00a4 05D0     		beq	.L10
 171 00a6 082B     		cmp	r3, #8
 172 00a8 03D0     		beq	.L10
 173 00aa 0A2B     		cmp	r3, #10
 174 00ac 01D0     		beq	.L10
 175 00ae 0C2B     		cmp	r3, #12
 176 00b0 0AD1     		bne	.L4
 177              	.L10:
 142:../i2c_comm.c **** 	{
 143:../i2c_comm.c **** 		DataLower = (DataReceived & 0x00FF);
 144:../i2c_comm.c **** 		DataTotal = (uint16_t) (DataUpper << 8 ) | DataLower; // upper 8 bits, shift left by 8 bits
 178              		.loc 1 144 0 is_stmt 1
 179 00b2 9C48     		ldr	r0, .L95+12
 143:../i2c_comm.c **** 		DataLower = (DataReceived & 0x00FF);
 180              		.loc 1 143 0
 181 00b4 3678     		ldrb	r6, [r6]
 182 00b6 9C49     		ldr	r1, .L95+16
 183              		.loc 1 144 0
 184 00b8 0278     		ldrb	r2, [r0]
 143:../i2c_comm.c **** 		DataLower = (DataReceived & 0x00FF);
 185              		.loc 1 143 0
 186 00ba 0E70     		strb	r6, [r1]
 187              		.loc 1 144 0
 188 00bc 1702     		lsl	r7, r2, #8
 189 00be 9E49     		ldr	r1, .L95+32
 190 00c0 3E43     		orr	r6, r7
 191 00c2 0E80     		strh	r6, [r1]
 192              	.LVL6:
 193              	.L84:
 145:../i2c_comm.c **** 		byteCount ++;
 194              		.loc 1 145 0
 195 00c4 0133     		add	r3, r3, #1
 196              	.L83:
 197 00c6 2360     		str	r3, [r4]
 198              	.L4:
 146:../i2c_comm.c **** 
 147:../i2c_comm.c **** 	}
 148:../i2c_comm.c **** 
 149:../i2c_comm.c **** 	if (byteCount == 3) // Commands here come with 2 more bytes of data
 199              		.loc 1 149 0
 200 00c8 2668     		ldr	r6, [r4]
 201 00ca 032E     		cmp	r6, #3
 202 00cc 00D0     		beq	.LCB141
 203 00ce E3E1     		b	.L12	@long jump
 204              	.LCB141:
 150:../i2c_comm.c **** 	{
 151:../i2c_comm.c **** 		if(Command == INTENSITY_RED) // Red Command: Change red color intensity of lamp
 205              		.loc 1 151 0
 206 00d0 934A     		ldr	r2, .L95+8
 207 00d2 1078     		ldrb	r0, [r2]
 208 00d4 1128     		cmp	r0, #17
 209 00d6 19D1     		bne	.L13
 152:../i2c_comm.c **** 		{
 153:../i2c_comm.c **** 			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle0, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle0.ChNum)); // e
 210              		.loc 1 153 0
 211 00d8 984D     		ldr	r5, .L95+36
 212 00da 0127     		mov	r7, #1
 213 00dc AA68     		ldr	r2, [r5, #8]
 214 00de 281C     		mov	r0, r5
 215 00e0 9740     		lsl	r7, r7, r2
 216 00e2 391C     		mov	r1, r7
 217 00e4 FFF7FEFF 		bl	BCCUCH01_AbortLinearWalk
 218              	.LVL7:
 154:../i2c_comm.c **** 			DataTotal &= 0x0FFF;
 219              		.loc 1 154 0
 220 00e8 934E     		ldr	r6, .L95+32
 221 00ea 3188     		ldrh	r1, [r6]
 222 00ec 0805     		lsl	r0, r1, #20
 223 00ee 010D     		lsr	r1, r0, #20
 155:../i2c_comm.c **** 			BCCUCH01_SetIntensity(&BCCUCH01_Handle0, DataTotal);
 224              		.loc 1 155 0
 225 00f0 281C     		mov	r0, r5
 154:../i2c_comm.c **** 			DataTotal &= 0x0FFF;
 226              		.loc 1 154 0
 227 00f2 3180     		strh	r1, [r6]
 228              		.loc 1 155 0
 229 00f4 FFF7FEFF 		bl	BCCUCH01_SetIntensity
 230              	.LVL8:
 156:../i2c_comm.c **** 			BCCUCH01_StartLinearWalk(&BCCUCH01_Handle0, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle0.ChNum)); // s
 231              		.loc 1 156 0
 232 00f8 281C     		mov	r0, r5
 233 00fa 391C     		mov	r1, r7
 234 00fc FFF7FEFF 		bl	BCCUCH01_StartLinearWalk
 235              	.LVL9:
 157:../i2c_comm.c **** 			byteCount = 0;
 236              		.loc 1 157 0
 237 0100 0023     		mov	r3, #0
 238 0102 2360     		str	r3, [r4]
 158:../i2c_comm.c **** 
 159:../i2c_comm.c **** 			flashBuffer[1] = DataTotal; // store into flash buffer
 239              		.loc 1 159 0
 240 0104 8A4D     		ldr	r5, .L95+24
 241 0106 3488     		ldrh	r4, [r6]
 242 0108 6C60     		str	r4, [r5, #4]
 243 010a 99E2     		b	.L1
 244              	.L13:
 160:../i2c_comm.c **** 		}
 161:../i2c_comm.c **** 
 162:../i2c_comm.c **** 		else if (Command == INTENSITY_GREEN) // Green Command: Change green color intensity of lamp
 245              		.loc 1 162 0
 246 010c 1228     		cmp	r0, #18
 247 010e 19D1     		bne	.L15
 163:../i2c_comm.c **** 		{
 164:../i2c_comm.c **** 			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle1, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle1.ChNum)); //BC
 248              		.loc 1 164 0
 249 0110 8B4D     		ldr	r5, .L95+40
 250 0112 0127     		mov	r7, #1
 251 0114 AA68     		ldr	r2, [r5, #8]
 252 0116 281C     		mov	r0, r5
 253 0118 9740     		lsl	r7, r7, r2
 254 011a 391C     		mov	r1, r7
 255 011c FFF7FEFF 		bl	BCCUCH01_AbortLinearWalk
 256              	.LVL10:
 165:../i2c_comm.c **** 			DataTotal &= 0x0FFF;
 257              		.loc 1 165 0
 258 0120 854E     		ldr	r6, .L95+32
 259 0122 3188     		ldrh	r1, [r6]
 260 0124 0805     		lsl	r0, r1, #20
 261 0126 010D     		lsr	r1, r0, #20
 166:../i2c_comm.c **** 			BCCUCH01_SetIntensity(&BCCUCH01_Handle1, DataTotal);
 262              		.loc 1 166 0
 263 0128 281C     		mov	r0, r5
 165:../i2c_comm.c **** 			DataTotal &= 0x0FFF;
 264              		.loc 1 165 0
 265 012a 3180     		strh	r1, [r6]
 266              		.loc 1 166 0
 267 012c FFF7FEFF 		bl	BCCUCH01_SetIntensity
 268              	.LVL11:
 167:../i2c_comm.c **** 			BCCUCH01_StartLinearWalk(&BCCUCH01_Handle1, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle1.ChNum));
 269              		.loc 1 167 0
 270 0130 281C     		mov	r0, r5
 271 0132 391C     		mov	r1, r7
 272 0134 FFF7FEFF 		bl	BCCUCH01_StartLinearWalk
 273              	.LVL12:
 168:../i2c_comm.c **** 			byteCount = 0;
 274              		.loc 1 168 0
 275 0138 0023     		mov	r3, #0
 276 013a 2360     		str	r3, [r4]
 169:../i2c_comm.c **** 
 170:../i2c_comm.c **** 			flashBuffer[2] = DataTotal;
 277              		.loc 1 170 0
 278 013c 7C4D     		ldr	r5, .L95+24
 279 013e 3488     		ldrh	r4, [r6]
 280 0140 AC60     		str	r4, [r5, #8]
 281 0142 7DE2     		b	.L1
 282              	.L15:
 171:../i2c_comm.c **** 		}
 172:../i2c_comm.c **** 
 173:../i2c_comm.c **** 
 174:../i2c_comm.c **** 		else if (Command == INTENSITY_BLUE) // Blue Command: Change blue color intensity of lamp
 283              		.loc 1 174 0
 284 0144 1328     		cmp	r0, #19
 285 0146 17D1     		bne	.L16
 175:../i2c_comm.c **** 		{
 176:../i2c_comm.c **** 			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle2, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle2.ChNum)); // B
 286              		.loc 1 176 0
 287 0148 7E4D     		ldr	r5, .L95+44
 288 014a 0127     		mov	r7, #1
 289 014c AA68     		ldr	r2, [r5, #8]
 290 014e 281C     		mov	r0, r5
 291 0150 9740     		lsl	r7, r7, r2
 292 0152 391C     		mov	r1, r7
 293 0154 FFF7FEFF 		bl	BCCUCH01_AbortLinearWalk
 294              	.LVL13:
 177:../i2c_comm.c **** 			DataTotal &= 0x0FFF;
 295              		.loc 1 177 0
 296 0158 774E     		ldr	r6, .L95+32
 297 015a 3188     		ldrh	r1, [r6]
 298 015c 0805     		lsl	r0, r1, #20
 299 015e 010D     		lsr	r1, r0, #20
 178:../i2c_comm.c **** 			BCCUCH01_SetIntensity(&BCCUCH01_Handle2, DataTotal);
 300              		.loc 1 178 0
 301 0160 281C     		mov	r0, r5
 177:../i2c_comm.c **** 			DataTotal &= 0x0FFF;
 302              		.loc 1 177 0
 303 0162 3180     		strh	r1, [r6]
 304              		.loc 1 178 0
 305 0164 FFF7FEFF 		bl	BCCUCH01_SetIntensity
 306              	.LVL14:
 179:../i2c_comm.c **** 			BCCUCH01_StartLinearWalk(&BCCUCH01_Handle2, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle2.ChNum));
 307              		.loc 1 179 0
 308 0168 281C     		mov	r0, r5
 309 016a 391C     		mov	r1, r7
 310 016c FFF7FEFF 		bl	BCCUCH01_StartLinearWalk
 311              	.LVL15:
 180:../i2c_comm.c **** 			byteCount = 0;
 312              		.loc 1 180 0
 313 0170 0023     		mov	r3, #0
 314 0172 2360     		str	r3, [r4]
 181:../i2c_comm.c **** 
 182:../i2c_comm.c **** 			flashBuffer[3] = DataTotal;
 315              		.loc 1 182 0
 316 0174 3288     		ldrh	r2, [r6]
 317 0176 D5E1     		b	.L86
 318              	.L16:
 183:../i2c_comm.c **** 		}
 184:../i2c_comm.c **** 
 185:../i2c_comm.c **** 		else if (Command == INTENSITY_RGB) // RGB Command: Change color intensity of red, green and blue 
 319              		.loc 1 185 0
 320 0178 1428     		cmp	r0, #20
 321 017a 1CD1     		bne	.L17
 186:../i2c_comm.c **** 		{
 187:../i2c_comm.c **** 			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle0, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle0.ChNum));
 322              		.loc 1 187 0
 323 017c 6F48     		ldr	r0, .L95+36
 324 017e 0126     		mov	r6, #1
 325 0180 8368     		ldr	r3, [r0, #8]
 326 0182 311C     		mov	r1, r6
 327 0184 9940     		lsl	r1, r1, r3
 328 0186 FFF7FEFF 		bl	BCCUCH01_AbortLinearWalk
 329              	.LVL16:
 188:../i2c_comm.c **** 			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle1, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle1.ChNum));
 330              		.loc 1 188 0
 331 018a 6D48     		ldr	r0, .L95+40
 332 018c 311C     		mov	r1, r6
 333 018e 8768     		ldr	r7, [r0, #8]
 334 0190 B940     		lsl	r1, r1, r7
 335 0192 FFF7FEFF 		bl	BCCUCH01_AbortLinearWalk
 336              	.LVL17:
 189:../i2c_comm.c **** 			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle2, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle2.ChNum));
 337              		.loc 1 189 0
 338 0196 6B48     		ldr	r0, .L95+44
 339 0198 311C     		mov	r1, r6
 340 019a 8268     		ldr	r2, [r0, #8]
 341 019c 9140     		lsl	r1, r1, r2
 342 019e FFF7FEFF 		bl	BCCUCH01_AbortLinearWalk
 343              	.LVL18:
 190:../i2c_comm.c **** 			DataTotal &= 0x0FFF;
 344              		.loc 1 190 0
 345 01a2 6549     		ldr	r1, .L95+32
 191:../i2c_comm.c **** 			Lamphandle.Intensity_Red = DataTotal;
 346              		.loc 1 191 0
 347 01a4 684B     		ldr	r3, .L95+48
 190:../i2c_comm.c **** 			DataTotal &= 0x0FFF;
 348              		.loc 1 190 0
 349 01a6 0888     		ldrh	r0, [r1]
 192:../i2c_comm.c **** 
 193:../i2c_comm.c **** 			flashBuffer[1] = DataTotal;
 350              		.loc 1 193 0
 351 01a8 614F     		ldr	r7, .L95+24
 190:../i2c_comm.c **** 			DataTotal &= 0x0FFF;
 352              		.loc 1 190 0
 353 01aa 0405     		lsl	r4, r0, #20
 354 01ac 260D     		lsr	r6, r4, #20
 355 01ae 0E80     		strh	r6, [r1]
 191:../i2c_comm.c **** 			Lamphandle.Intensity_Red = DataTotal;
 356              		.loc 1 191 0
 357 01b0 1E60     		str	r6, [r3]
 358              		.loc 1 193 0
 359 01b2 7E60     		str	r6, [r7, #4]
 360 01b4 44E2     		b	.L1
 361              	.L17:
 194:../i2c_comm.c **** 		}
 195:../i2c_comm.c **** 
 196:../i2c_comm.c **** 		else if (Command == CURRENT_RED) // Red Current Command: Change peak current reference of red cha
 362              		.loc 1 196 0
 363 01b6 2128     		cmp	r0, #33
 364 01b8 1AD1     		bne	.L18
 197:../i2c_comm.c **** 		{
 198:../i2c_comm.c **** 			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle3, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle3.ChNum)); // B
 365              		.loc 1 198 0
 366 01ba 644E     		ldr	r6, .L95+52
 367 01bc 0127     		mov	r7, #1
 368 01be B368     		ldr	r3, [r6, #8]
 369 01c0 301C     		mov	r0, r6
 370 01c2 9F40     		lsl	r7, r7, r3
 371 01c4 391C     		mov	r1, r7
 372 01c6 FFF7FEFF 		bl	BCCUCH01_AbortLinearWalk
 373              	.LVL19:
 199:../i2c_comm.c **** 			if (DataTotal > 0x80) // To ensure current does not exceed limit
 374              		.loc 1 199 0
 375 01ca 5B4D     		ldr	r5, .L95+32
 376 01cc 2988     		ldrh	r1, [r5]
 377 01ce 8029     		cmp	r1, #128
 378 01d0 01D9     		bls	.L19
 200:../i2c_comm.c **** 				DataTotal = 0x80;
 379              		.loc 1 200 0
 380 01d2 8022     		mov	r2, #128
 381 01d4 2A80     		strh	r2, [r5]
 382              	.L19:
 201:../i2c_comm.c **** 			DataTotal &= 0x00FF;
 383              		.loc 1 201 0
 384 01d6 2978     		ldrb	r1, [r5]
 202:../i2c_comm.c **** 			BCCUCH01_SetIntensity(&BCCUCH01_Handle3, DataTotal);
 385              		.loc 1 202 0
 386 01d8 301C     		mov	r0, r6
 201:../i2c_comm.c **** 			DataTotal &= 0x00FF;
 387              		.loc 1 201 0
 388 01da 2980     		strh	r1, [r5]
 389              		.loc 1 202 0
 390 01dc FFF7FEFF 		bl	BCCUCH01_SetIntensity
 391              	.LVL20:
 203:../i2c_comm.c **** 			BCCUCH01_StartLinearWalk(&BCCUCH01_Handle3, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle3.ChNum)); // S
 392              		.loc 1 203 0
 393 01e0 301C     		mov	r0, r6
 394 01e2 391C     		mov	r1, r7
 395 01e4 FFF7FEFF 		bl	BCCUCH01_StartLinearWalk
 396              	.LVL21:
 204:../i2c_comm.c **** 			byteCount = 0;
 397              		.loc 1 204 0
 398 01e8 0020     		mov	r0, #0
 399 01ea 2060     		str	r0, [r4]
 205:../i2c_comm.c **** 
 206:../i2c_comm.c **** 			flashBuffer[4] = DataTotal;
 400              		.loc 1 206 0
 401 01ec 2888     		ldrh	r0, [r5]
 402 01ee 5CE0     		b	.L87
 403              	.L18:
 207:../i2c_comm.c **** 
 208:../i2c_comm.c **** 		}
 209:../i2c_comm.c **** 
 210:../i2c_comm.c **** 		else if (Command == CURRENT_GREEN) // Green Current Command: Change peak current reference of gre
 404              		.loc 1 210 0
 405 01f0 2228     		cmp	r0, #34
 406 01f2 1AD1     		bne	.L20
 211:../i2c_comm.c **** 		{
 212:../i2c_comm.c **** 			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle4, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle4.ChNum)); // B
 407              		.loc 1 212 0
 408 01f4 564E     		ldr	r6, .L95+56
 409 01f6 0127     		mov	r7, #1
 410 01f8 B368     		ldr	r3, [r6, #8]
 411 01fa 301C     		mov	r0, r6
 412 01fc 9F40     		lsl	r7, r7, r3
 413 01fe 391C     		mov	r1, r7
 414 0200 FFF7FEFF 		bl	BCCUCH01_AbortLinearWalk
 415              	.LVL22:
 213:../i2c_comm.c **** 			if (DataTotal > 0x80)
 416              		.loc 1 213 0
 417 0204 4C4D     		ldr	r5, .L95+32
 418 0206 2988     		ldrh	r1, [r5]
 419 0208 8029     		cmp	r1, #128
 420 020a 01D9     		bls	.L21
 214:../i2c_comm.c **** 				DataTotal = 0x80;
 421              		.loc 1 214 0
 422 020c 8022     		mov	r2, #128
 423 020e 2A80     		strh	r2, [r5]
 424              	.L21:
 215:../i2c_comm.c **** 			DataTotal &= 0x00FF;
 425              		.loc 1 215 0
 426 0210 2978     		ldrb	r1, [r5]
 216:../i2c_comm.c **** 			BCCUCH01_SetIntensity(&BCCUCH01_Handle4, DataTotal);
 427              		.loc 1 216 0
 428 0212 301C     		mov	r0, r6
 215:../i2c_comm.c **** 			DataTotal &= 0x00FF;
 429              		.loc 1 215 0
 430 0214 2980     		strh	r1, [r5]
 431              		.loc 1 216 0
 432 0216 FFF7FEFF 		bl	BCCUCH01_SetIntensity
 433              	.LVL23:
 217:../i2c_comm.c **** 			BCCUCH01_StartLinearWalk(&BCCUCH01_Handle4, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle4.ChNum));
 434              		.loc 1 217 0
 435 021a 301C     		mov	r0, r6
 436 021c 391C     		mov	r1, r7
 437 021e FFF7FEFF 		bl	BCCUCH01_StartLinearWalk
 438              	.LVL24:
 218:../i2c_comm.c **** 			byteCount = 0;
 439              		.loc 1 218 0
 440 0222 0020     		mov	r0, #0
 441 0224 2060     		str	r0, [r4]
 219:../i2c_comm.c **** 
 220:../i2c_comm.c **** 			flashBuffer[5] = DataTotal;
 442              		.loc 1 220 0
 443 0226 2A88     		ldrh	r2, [r5]
 444 0228 4FE1     		b	.L88
 445              	.L20:
 221:../i2c_comm.c **** 		}
 222:../i2c_comm.c **** 
 223:../i2c_comm.c **** 
 224:../i2c_comm.c **** 		else if (Command == CURRENT_BLUE) // Blue Current Command: Change peak current reference of blue 
 446              		.loc 1 224 0
 447 022a 2328     		cmp	r0, #35
 448 022c 1AD1     		bne	.L22
 225:../i2c_comm.c **** 		{
 226:../i2c_comm.c **** 
 227:../i2c_comm.c **** 			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle5, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle5.ChNum)); // B
 449              		.loc 1 227 0
 450 022e 494E     		ldr	r6, .L95+60
 451 0230 0127     		mov	r7, #1
 452 0232 B368     		ldr	r3, [r6, #8]
 453 0234 301C     		mov	r0, r6
 454 0236 9F40     		lsl	r7, r7, r3
 455 0238 391C     		mov	r1, r7
 456 023a FFF7FEFF 		bl	BCCUCH01_AbortLinearWalk
 457              	.LVL25:
 228:../i2c_comm.c **** 			if (DataTotal > 0x80)
 458              		.loc 1 228 0
 459 023e 3E4D     		ldr	r5, .L95+32
 460 0240 2988     		ldrh	r1, [r5]
 461 0242 8029     		cmp	r1, #128
 462 0244 01D9     		bls	.L23
 229:../i2c_comm.c **** 				DataTotal = 0x80;
 463              		.loc 1 229 0
 464 0246 8022     		mov	r2, #128
 465 0248 2A80     		strh	r2, [r5]
 466              	.L23:
 230:../i2c_comm.c **** 			DataTotal &= 0x00FF;
 467              		.loc 1 230 0
 468 024a 2978     		ldrb	r1, [r5]
 231:../i2c_comm.c **** 			BCCUCH01_SetIntensity(&BCCUCH01_Handle5, DataTotal);
 469              		.loc 1 231 0
 470 024c 301C     		mov	r0, r6
 230:../i2c_comm.c **** 			DataTotal &= 0x00FF;
 471              		.loc 1 230 0
 472 024e 2980     		strh	r1, [r5]
 473              		.loc 1 231 0
 474 0250 FFF7FEFF 		bl	BCCUCH01_SetIntensity
 475              	.LVL26:
 232:../i2c_comm.c **** 			BCCUCH01_StartLinearWalk(&BCCUCH01_Handle5, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle5.ChNum));
 476              		.loc 1 232 0
 477 0254 301C     		mov	r0, r6
 478 0256 391C     		mov	r1, r7
 479 0258 FFF7FEFF 		bl	BCCUCH01_StartLinearWalk
 480              	.LVL27:
 233:../i2c_comm.c **** 			byteCount = 0;
 481              		.loc 1 233 0
 482 025c 0020     		mov	r0, #0
 483 025e 2060     		str	r0, [r4]
 234:../i2c_comm.c **** 
 235:../i2c_comm.c **** 			flashBuffer[6] = DataTotal;
 484              		.loc 1 235 0
 485 0260 2988     		ldrh	r1, [r5]
 486 0262 7FE1     		b	.L89
 487              	.L22:
 236:../i2c_comm.c **** 		}
 237:../i2c_comm.c **** 
 238:../i2c_comm.c **** 
 239:../i2c_comm.c **** 		else if (Command == CURRENT_RGB) // RGB Current Command: Change peak current reference of red gre
 488              		.loc 1 239 0
 489 0264 2428     		cmp	r0, #36
 490 0266 23D1     		bne	.L24
 240:../i2c_comm.c **** 		{
 241:../i2c_comm.c **** 			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle3, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle3.ChNum));
 491              		.loc 1 241 0
 492 0268 384E     		ldr	r6, .L95+52
 493 026a 0127     		mov	r7, #1
 494 026c B368     		ldr	r3, [r6, #8]
 495 026e 391C     		mov	r1, r7
 496 0270 9940     		lsl	r1, r1, r3
 497 0272 301C     		mov	r0, r6
 498 0274 FFF7FEFF 		bl	BCCUCH01_AbortLinearWalk
 499              	.LVL28:
 242:../i2c_comm.c **** 			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle4, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle4.ChNum));
 500              		.loc 1 242 0
 501 0278 3548     		ldr	r0, .L95+56
 502 027a 8168     		ldr	r1, [r0, #8]
 503 027c 0A1C     		mov	r2, r1
 504 027e 391C     		mov	r1, r7
 505 0280 9140     		lsl	r1, r1, r2
 506 0282 FFF7FEFF 		bl	BCCUCH01_AbortLinearWalk
 507              	.LVL29:
 243:../i2c_comm.c **** 			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle5, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle5.ChNum));
 508              		.loc 1 243 0
 509 0286 3348     		ldr	r0, .L95+60
 510 0288 391C     		mov	r1, r7
 511 028a 8568     		ldr	r5, [r0, #8]
 512 028c A940     		lsl	r1, r1, r5
 513 028e FFF7FEFF 		bl	BCCUCH01_AbortLinearWalk
 514              	.LVL30:
 244:../i2c_comm.c **** 			if (DataTotal > 0x64)
 515              		.loc 1 244 0
 516 0292 294C     		ldr	r4, .L95+32
 517 0294 301C     		mov	r0, r6
 518 0296 2788     		ldrh	r7, [r4]
 519 0298 642F     		cmp	r7, #100
 520 029a 01D9     		bls	.L25
 245:../i2c_comm.c **** 				DataTotal = 0x64;
 521              		.loc 1 245 0
 522 029c 6426     		mov	r6, #100
 523 029e 2680     		strh	r6, [r4]
 524              	.L25:
 246:../i2c_comm.c **** 			DataTotal &= 0x00FF;
 525              		.loc 1 246 0
 526 02a0 2178     		ldrb	r1, [r4]
 527 02a2 2180     		strh	r1, [r4]
 247:../i2c_comm.c **** 			BCCUCH01_SetIntensity(&BCCUCH01_Handle3, DataTotal);
 528              		.loc 1 247 0
 529 02a4 FFF7FEFF 		bl	BCCUCH01_SetIntensity
 530              	.LVL31:
 248:../i2c_comm.c **** 			flashBuffer[4] = DataTotal;
 531              		.loc 1 248 0
 532 02a8 2088     		ldrh	r0, [r4]
 533              	.L87:
 534 02aa 214C     		ldr	r4, .L95+24
 535 02ac 2061     		str	r0, [r4, #16]
 536 02ae C7E1     		b	.L1
 537              	.L24:
 249:../i2c_comm.c **** 		}
 250:../i2c_comm.c **** 
 251:../i2c_comm.c **** 		else if (Command == CHANGEADDRESS) // Change Address of Slave
 538              		.loc 1 251 0
 539 02b0 7028     		cmp	r0, #112
 540 02b2 13D1     		bne	.L26
 252:../i2c_comm.c **** 		{
 253:../i2c_comm.c **** 			I2C003_Handle0.I2CRegs->PCR_IICMode &= 0xFFFF0000; // Clear the address register
 541              		.loc 1 253 0
 542 02b4 E86B     		ldr	r0, [r5, #60]
 254:../i2c_comm.c **** 			changeAddress = (DataUpper << 8) | DataLower; // Put Address into one variable
 543              		.loc 1 254 0
 544 02b6 1B4F     		ldr	r7, .L95+12
 253:../i2c_comm.c **** 			I2C003_Handle0.I2CRegs->PCR_IICMode &= 0xFFFF0000; // Clear the address register
 545              		.loc 1 253 0
 546 02b8 010C     		lsr	r1, r0, #16
 547              		.loc 1 254 0
 548 02ba 1B48     		ldr	r0, .L95+16
 253:../i2c_comm.c **** 			I2C003_Handle0.I2CRegs->PCR_IICMode &= 0xFFFF0000; // Clear the address register
 549              		.loc 1 253 0
 550 02bc 0A04     		lsl	r2, r1, #16
 551              		.loc 1 254 0
 552 02be 3E78     		ldrb	r6, [r7]
 253:../i2c_comm.c **** 			I2C003_Handle0.I2CRegs->PCR_IICMode &= 0xFFFF0000; // Clear the address register
 553              		.loc 1 253 0
 554 02c0 EA63     		str	r2, [r5, #60]
 555              		.loc 1 254 0
 556 02c2 0178     		ldrb	r1, [r0]
 255:../i2c_comm.c **** 			changeAddress &= 0x0000FFFF;
 256:../i2c_comm.c **** 			I2C003_Handle0.I2CRegs->PCR_IICMode |= changeAddress; // write into register
 557              		.loc 1 256 0
 558 02c4 EF6B     		ldr	r7, [r5, #60]
 254:../i2c_comm.c **** 			changeAddress = (DataUpper << 8) | DataLower; // Put Address into one variable
 559              		.loc 1 254 0
 560 02c6 3302     		lsl	r3, r6, #8
 255:../i2c_comm.c **** 			changeAddress &= 0x0000FFFF;
 561              		.loc 1 255 0
 562 02c8 0B43     		orr	r3, r1
 563              	.LVL32:
 564              		.loc 1 256 0
 565 02ca 1F43     		orr	r7, r3
 566              	.LVL33:
 567 02cc EF63     		str	r7, [r5, #60]
 257:../i2c_comm.c **** 			byteCount = 0;
 568              		.loc 1 257 0
 569 02ce 0025     		mov	r5, #0
 255:../i2c_comm.c **** 			changeAddress &= 0x0000FFFF;
 570              		.loc 1 255 0
 571 02d0 214A     		ldr	r2, .L95+64
 572              		.loc 1 257 0
 573 02d2 2560     		str	r5, [r4]
 258:../i2c_comm.c **** 
 259:../i2c_comm.c **** 			flashBuffer[22] = changeAddress;
 574              		.loc 1 259 0
 575 02d4 164C     		ldr	r4, .L95+24
 255:../i2c_comm.c **** 			changeAddress &= 0x0000FFFF;
 576              		.loc 1 255 0
 577 02d6 1360     		str	r3, [r2]
 578              		.loc 1 259 0
 579 02d8 A365     		str	r3, [r4, #88]
 580 02da B1E1     		b	.L1
 581              	.LVL34:
 582              	.L26:
 260:../i2c_comm.c **** 		}
 261:../i2c_comm.c **** 
 262:../i2c_comm.c **** 		else if (Command == OFFTIME_RED) // Change off-time of Red channel
 583              		.loc 1 262 0
 584 02dc 4128     		cmp	r0, #65
 585 02de 0CD1     		bne	.L27
 263:../i2c_comm.c **** 		{
 264:../i2c_comm.c **** 			DataTotal &= 0x00FF;
 586              		.loc 1 264 0
 587 02e0 154F     		ldr	r7, .L95+32
 265:../i2c_comm.c **** 			PWMSP003_UpdateCompare(&PWMSP003_Handle0, DataTotal, FALSE); // change compare value of pwm of r
 588              		.loc 1 265 0
 589 02e2 1E48     		ldr	r0, .L95+68
 264:../i2c_comm.c **** 			DataTotal &= 0x00FF;
 590              		.loc 1 264 0
 591 02e4 3978     		ldrb	r1, [r7]
 592              		.loc 1 265 0
 593 02e6 0022     		mov	r2, #0
 266:../i2c_comm.c **** 			byteCount = 0;
 594              		.loc 1 266 0
 595 02e8 0026     		mov	r6, #0
 264:../i2c_comm.c **** 			DataTotal &= 0x00FF;
 596              		.loc 1 264 0
 597 02ea 3980     		strh	r1, [r7]
 265:../i2c_comm.c **** 			PWMSP003_UpdateCompare(&PWMSP003_Handle0, DataTotal, FALSE); // change compare value of pwm of r
 598              		.loc 1 265 0
 599 02ec FFF7FEFF 		bl	PWMSP003_UpdateCompare
 600              	.LVL35:
 601              		.loc 1 266 0
 602 02f0 2660     		str	r6, [r4]
 267:../i2c_comm.c **** 
 268:../i2c_comm.c **** 			flashBuffer[16] = DataTotal;
 603              		.loc 1 268 0
 604 02f2 0F4B     		ldr	r3, .L95+24
 605 02f4 3C88     		ldrh	r4, [r7]
 606 02f6 1C64     		str	r4, [r3, #64]
 607 02f8 A2E1     		b	.L1
 608              	.L27:
 269:../i2c_comm.c **** 		}
 270:../i2c_comm.c **** 
 271:../i2c_comm.c **** 		else if (Command == OFFTIME_GREEN) // Change off-time of Green channel
 609              		.loc 1 271 0
 610 02fa 4228     		cmp	r0, #66
 611 02fc 32D1     		bne	.L28
 272:../i2c_comm.c **** 		{
 273:../i2c_comm.c **** 
 274:../i2c_comm.c **** 			DataTotal &= 0x00FF;
 612              		.loc 1 274 0
 613 02fe 0E4D     		ldr	r5, .L95+32
 275:../i2c_comm.c **** 			PWMSP003_UpdateCompare(&PWMSP003_Handle1, DataTotal, FALSE); // change compare value of pwm of g
 614              		.loc 1 275 0
 615 0300 0022     		mov	r2, #0
 274:../i2c_comm.c **** 			DataTotal &= 0x00FF;
 616              		.loc 1 274 0
 617 0302 2978     		ldrb	r1, [r5]
 618              		.loc 1 275 0
 619 0304 1648     		ldr	r0, .L95+72
 274:../i2c_comm.c **** 			DataTotal &= 0x00FF;
 620              		.loc 1 274 0
 621 0306 2980     		strh	r1, [r5]
 622              		.loc 1 275 0
 623 0308 FFF7FEFF 		bl	PWMSP003_UpdateCompare
 624              	.LVL36:
 276:../i2c_comm.c **** 			byteCount = 0;
 277:../i2c_comm.c **** 
 278:../i2c_comm.c **** 			flashBuffer[17] = DataTotal;
 625              		.loc 1 278 0
 626 030c 2988     		ldrh	r1, [r5]
 627 030e 084A     		ldr	r2, .L95+24
 276:../i2c_comm.c **** 			byteCount = 0;
 628              		.loc 1 276 0
 629 0310 0020     		mov	r0, #0
 630 0312 2060     		str	r0, [r4]
 631              		.loc 1 278 0
 632 0314 5164     		str	r1, [r2, #68]
 633 0316 93E1     		b	.L1
 634              	.L96:
 635              		.align	2
 636              	.L95:
 637 0318 00000000 		.word	I2C003_Handle0
 638 031c 00000000 		.word	byteCount
 639 0320 00000000 		.word	Command
 640 0324 00000000 		.word	DataUpper
 641 0328 00000000 		.word	DataLower
 642 032c 00000000 		.word	DMXControl
 643 0330 00000000 		.word	flashBuffer
 644 0334 00000000 		.word	writeToFlash
 645 0338 00000000 		.word	DataTotal
 646 033c 00000000 		.word	BCCUCH01_Handle0
 647 0340 00000000 		.word	BCCUCH01_Handle1
 648 0344 00000000 		.word	BCCUCH01_Handle2
 649 0348 00000000 		.word	Lamphandle
 650 034c 00000000 		.word	BCCUCH01_Handle3
 651 0350 00000000 		.word	BCCUCH01_Handle4
 652 0354 00000000 		.word	BCCUCH01_Handle5
 653 0358 00000000 		.word	changeAddress
 654 035c 00000000 		.word	PWMSP003_Handle0
 655 0360 00000000 		.word	PWMSP003_Handle1
 656              	.L28:
 279:../i2c_comm.c **** 		}
 280:../i2c_comm.c **** 
 281:../i2c_comm.c **** 		else if (Command == OFFTIME_BLUE) // Change offtime of Blue channel
 657              		.loc 1 281 0
 658 0364 4328     		cmp	r0, #67
 659 0366 0CD1     		bne	.L29
 282:../i2c_comm.c **** 		{
 283:../i2c_comm.c **** 
 284:../i2c_comm.c **** 			DataTotal &= 0x00FF;
 660              		.loc 1 284 0
 661 0368 B64D     		ldr	r5, .L97
 285:../i2c_comm.c **** 			PWMSP003_UpdateCompare(&PWMSP003_Handle2, DataTotal, FALSE); // change compare value of pwm of b
 662              		.loc 1 285 0
 663 036a B748     		ldr	r0, .L97+4
 284:../i2c_comm.c **** 			DataTotal &= 0x00FF;
 664              		.loc 1 284 0
 665 036c 2978     		ldrb	r1, [r5]
 666              		.loc 1 285 0
 667 036e 0022     		mov	r2, #0
 284:../i2c_comm.c **** 			DataTotal &= 0x00FF;
 668              		.loc 1 284 0
 669 0370 2980     		strh	r1, [r5]
 670              		.loc 1 285 0
 671 0372 FFF7FEFF 		bl	PWMSP003_UpdateCompare
 672              	.LVL37:
 286:../i2c_comm.c **** 			byteCount = 0;
 287:../i2c_comm.c **** 
 288:../i2c_comm.c **** 			flashBuffer[18] = DataTotal;
 673              		.loc 1 288 0
 674 0376 2E88     		ldrh	r6, [r5]
 675 0378 B44B     		ldr	r3, .L97+8
 286:../i2c_comm.c **** 			byteCount = 0;
 676              		.loc 1 286 0
 677 037a 0027     		mov	r7, #0
 678 037c 2760     		str	r7, [r4]
 679              		.loc 1 288 0
 680 037e 9E64     		str	r6, [r3, #72]
 681 0380 5EE1     		b	.L1
 682              	.L29:
 289:../i2c_comm.c **** 
 290:../i2c_comm.c **** 		}
 291:../i2c_comm.c **** 
 292:../i2c_comm.c **** 		else if (Command == WALKTIME) // Change Walk Time
 683              		.loc 1 292 0
 684 0382 5028     		cmp	r0, #80
 685 0384 1BD1     		bne	.L30
 293:../i2c_comm.c **** 		{
 294:../i2c_comm.c **** 			DataTotal &= 0x03FF; // Mask data. Walktime is 10 bit, not 12 bit information
 686              		.loc 1 294 0
 687 0386 AF4D     		ldr	r5, .L97
 688 0388 2F88     		ldrh	r7, [r5]
 689 038a BE05     		lsl	r6, r7, #22
 690 038c B30D     		lsr	r3, r6, #22
 295:../i2c_comm.c **** 			if (DataTotal < 0xF)
 691              		.loc 1 295 0
 692 038e 0E2B     		cmp	r3, #14
 693 0390 00D8     		bhi	.L85
 694              	.L31:
 296:../i2c_comm.c **** 				DataTotal = 0xF;
 695              		.loc 1 296 0
 696 0392 0F23     		mov	r3, #15
 697              	.L85:
 698 0394 2B80     		strh	r3, [r5]
 297:../i2c_comm.c **** 			BCCUCH01_SetLinearWalkPrescaler(&BCCUCH01_Handle0, DataTotal); // Red channel
 699              		.loc 1 297 0
 700 0396 2988     		ldrh	r1, [r5]
 701 0398 AD48     		ldr	r0, .L97+12
 702 039a FFF7FEFF 		bl	BCCUCH01_SetLinearWalkPrescaler
 703              	.LVL38:
 298:../i2c_comm.c **** 			BCCUCH01_SetLinearWalkPrescaler(&BCCUCH01_Handle1, DataTotal); // Green channel
 704              		.loc 1 298 0
 705 039e 2988     		ldrh	r1, [r5]
 706 03a0 AC48     		ldr	r0, .L97+16
 707 03a2 FFF7FEFF 		bl	BCCUCH01_SetLinearWalkPrescaler
 708              	.LVL39:
 299:../i2c_comm.c **** 			BCCUCH01_SetLinearWalkPrescaler(&BCCUCH01_Handle2, DataTotal); // Blue channel
 709              		.loc 1 299 0
 710 03a6 2988     		ldrh	r1, [r5]
 711 03a8 AB48     		ldr	r0, .L97+20
 712 03aa FFF7FEFF 		bl	BCCUCH01_SetLinearWalkPrescaler
 713              	.LVL40:
 300:../i2c_comm.c **** 			Lamphandle.LinearWalkPrescaler = DataTotal; // change linear walk in lamphandle enum
 301:../i2c_comm.c **** 			byteCount = 0;
 714              		.loc 1 301 0
 715 03ae 0022     		mov	r2, #0
 300:../i2c_comm.c **** 			Lamphandle.LinearWalkPrescaler = DataTotal; // change linear walk in lamphandle enum
 716              		.loc 1 300 0
 717 03b0 2888     		ldrh	r0, [r5]
 718 03b2 AA49     		ldr	r1, .L97+24
 719              		.loc 1 301 0
 720 03b4 2260     		str	r2, [r4]
 302:../i2c_comm.c **** 
 303:../i2c_comm.c **** 			flashBuffer[19] = DataTotal;
 721              		.loc 1 303 0
 722 03b6 A54C     		ldr	r4, .L97+8
 300:../i2c_comm.c **** 			Lamphandle.LinearWalkPrescaler = DataTotal; // change linear walk in lamphandle enum
 723              		.loc 1 300 0
 724 03b8 8861     		str	r0, [r1, #24]
 725              		.loc 1 303 0
 726 03ba E064     		str	r0, [r4, #76]
 727 03bc 40E1     		b	.L1
 728              	.L30:
 304:../i2c_comm.c **** 		}
 305:../i2c_comm.c **** 
 306:../i2c_comm.c **** 		else if (Command == DIMMINGLEVEL) // Change dimming Level
 729              		.loc 1 306 0
 730 03be 6028     		cmp	r0, #96
 731 03c0 1DD1     		bne	.L33
 307:../i2c_comm.c **** 		{
 308:../i2c_comm.c **** 			BCCUDIM01_AbortDimming(&BCCUDIM01_Handle0, GET_CHANNEL_DIM_MASK(BCCUDIM01_Handle0.DE_Num)); // A
 732              		.loc 1 308 0
 733 03c2 A74D     		ldr	r5, .L97+28
 734 03c4 2F7A     		ldrb	r7, [r5, #8]
 735 03c6 381C     		mov	r0, r7
 736 03c8 FFF7FEFF 		bl	GET_CHANNEL_DIM_MASK
 737              	.LVL41:
 738 03cc 011C     		mov	r1, r0
 739 03ce 281C     		mov	r0, r5
 740 03d0 FFF7FEFF 		bl	BCCUDIM01_AbortDimming
 741              	.LVL42:
 309:../i2c_comm.c **** 			DataTotal &= 0x0FFF; // Mask data. Dimming is only 12 bit information, not 16 bits
 742              		.loc 1 309 0
 743 03d4 9B4E     		ldr	r6, .L97
 744 03d6 3388     		ldrh	r3, [r6]
 745 03d8 1805     		lsl	r0, r3, #20
 746 03da 010D     		lsr	r1, r0, #20
 310:../i2c_comm.c **** 			BCCUDIM01_SetDimLvl(&BCCUDIM01_Handle0, DataTotal); // dimming engine 2
 747              		.loc 1 310 0
 748 03dc 281C     		mov	r0, r5
 309:../i2c_comm.c **** 			DataTotal &= 0x0FFF; // Mask data. Dimming is only 12 bit information, not 16 bits
 749              		.loc 1 309 0
 750 03de 3180     		strh	r1, [r6]
 751              		.loc 1 310 0
 752 03e0 FFF7FEFF 		bl	BCCUDIM01_SetDimLvl
 753              	.LVL43:
 311:../i2c_comm.c **** 			BCCUDIM01_StartDimming(&BCCUDIM01_Handle0, GET_CHANNEL_DIM_MASK(BCCUDIM01_Handle0.DE_Num));
 754              		.loc 1 311 0
 755 03e4 381C     		mov	r0, r7
 756 03e6 FFF7FEFF 		bl	GET_CHANNEL_DIM_MASK
 757              	.LVL44:
 758 03ea 011C     		mov	r1, r0
 759 03ec 281C     		mov	r0, r5
 760 03ee FFF7FEFF 		bl	BCCUDIM01_StartDimming
 761              	.LVL45:
 312:../i2c_comm.c **** 			byteCount = 0;
 762              		.loc 1 312 0
 763 03f2 0021     		mov	r1, #0
 764 03f4 2160     		str	r1, [r4]
 313:../i2c_comm.c **** 
 314:../i2c_comm.c **** 			flashBuffer[20] = DataTotal;
 765              		.loc 1 314 0
 766 03f6 3288     		ldrh	r2, [r6]
 767 03f8 944C     		ldr	r4, .L97+8
 768 03fa 2265     		str	r2, [r4, #80]
 769 03fc 20E1     		b	.L1
 770              	.L33:
 315:../i2c_comm.c **** 		}
 316:../i2c_comm.c **** 
 317:../i2c_comm.c **** 		else if (Command == FADERATE) // Fade Rate
 771              		.loc 1 317 0
 772 03fe 6128     		cmp	r0, #97
 773 0400 15D1     		bne	.L34
 318:../i2c_comm.c **** 		{
 319:../i2c_comm.c **** 			BCCUDIM01_AbortDimming(&BCCUDIM01_Handle0, GET_CHANNEL_DIM_MASK(BCCUDIM01_Handle0.DE_Num));
 774              		.loc 1 319 0
 775 0402 974F     		ldr	r7, .L97+28
 320:../i2c_comm.c **** 			DataTotal &= 0x03FF; // 10bit number
 321:../i2c_comm.c **** 			BCCUDIM01_SetDimDiv(&BCCUDIM01_Handle0, DataTotal); // dimming engine 2
 322:../i2c_comm.c **** 			byteCount = 0;
 776              		.loc 1 322 0
 777 0404 0026     		mov	r6, #0
 319:../i2c_comm.c **** 			BCCUDIM01_AbortDimming(&BCCUDIM01_Handle0, GET_CHANNEL_DIM_MASK(BCCUDIM01_Handle0.DE_Num));
 778              		.loc 1 319 0
 779 0406 387A     		ldrb	r0, [r7, #8]
 780 0408 FFF7FEFF 		bl	GET_CHANNEL_DIM_MASK
 781              	.LVL46:
 782 040c 011C     		mov	r1, r0
 783 040e 381C     		mov	r0, r7
 784 0410 FFF7FEFF 		bl	BCCUDIM01_AbortDimming
 785              	.LVL47:
 320:../i2c_comm.c **** 			DataTotal &= 0x03FF; // 10bit number
 786              		.loc 1 320 0
 787 0414 8B4D     		ldr	r5, .L97
 788 0416 2888     		ldrh	r0, [r5]
 789 0418 8105     		lsl	r1, r0, #22
 790 041a 890D     		lsr	r1, r1, #22
 321:../i2c_comm.c **** 			BCCUDIM01_SetDimDiv(&BCCUDIM01_Handle0, DataTotal); // dimming engine 2
 791              		.loc 1 321 0
 792 041c 381C     		mov	r0, r7
 320:../i2c_comm.c **** 			DataTotal &= 0x03FF; // 10bit number
 793              		.loc 1 320 0
 794 041e 2980     		strh	r1, [r5]
 321:../i2c_comm.c **** 			BCCUDIM01_SetDimDiv(&BCCUDIM01_Handle0, DataTotal); // dimming engine 2
 795              		.loc 1 321 0
 796 0420 FFF7FEFF 		bl	BCCUDIM01_SetDimDiv
 797              	.LVL48:
 798              		.loc 1 322 0
 799 0424 2660     		str	r6, [r4]
 323:../i2c_comm.c **** 
 324:../i2c_comm.c **** 			flashBuffer[21] = DataTotal;
 800              		.loc 1 324 0
 801 0426 2A88     		ldrh	r2, [r5]
 802 0428 884C     		ldr	r4, .L97+8
 803 042a 6265     		str	r2, [r4, #84]
 804 042c 08E1     		b	.L1
 805              	.L34:
 325:../i2c_comm.c **** 		}
 326:../i2c_comm.c **** 
 327:../i2c_comm.c **** 		else if (Command == DIRECTACCESS_READ || Command == DIRECTACCESS_MOVE || Command == DIRECTACCESS_
 806              		.loc 1 327 0
 807 042e 051C     		mov	r5, r0
 808 0430 7035     		add	r5, r5, #112
 809 0432 E9B2     		uxtb	r1, r5
 810 0434 0329     		cmp	r1, #3
 811 0436 03D8     		bhi	.L35
 328:../i2c_comm.c **** 		{
 329:../i2c_comm.c **** 			// Direct Access commands. The first 4 bytes being sent are the register address. Lower 16 bits 
 330:../i2c_comm.c **** 			registerAddress = 0;
 331:../i2c_comm.c **** 			registerAddress = DataTotal;
 812              		.loc 1 331 0
 813 0438 824B     		ldr	r3, .L97
 814 043a 8A4D     		ldr	r5, .L97+32
 815 043c 1A88     		ldrh	r2, [r3]
 816 043e 52E0     		b	.L90
 817              	.L35:
 332:../i2c_comm.c **** 		}
 333:../i2c_comm.c **** 
 334:../i2c_comm.c **** 		else if (Command == DMXSLOT) // Starting slot number of DMX
 818              		.loc 1 334 0
 819 0440 3228     		cmp	r0, #50
 820 0442 08D1     		bne	.L36
 335:../i2c_comm.c **** 		{
 336:../i2c_comm.c **** 			startingSlot = DataTotal;
 821              		.loc 1 336 0
 822 0444 7F49     		ldr	r1, .L97
 337:../i2c_comm.c **** 			byteCount = 0;
 823              		.loc 1 337 0
 824 0446 0022     		mov	r2, #0
 336:../i2c_comm.c **** 			startingSlot = DataTotal;
 825              		.loc 1 336 0
 826 0448 0F88     		ldrh	r7, [r1]
 827 044a 874E     		ldr	r6, .L97+36
 828              		.loc 1 337 0
 829 044c 2260     		str	r2, [r4]
 338:../i2c_comm.c **** 
 339:../i2c_comm.c **** 			flashBuffer[8] = DataTotal;
 830              		.loc 1 339 0
 831 044e 7F4C     		ldr	r4, .L97+8
 336:../i2c_comm.c **** 			startingSlot = DataTotal;
 832              		.loc 1 336 0
 833 0450 3780     		strh	r7, [r6]
 834              		.loc 1 339 0
 835 0452 2762     		str	r7, [r4, #32]
 836 0454 F4E0     		b	.L1
 837              	.L36:
 340:../i2c_comm.c **** 		}
 341:../i2c_comm.c **** 
 342:../i2c_comm.c **** 		else if (Command == DMX8BIT) // Configuration for 8 bit DMX
 838              		.loc 1 342 0
 839 0456 3328     		cmp	r0, #51
 840 0458 0CD1     		bne	.L37
 343:../i2c_comm.c **** 		{
 344:../i2c_comm.c **** 			DMX_8 = 1; // Set status of 8 bit DMX
 345:../i2c_comm.c **** 			DMX_16 = 0; // Clear 16 bit
 346:../i2c_comm.c **** 
 347:../i2c_comm.c **** 			dmx_RedH = DataTotal; // First 16 bits contains information for Red Slot
 841              		.loc 1 347 0
 842 045a 7A48     		ldr	r0, .L97
 344:../i2c_comm.c **** 			DMX_8 = 1; // Set status of 8 bit DMX
 843              		.loc 1 344 0
 844 045c 834E     		ldr	r6, .L97+40
 345:../i2c_comm.c **** 			DMX_16 = 0; // Clear 16 bit
 845              		.loc 1 345 0
 846 045e 844B     		ldr	r3, .L97+44
 847              		.loc 1 347 0
 848 0460 0088     		ldrh	r0, [r0]
 849 0462 844D     		ldr	r5, .L97+48
 344:../i2c_comm.c **** 			DMX_8 = 1; // Set status of 8 bit DMX
 850              		.loc 1 344 0
 851 0464 0127     		mov	r7, #1
 345:../i2c_comm.c **** 			DMX_16 = 0; // Clear 16 bit
 852              		.loc 1 345 0
 853 0466 0022     		mov	r2, #0
 344:../i2c_comm.c **** 			DMX_8 = 1; // Set status of 8 bit DMX
 854              		.loc 1 344 0
 855 0468 3760     		str	r7, [r6]
 345:../i2c_comm.c **** 			DMX_16 = 0; // Clear 16 bit
 856              		.loc 1 345 0
 857 046a 1A60     		str	r2, [r3]
 858              		.loc 1 347 0
 859 046c 2880     		strh	r0, [r5]
 348:../i2c_comm.c **** 			flashBuffer[9] = 0x8;
 860              		.loc 1 348 0
 861 046e 774C     		ldr	r4, .L97+8
 862 0470 0821     		mov	r1, #8
 863 0472 0EE0     		b	.L92
 864              	.L37:
 349:../i2c_comm.c **** 			flashBuffer[10] = DataTotal;
 350:../i2c_comm.c **** 		}
 351:../i2c_comm.c **** 
 352:../i2c_comm.c **** 
 353:../i2c_comm.c **** 		else if (Command == DMX16BIT) // Configuration for 16 bit DMX
 865              		.loc 1 353 0
 866 0474 3428     		cmp	r0, #52
 867 0476 00D0     		beq	.LCB695
 868 0478 E2E0     		b	.L1	@long jump
 869              	.LCB695:
 354:../i2c_comm.c **** 		{
 355:../i2c_comm.c **** 			DMX_8 = 0; // Clear status of 8 bit DMX
 356:../i2c_comm.c **** 			DMX_16 = 1; // Set status of 16 bit DMX
 357:../i2c_comm.c **** 
 358:../i2c_comm.c **** 
 359:../i2c_comm.c **** 			dmx_RedH = DataTotal;
 870              		.loc 1 359 0
 871 047a 724A     		ldr	r2, .L97
 355:../i2c_comm.c **** 			DMX_8 = 0; // Clear status of 8 bit DMX
 872              		.loc 1 355 0
 873 047c 7B4F     		ldr	r7, .L97+40
 874 047e 0024     		mov	r4, #0
 356:../i2c_comm.c **** 			DMX_16 = 1; // Set status of 16 bit DMX
 875              		.loc 1 356 0
 876 0480 7B4B     		ldr	r3, .L97+44
 877              		.loc 1 359 0
 878 0482 1088     		ldrh	r0, [r2]
 879 0484 7B4D     		ldr	r5, .L97+48
 355:../i2c_comm.c **** 			DMX_8 = 0; // Clear status of 8 bit DMX
 880              		.loc 1 355 0
 881 0486 3C60     		str	r4, [r7]
 356:../i2c_comm.c **** 			DMX_16 = 1; // Set status of 16 bit DMX
 882              		.loc 1 356 0
 883 0488 0126     		mov	r6, #1
 360:../i2c_comm.c **** 			flashBuffer[9] = 0x16;
 884              		.loc 1 360 0
 885 048a 704C     		ldr	r4, .L97+8
 356:../i2c_comm.c **** 			DMX_16 = 1; // Set status of 16 bit DMX
 886              		.loc 1 356 0
 887 048c 1E60     		str	r6, [r3]
 359:../i2c_comm.c **** 			dmx_RedH = DataTotal;
 888              		.loc 1 359 0
 889 048e 2880     		strh	r0, [r5]
 890              		.loc 1 360 0
 891 0490 1621     		mov	r1, #22
 892              	.L92:
 893 0492 6162     		str	r1, [r4, #36]
 361:../i2c_comm.c **** 			flashBuffer[10] = DataTotal;
 894              		.loc 1 361 0
 895 0494 A062     		str	r0, [r4, #40]
 896 0496 D3E0     		b	.L1
 897              	.L12:
 362:../i2c_comm.c **** 		}
 363:../i2c_comm.c **** 
 364:../i2c_comm.c **** 
 365:../i2c_comm.c **** 	}
 366:../i2c_comm.c **** 
 367:../i2c_comm.c **** 
 368:../i2c_comm.c **** 
 369:../i2c_comm.c **** 	else if (byteCount == 5) // Another 2 bytes of data received
 898              		.loc 1 369 0
 899 0498 052E     		cmp	r6, #5
 900 049a 32D1     		bne	.L38
 370:../i2c_comm.c **** 	{
 371:../i2c_comm.c **** 
 372:../i2c_comm.c **** 		if (Command == INTENSITY_RGB) // Green color intensity data
 901              		.loc 1 372 0
 902 049c 764C     		ldr	r4, .L97+52
 903 049e 2078     		ldrb	r0, [r4]
 904 04a0 1428     		cmp	r0, #20
 905 04a2 09D1     		bne	.L39
 373:../i2c_comm.c **** 		{
 374:../i2c_comm.c **** 			DataTotal &= 0x0FFF;
 906              		.loc 1 374 0
 907 04a4 674C     		ldr	r4, .L97
 375:../i2c_comm.c **** 			Lamphandle.Intensity_Green = DataTotal;
 908              		.loc 1 375 0
 909 04a6 6D4E     		ldr	r6, .L97+24
 374:../i2c_comm.c **** 			DataTotal &= 0x0FFF;
 910              		.loc 1 374 0
 911 04a8 2088     		ldrh	r0, [r4]
 376:../i2c_comm.c **** 			flashBuffer[2] = DataTotal;
 912              		.loc 1 376 0
 913 04aa 684B     		ldr	r3, .L97+8
 374:../i2c_comm.c **** 			DataTotal &= 0x0FFF;
 914              		.loc 1 374 0
 915 04ac 0105     		lsl	r1, r0, #20
 916 04ae 0F0D     		lsr	r7, r1, #20
 917 04b0 2780     		strh	r7, [r4]
 375:../i2c_comm.c **** 			Lamphandle.Intensity_Green = DataTotal;
 918              		.loc 1 375 0
 919 04b2 7760     		str	r7, [r6, #4]
 920              		.loc 1 376 0
 921 04b4 9F60     		str	r7, [r3, #8]
 922 04b6 C3E0     		b	.L1
 923              	.L39:
 377:../i2c_comm.c **** 		}
 378:../i2c_comm.c **** 
 379:../i2c_comm.c **** 		else if (Command == CURRENT_RGB) // green peak current reference data
 924              		.loc 1 379 0
 925 04b8 2428     		cmp	r0, #36
 926 04ba 09D1     		bne	.L40
 380:../i2c_comm.c **** 		{
 381:../i2c_comm.c **** 			DataTotal &= 0x00FF;
 927              		.loc 1 381 0
 928 04bc 614D     		ldr	r5, .L97
 382:../i2c_comm.c **** 			BCCUCH01_SetIntensity(&BCCUCH01_Handle4, DataTotal);
 929              		.loc 1 382 0
 930 04be 6F48     		ldr	r0, .L97+56
 381:../i2c_comm.c **** 			DataTotal &= 0x00FF;
 931              		.loc 1 381 0
 932 04c0 2978     		ldrb	r1, [r5]
 933 04c2 2980     		strh	r1, [r5]
 934              		.loc 1 382 0
 935 04c4 FFF7FEFF 		bl	BCCUCH01_SetIntensity
 936              	.LVL49:
 383:../i2c_comm.c **** 			flashBuffer[5] = DataTotal;
 937              		.loc 1 383 0
 938 04c8 2A88     		ldrh	r2, [r5]
 939              	.L88:
 940 04ca 604C     		ldr	r4, .L97+8
 941 04cc 6261     		str	r2, [r4, #20]
 942 04ce B7E0     		b	.L1
 943              	.L40:
 384:../i2c_comm.c **** 		}
 385:../i2c_comm.c **** 
 386:../i2c_comm.c **** 		else if (Command == DIRECTACCESS_READ || Command == DIRECTACCESS_MOVE || Command == DIRECTACCESS_
 944              		.loc 1 386 0
 945 04d0 011C     		mov	r1, r0
 946 04d2 7031     		add	r1, r1, #112
 947 04d4 CFB2     		uxtb	r7, r1
 948 04d6 032F     		cmp	r7, #3
 949 04d8 07D8     		bhi	.L41
 387:../i2c_comm.c **** 		{
 388:../i2c_comm.c **** 			registerAddress = registerAddress << 16;
 389:../i2c_comm.c **** 			registerAddress |= DataTotal; // get registerAddress;
 950              		.loc 1 389 0
 951 04da 624D     		ldr	r5, .L97+32
 952 04dc 594E     		ldr	r6, .L97
 388:../i2c_comm.c **** 			registerAddress = registerAddress << 16;
 953              		.loc 1 388 0
 954 04de 2B68     		ldr	r3, [r5]
 955              		.loc 1 389 0
 956 04e0 3488     		ldrh	r4, [r6]
 388:../i2c_comm.c **** 			registerAddress = registerAddress << 16;
 957              		.loc 1 388 0
 958 04e2 1A04     		lsl	r2, r3, #16
 959              	.L91:
 960              		.loc 1 389 0
 961 04e4 2243     		orr	r2, r4
 962              	.L90:
 963 04e6 2A60     		str	r2, [r5]
 964 04e8 AAE0     		b	.L1
 965              	.L41:
 390:../i2c_comm.c **** 		}
 391:../i2c_comm.c **** 
 392:../i2c_comm.c **** 		else if (Command == DMX8BIT)
 966              		.loc 1 392 0
 967 04ea 3328     		cmp	r0, #51
 968 04ec 53D0     		beq	.L93
 969              	.L42:
 393:../i2c_comm.c **** 		{
 394:../i2c_comm.c **** 			dmx_GreenH = DataTotal; // if 8 bit DMX, dmx slot containing green colour intensity data
 395:../i2c_comm.c **** 			flashBuffer[12] = DataTotal;
 396:../i2c_comm.c **** 		}
 397:../i2c_comm.c **** 
 398:../i2c_comm.c **** 		else if (Command == DMX16BIT)
 970              		.loc 1 398 0
 971 04ee 3428     		cmp	r0, #52
 972 04f0 00D0     		beq	.LCB781
 973 04f2 A5E0     		b	.L1	@long jump
 974              	.LCB781:
 399:../i2c_comm.c **** 		{
 400:../i2c_comm.c **** 
 401:../i2c_comm.c **** 			dmx_RedL = DataTotal; // if 16 bit DMX, dmx slot containing lower red colour intensity data
 975              		.loc 1 401 0
 976 04f4 534D     		ldr	r5, .L97
 977 04f6 624B     		ldr	r3, .L97+60
 978 04f8 2E88     		ldrh	r6, [r5]
 402:../i2c_comm.c **** 
 403:../i2c_comm.c **** 			flashBuffer[11] = dmx_RedL;
 979              		.loc 1 403 0
 980 04fa 544A     		ldr	r2, .L97+8
 401:../i2c_comm.c **** 			dmx_RedL = DataTotal; // if 16 bit DMX, dmx slot containing lower red colour intensity data
 981              		.loc 1 401 0
 982 04fc 1E80     		strh	r6, [r3]
 983              		.loc 1 403 0
 984 04fe D662     		str	r6, [r2, #44]
 985 0500 9EE0     		b	.L1
 986              	.L38:
 404:../i2c_comm.c **** 
 405:../i2c_comm.c **** 		}
 406:../i2c_comm.c **** 
 407:../i2c_comm.c **** 	}
 408:../i2c_comm.c **** 
 409:../i2c_comm.c **** 	else if (byteCount == 7) // Another 2 bytes of data received
 987              		.loc 1 409 0
 988 0502 072E     		cmp	r6, #7
 989 0504 4ED1     		bne	.L43
 410:../i2c_comm.c **** 	{
 411:../i2c_comm.c **** 
 412:../i2c_comm.c **** 
 413:../i2c_comm.c **** 		if (Command == INTENSITY_RGB) // colour intensity of blue channel
 990              		.loc 1 413 0
 991 0506 5C4A     		ldr	r2, .L97+52
 992 0508 1578     		ldrb	r5, [r2]
 993 050a 142D     		cmp	r5, #20
 994 050c 0DD1     		bne	.L44
 414:../i2c_comm.c **** 		{
 415:../i2c_comm.c **** 			DataTotal &= 0x0FFF;
 995              		.loc 1 415 0
 996 050e 4D4F     		ldr	r7, .L97
 416:../i2c_comm.c **** 			Lamphandle.Intensity_Blue = DataTotal;
 997              		.loc 1 416 0
 998 0510 5249     		ldr	r1, .L97+24
 415:../i2c_comm.c **** 			DataTotal &= 0x0FFF;
 999              		.loc 1 415 0
 1000 0512 3D88     		ldrh	r5, [r7]
 417:../i2c_comm.c **** 			COLORLAMP01_SetColor(&COLORLAMP01_ConfigHandle0, &Lamphandle);
 1001              		.loc 1 417 0
 1002 0514 5B48     		ldr	r0, .L97+64
 415:../i2c_comm.c **** 			DataTotal &= 0x0FFF;
 1003              		.loc 1 415 0
 1004 0516 2E05     		lsl	r6, r5, #20
 1005 0518 330D     		lsr	r3, r6, #20
 1006 051a 3B80     		strh	r3, [r7]
 416:../i2c_comm.c **** 			Lamphandle.Intensity_Blue = DataTotal;
 1007              		.loc 1 416 0
 1008 051c 8B60     		str	r3, [r1, #8]
 1009              		.loc 1 417 0
 1010 051e FFF7FEFF 		bl	COLORLAMP01_SetColor
 1011              	.LVL50:
 418:../i2c_comm.c **** 			flashBuffer[3] = DataTotal;
 1012              		.loc 1 418 0
 1013 0522 3A88     		ldrh	r2, [r7]
 1014              	.L86:
 1015 0524 494C     		ldr	r4, .L97+8
 1016 0526 E260     		str	r2, [r4, #12]
 1017 0528 8AE0     		b	.L1
 1018              	.L44:
 419:../i2c_comm.c **** 		}
 420:../i2c_comm.c **** 
 421:../i2c_comm.c **** 		else if (Command == CURRENT_RGB) // peak current reference of blue channel
 1019              		.loc 1 421 0
 1020 052a 242D     		cmp	r5, #36
 1021 052c 1DD1     		bne	.L45
 422:../i2c_comm.c **** 		{
 423:../i2c_comm.c **** 			DataTotal &= 0x00FF;
 1022              		.loc 1 423 0
 1023 052e 454F     		ldr	r7, .L97
 424:../i2c_comm.c **** 			BCCUCH01_SetIntensity(&BCCUCH01_Handle5, DataTotal);
 1024              		.loc 1 424 0
 1025 0530 554D     		ldr	r5, .L97+68
 423:../i2c_comm.c **** 			DataTotal &= 0x00FF;
 1026              		.loc 1 423 0
 1027 0532 3978     		ldrb	r1, [r7]
 1028              		.loc 1 424 0
 1029 0534 281C     		mov	r0, r5
 423:../i2c_comm.c **** 			DataTotal &= 0x00FF;
 1030              		.loc 1 423 0
 1031 0536 3980     		strh	r1, [r7]
 1032              		.loc 1 424 0
 1033 0538 FFF7FEFF 		bl	BCCUCH01_SetIntensity
 1034              	.LVL51:
 425:../i2c_comm.c **** 			BCCUCH01_StartLinearWalk(&BCCUCH01_Handle3, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle3.ChNum));
 1035              		.loc 1 425 0
 1036 053c 5348     		ldr	r0, .L97+72
 1037 053e 0126     		mov	r6, #1
 1038 0540 8368     		ldr	r3, [r0, #8]
 1039 0542 311C     		mov	r1, r6
 1040 0544 9940     		lsl	r1, r1, r3
 1041 0546 FFF7FEFF 		bl	BCCUCH01_StartLinearWalk
 1042              	.LVL52:
 426:../i2c_comm.c **** 			BCCUCH01_StartLinearWalk(&BCCUCH01_Handle4, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle4.ChNum));
 1043              		.loc 1 426 0
 1044 054a 4C48     		ldr	r0, .L97+56
 1045 054c 311C     		mov	r1, r6
 1046 054e 8468     		ldr	r4, [r0, #8]
 1047 0550 A140     		lsl	r1, r1, r4
 1048 0552 FFF7FEFF 		bl	BCCUCH01_StartLinearWalk
 1049              	.LVL53:
 427:../i2c_comm.c **** 			BCCUCH01_StartLinearWalk(&BCCUCH01_Handle5, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle5.ChNum));
 1050              		.loc 1 427 0
 1051 0556 A868     		ldr	r0, [r5, #8]
 1052 0558 311C     		mov	r1, r6
 1053 055a 8140     		lsl	r1, r1, r0
 1054 055c 281C     		mov	r0, r5
 1055 055e FFF7FEFF 		bl	BCCUCH01_StartLinearWalk
 1056              	.LVL54:
 428:../i2c_comm.c **** 			flashBuffer[6] = DataTotal;
 1057              		.loc 1 428 0
 1058 0562 3988     		ldrh	r1, [r7]
 1059              	.L89:
 1060 0564 394C     		ldr	r4, .L97+8
 1061 0566 A161     		str	r1, [r4, #24]
 1062 0568 6AE0     		b	.L1
 1063              	.L45:
 429:../i2c_comm.c **** 		}
 430:../i2c_comm.c **** 
 431:../i2c_comm.c **** 		else if (Command == DIRECTACCESS_MOVE || Command == DIRECTACCESS_AND  || Command == DIRECTACCESS_
 1064              		.loc 1 431 0
 1065 056a 2F1C     		mov	r7, r5
 1066 056c 6F37     		add	r7, r7, #111
 1067 056e FBB2     		uxtb	r3, r7
 1068 0570 022B     		cmp	r3, #2
 1069 0572 03D8     		bhi	.L46
 432:../i2c_comm.c **** 		{
 433:../i2c_comm.c **** 			DataDirect = 0;
 434:../i2c_comm.c **** 			DataDirect = DataTotal;
 1070              		.loc 1 434 0
 1071 0574 334C     		ldr	r4, .L97
 1072 0576 464D     		ldr	r5, .L97+76
 1073 0578 2288     		ldrh	r2, [r4]
 1074 057a B4E7     		b	.L90
 1075              	.L46:
 435:../i2c_comm.c **** 		}
 436:../i2c_comm.c **** 
 437:../i2c_comm.c **** 		else if (Command == DMX8BIT) // if dmx 8 bit, dmx slot of blue data
 1076              		.loc 1 437 0
 1077 057c 332D     		cmp	r5, #51
 1078 057e 08D1     		bne	.L47
 438:../i2c_comm.c **** 		{
 439:../i2c_comm.c **** 			dmx_BlueH = DataTotal;
 1079              		.loc 1 439 0
 1080 0580 3049     		ldr	r1, .L97
 1081 0582 444E     		ldr	r6, .L97+80
 1082 0584 0888     		ldrh	r0, [r1]
 440:../i2c_comm.c **** 			flashBuffer[14] = DataTotal;
 1083              		.loc 1 440 0
 1084 0586 314A     		ldr	r2, .L97+8
 441:../i2c_comm.c **** 			byteCount = 0;
 1085              		.loc 1 441 0
 1086 0588 0025     		mov	r5, #0
 439:../i2c_comm.c **** 			dmx_BlueH = DataTotal;
 1087              		.loc 1 439 0
 1088 058a 3080     		strh	r0, [r6]
 440:../i2c_comm.c **** 			flashBuffer[14] = DataTotal;
 1089              		.loc 1 440 0
 1090 058c 9063     		str	r0, [r2, #56]
 1091              		.loc 1 441 0
 1092 058e 2560     		str	r5, [r4]
 1093 0590 56E0     		b	.L1
 1094              	.L47:
 442:../i2c_comm.c **** 		}
 443:../i2c_comm.c **** 
 444:../i2c_comm.c **** 		else if (Command == DMX16BIT) // if dmx 16 bit, dmx slot containing higher green colour intensity
 1095              		.loc 1 444 0
 1096 0592 342D     		cmp	r5, #52
 1097 0594 54D1     		bne	.L1
 1098              	.L93:
 445:../i2c_comm.c **** 		{
 446:../i2c_comm.c **** 			dmx_GreenH = DataTotal;
 1099              		.loc 1 446 0
 1100 0596 2B4C     		ldr	r4, .L97
 1101 0598 3F49     		ldr	r1, .L97+84
 1102 059a 2088     		ldrh	r0, [r4]
 447:../i2c_comm.c **** 			flashBuffer[12] = DataTotal;
 1103              		.loc 1 447 0
 1104 059c 2B4F     		ldr	r7, .L97+8
 446:../i2c_comm.c **** 			dmx_GreenH = DataTotal;
 1105              		.loc 1 446 0
 1106 059e 0880     		strh	r0, [r1]
 1107              		.loc 1 447 0
 1108 05a0 3863     		str	r0, [r7, #48]
 1109 05a2 4DE0     		b	.L1
 1110              	.L43:
 448:../i2c_comm.c **** 		}
 449:../i2c_comm.c **** 
 450:../i2c_comm.c **** 
 451:../i2c_comm.c **** 
 452:../i2c_comm.c **** 		//byteCount = 0;
 453:../i2c_comm.c **** 	}
 454:../i2c_comm.c **** 
 455:../i2c_comm.c **** 	else if (byteCount == 9)
 1111              		.loc 1 455 0
 1112 05a4 092E     		cmp	r6, #9
 1113 05a6 32D1     		bne	.L48
 456:../i2c_comm.c **** 	{
 457:../i2c_comm.c **** 
 458:../i2c_comm.c **** 		if (Command == DIRECTACCESS_MOVE) // direct access commands: this byte will complete the 32 bits 
 1114              		.loc 1 458 0
 1115 05a8 334A     		ldr	r2, .L97+52
 1116 05aa 1778     		ldrb	r7, [r2]
 1117 05ac 912F     		cmp	r7, #145
 1118 05ae 0AD1     		bne	.L49
 1119              	.LBB2:
 459:../i2c_comm.c **** 		{
 460:../i2c_comm.c **** 
 461:../i2c_comm.c **** 			DataDirect = DataDirect << 16;
 1120              		.loc 1 461 0
 1121 05b0 374F     		ldr	r7, .L97+76
 462:../i2c_comm.c **** 			DataDirect |= DataTotal;
 1122              		.loc 1 462 0
 1123 05b2 244A     		ldr	r2, .L97
 461:../i2c_comm.c **** 			DataDirect = DataDirect << 16;
 1124              		.loc 1 461 0
 1125 05b4 3B68     		ldr	r3, [r7]
 463:../i2c_comm.c **** 			uint32_t *access;
 464:../i2c_comm.c **** 			access = registerAddress;
 465:../i2c_comm.c **** 			*access = DataDirect;
 1126              		.loc 1 465 0
 1127 05b6 2B48     		ldr	r0, .L97+32
 462:../i2c_comm.c **** 			DataDirect |= DataTotal;
 1128              		.loc 1 462 0
 1129 05b8 1588     		ldrh	r5, [r2]
 461:../i2c_comm.c **** 			DataDirect = DataDirect << 16;
 1130              		.loc 1 461 0
 1131 05ba 1904     		lsl	r1, r3, #16
 1132              		.loc 1 465 0
 1133 05bc 0668     		ldr	r6, [r0]
 462:../i2c_comm.c **** 			DataDirect |= DataTotal;
 1134              		.loc 1 462 0
 1135 05be 2943     		orr	r1, r5
 1136 05c0 3960     		str	r1, [r7]
 1137              	.LVL55:
 1138              		.loc 1 465 0
 1139 05c2 3160     		str	r1, [r6]
 1140 05c4 3CE0     		b	.L1
 1141              	.LVL56:
 1142              	.L49:
 1143              	.LBE2:
 466:../i2c_comm.c **** 
 467:../i2c_comm.c **** 		}
 468:../i2c_comm.c **** 
 469:../i2c_comm.c **** 		else if (Command == DIRECTACCESS_AND)
 1144              		.loc 1 469 0
 1145 05c6 922F     		cmp	r7, #146
 1146 05c8 0BD1     		bne	.L50
 1147              	.LBB3:
 470:../i2c_comm.c **** 		{
 471:../i2c_comm.c **** 			DataDirect = DataDirect << 16;
 1148              		.loc 1 471 0
 1149 05ca 3149     		ldr	r1, .L97+76
 472:../i2c_comm.c **** 			DataDirect |= DataTotal;
 1150              		.loc 1 472 0
 1151 05cc 1D4B     		ldr	r3, .L97
 471:../i2c_comm.c **** 			DataDirect = DataDirect << 16;
 1152              		.loc 1 471 0
 1153 05ce 0868     		ldr	r0, [r1]
 1154              		.loc 1 472 0
 1155 05d0 1F88     		ldrh	r7, [r3]
 473:../i2c_comm.c **** 			uint32_t *access;
 474:../i2c_comm.c **** 			access = registerAddress;
 1156              		.loc 1 474 0
 1157 05d2 244E     		ldr	r6, .L97+32
 471:../i2c_comm.c **** 			DataDirect = DataDirect << 16;
 1158              		.loc 1 471 0
 1159 05d4 0204     		lsl	r2, r0, #16
 472:../i2c_comm.c **** 			DataDirect |= DataTotal;
 1160              		.loc 1 472 0
 1161 05d6 3A43     		orr	r2, r7
 1162              		.loc 1 474 0
 1163 05d8 3568     		ldr	r5, [r6]
 1164              	.LVL57:
 472:../i2c_comm.c **** 			DataDirect |= DataTotal;
 1165              		.loc 1 472 0
 1166 05da 0A60     		str	r2, [r1]
 475:../i2c_comm.c **** 			*access &= DataDirect;
 1167              		.loc 1 475 0
 1168 05dc 2C68     		ldr	r4, [r5]
 1169 05de 2240     		and	r2, r4
 1170 05e0 81E7     		b	.L90
 1171              	.LVL58:
 1172              	.L50:
 1173              	.LBE3:
 476:../i2c_comm.c **** 		}
 477:../i2c_comm.c **** 
 478:../i2c_comm.c **** 		else if (Command == DIRECTACCESS_OR)
 1174              		.loc 1 478 0
 1175 05e2 932F     		cmp	r7, #147
 1176 05e4 0AD1     		bne	.L51
 1177              	.LBB4:
 479:../i2c_comm.c **** 		{
 480:../i2c_comm.c **** 			DataDirect = DataDirect << 16;
 1178              		.loc 1 480 0
 1179 05e6 2A49     		ldr	r1, .L97+76
 481:../i2c_comm.c **** 			DataDirect |= DataTotal;
 1180              		.loc 1 481 0
 1181 05e8 164B     		ldr	r3, .L97
 480:../i2c_comm.c **** 			DataDirect = DataDirect << 16;
 1182              		.loc 1 480 0
 1183 05ea 0868     		ldr	r0, [r1]
 1184              		.loc 1 481 0
 1185 05ec 1F88     		ldrh	r7, [r3]
 482:../i2c_comm.c **** 			uint32_t *access;
 483:../i2c_comm.c **** 			access = registerAddress;
 1186              		.loc 1 483 0
 1187 05ee 1D4E     		ldr	r6, .L97+32
 480:../i2c_comm.c **** 			DataDirect = DataDirect << 16;
 1188              		.loc 1 480 0
 1189 05f0 0204     		lsl	r2, r0, #16
 481:../i2c_comm.c **** 			DataDirect |= DataTotal;
 1190              		.loc 1 481 0
 1191 05f2 3A43     		orr	r2, r7
 1192              		.loc 1 483 0
 1193 05f4 3568     		ldr	r5, [r6]
 1194              	.LVL59:
 481:../i2c_comm.c **** 			DataDirect |= DataTotal;
 1195              		.loc 1 481 0
 1196 05f6 0A60     		str	r2, [r1]
 484:../i2c_comm.c **** 			*access |= DataDirect;
 1197              		.loc 1 484 0
 1198 05f8 2C68     		ldr	r4, [r5]
 1199 05fa 73E7     		b	.L91
 1200              	.LVL60:
 1201              	.L51:
 1202              	.LBE4:
 485:../i2c_comm.c **** 		}
 486:../i2c_comm.c **** 
 487:../i2c_comm.c **** 		else if (Command == DMX16BIT) // if dmx 16 bit, dmx slot containing lower 8 bits of green colour 
 1203              		.loc 1 487 0
 1204 05fc 342F     		cmp	r7, #52
 1205 05fe 1FD1     		bne	.L1
 488:../i2c_comm.c **** 		{
 489:../i2c_comm.c **** 
 490:../i2c_comm.c **** 			dmx_GreenL = DataTotal;
 1206              		.loc 1 490 0
 1207 0600 1049     		ldr	r1, .L97
 1208 0602 264D     		ldr	r5, .L97+88
 1209 0604 0E88     		ldrh	r6, [r1]
 491:../i2c_comm.c **** 			flashBuffer[13] = DataTotal;
 1210              		.loc 1 491 0
 1211 0606 114C     		ldr	r4, .L97+8
 490:../i2c_comm.c **** 			dmx_GreenL = DataTotal;
 1212              		.loc 1 490 0
 1213 0608 2E80     		strh	r6, [r5]
 1214              		.loc 1 491 0
 1215 060a 6663     		str	r6, [r4, #52]
 1216 060c 18E0     		b	.L1
 1217              	.L48:
 492:../i2c_comm.c **** 		}
 493:../i2c_comm.c **** 
 494:../i2c_comm.c **** 
 495:../i2c_comm.c **** 	}
 496:../i2c_comm.c **** 
 497:../i2c_comm.c **** 	else if (byteCount == 11)
 1218              		.loc 1 497 0
 1219 060e 0B2E     		cmp	r6, #11
 1220 0610 0AD1     		bne	.L52
 498:../i2c_comm.c **** 	{
 499:../i2c_comm.c **** 
 500:../i2c_comm.c **** 		if (Command == DMX16BIT) // dmx slot containing higher 8 bits of blue colour intensity
 1221              		.loc 1 500 0
 1222 0612 1949     		ldr	r1, .L97+52
 1223 0614 0E78     		ldrb	r6, [r1]
 1224 0616 342E     		cmp	r6, #52
 1225 0618 12D1     		bne	.L1
 501:../i2c_comm.c **** 		{
 502:../i2c_comm.c **** 
 503:../i2c_comm.c **** 			dmx_BlueH = DataTotal;
 1226              		.loc 1 503 0
 1227 061a 0A4D     		ldr	r5, .L97
 1228 061c 1D4B     		ldr	r3, .L97+80
 1229 061e 2C88     		ldrh	r4, [r5]
 504:../i2c_comm.c **** 			flashBuffer[14] = DataTotal;
 1230              		.loc 1 504 0
 1231 0620 0A48     		ldr	r0, .L97+8
 503:../i2c_comm.c **** 			dmx_BlueH = DataTotal;
 1232              		.loc 1 503 0
 1233 0622 1C80     		strh	r4, [r3]
 1234              		.loc 1 504 0
 1235 0624 8463     		str	r4, [r0, #56]
 1236 0626 0BE0     		b	.L1
 1237              	.L52:
 505:../i2c_comm.c **** 		}
 506:../i2c_comm.c **** 	}
 507:../i2c_comm.c **** 
 508:../i2c_comm.c **** 	else if (byteCount == 13)
 1238              		.loc 1 508 0
 1239 0628 0D2E     		cmp	r6, #13
 1240 062a 09D1     		bne	.L1
 509:../i2c_comm.c **** 	{
 510:../i2c_comm.c **** 
 511:../i2c_comm.c **** 		if (Command == DMX16BIT)
 1241              		.loc 1 511 0
 1242 062c 124D     		ldr	r5, .L97+52
 1243 062e 2C78     		ldrb	r4, [r5]
 1244 0630 342C     		cmp	r4, #52
 1245 0632 05D1     		bne	.L1
 512:../i2c_comm.c **** 		{
 513:../i2c_comm.c **** // dmx slot containing lower 8 bits of blue colour intensity
 514:../i2c_comm.c **** 			dmx_BlueL = DataTotal;
 1246              		.loc 1 514 0
 1247 0634 034B     		ldr	r3, .L97
 1248 0636 1A4A     		ldr	r2, .L97+92
 1249 0638 1888     		ldrh	r0, [r3]
 515:../i2c_comm.c **** 			flashBuffer[15] = DataTotal;
 1250              		.loc 1 515 0
 1251 063a 044F     		ldr	r7, .L97+8
 514:../i2c_comm.c **** 			dmx_BlueL = DataTotal;
 1252              		.loc 1 514 0
 1253 063c 1080     		strh	r0, [r2]
 1254              		.loc 1 515 0
 1255 063e F863     		str	r0, [r7, #60]
 1256              	.LVL61:
 1257              	.L1:
 516:../i2c_comm.c **** 		}
 517:../i2c_comm.c **** 	}
 518:../i2c_comm.c **** 
 519:../i2c_comm.c **** 
 520:../i2c_comm.c **** 
 521:../i2c_comm.c **** }
 1258              		.loc 1 521 0
 1259 0640 05B0     		add	sp, sp, #20
 1260              		@ sp needed for prologue
 1261 0642 F0BD     		pop	{r4, r5, r6, r7, pc}
 1262              	.L98:
 1263              		.align	2
 1264              	.L97:
 1265 0644 00000000 		.word	DataTotal
 1266 0648 00000000 		.word	PWMSP003_Handle2
 1267 064c 00000000 		.word	flashBuffer
 1268 0650 00000000 		.word	BCCUCH01_Handle0
 1269 0654 00000000 		.word	BCCUCH01_Handle1
 1270 0658 00000000 		.word	BCCUCH01_Handle2
 1271 065c 00000000 		.word	Lamphandle
 1272 0660 00000000 		.word	BCCUDIM01_Handle0
 1273 0664 00000000 		.word	registerAddress
 1274 0668 00000000 		.word	startingSlot
 1275 066c 00000000 		.word	DMX_8
 1276 0670 00000000 		.word	DMX_16
 1277 0674 00000000 		.word	dmx_RedH
 1278 0678 00000000 		.word	Command
 1279 067c 00000000 		.word	BCCUCH01_Handle4
 1280 0680 00000000 		.word	dmx_RedL
 1281 0684 00000000 		.word	COLORLAMP01_ConfigHandle0
 1282 0688 00000000 		.word	BCCUCH01_Handle5
 1283 068c 00000000 		.word	BCCUCH01_Handle3
 1284 0690 00000000 		.word	DataDirect
 1285 0694 00000000 		.word	dmx_BlueH
 1286 0698 00000000 		.word	dmx_GreenH
 1287 069c 00000000 		.word	dmx_GreenL
 1288 06a0 00000000 		.word	dmx_BlueL
 1289              		.cfi_endproc
 1290              	.LFE38:
 1292              		.section	.text.USIC0_2_IRQHandler,"ax",%progbits
 1293              		.align	1
 1294              		.global	USIC0_2_IRQHandler
 1295              		.code	16
 1296              		.thumb_func
 1298              	USIC0_2_IRQHandler:
 1299              	.LFB39:
 522:../i2c_comm.c **** 
 523:../i2c_comm.c **** /*******************************************************************************
 524:../i2c_comm.c ****  ** Syntax          :                                                          **
 525:../i2c_comm.c ****  **                                                                            **
 526:../i2c_comm.c ****  ** Sync /Async     : Synchronous                                              **
 527:../i2c_comm.c ****  **                                                                            **
 528:../i2c_comm.c ****  ** Reentrant       : Non reentrant                                            **
 529:../i2c_comm.c ****  **                                                                            **
 530:../i2c_comm.c ****  ** Parameters(IN)  : None                                                     **
 531:../i2c_comm.c ****  **                                                                            **
 532:../i2c_comm.c ****  ** Parameters(OUT) : Data to be sent to master board via I2C                  **
 533:../i2c_comm.c ****  **                                                                            **
 534:../i2c_comm.c ****  ** Return value    : None                                                     **
 535:../i2c_comm.c ****  **                                                                            **
 536:../i2c_comm.c ****  ** Description     : This function is the interrupt service routine when the  **
 537:../i2c_comm.c ****  **                   shield receives a request for data and when a start      **
 538:../i2c_comm.c ****  **                   condition is received.                                   **
 539:../i2c_comm.c ****  *******************************************************************************/
 540:../i2c_comm.c **** void I2C_START(void)
 541:../i2c_comm.c **** {
 1300              		.loc 1 541 0
 1301              		.cfi_startproc
 1302 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1303              	.LCFI2:
 1304              		.cfi_def_cfa_offset 24
 1305              		.cfi_offset 3, -24
 1306              		.cfi_offset 4, -20
 1307              		.cfi_offset 5, -16
 1308              		.cfi_offset 6, -12
 1309              		.cfi_offset 7, -8
 1310              		.cfi_offset 14, -4
 542:../i2c_comm.c **** 
 543:../i2c_comm.c **** 	byteCount = 0;
 544:../i2c_comm.c **** 	uint8_t send = 0x00;
 545:../i2c_comm.c **** 	I2C003_Handle0.I2CRegs->TRBSCR |= 0x8000;
 1311              		.loc 1 545 0
 1312 0002 BC4E     		ldr	r6, .L152
 543:../i2c_comm.c **** 	byteCount = 0;
 1313              		.loc 1 543 0
 1314 0004 BC49     		ldr	r1, .L152+4
 1315              		.loc 1 545 0
 1316 0006 3568     		ldr	r5, [r6]
 1317 0008 8020     		mov	r0, #128
 1318 000a 2A1C     		mov	r2, r5
 1319 000c FC32     		add	r2, r2, #252
 1320 000e D469     		ldr	r4, [r2, #28]
 1321 0010 0702     		lsl	r7, r0, #8
 543:../i2c_comm.c **** 	byteCount = 0;
 1322              		.loc 1 543 0
 1323 0012 0023     		mov	r3, #0
 1324              		.loc 1 545 0
 1325 0014 3C43     		orr	r4, r7
 543:../i2c_comm.c **** 	byteCount = 0;
 1326              		.loc 1 543 0
 1327 0016 0B60     		str	r3, [r1]
 1328              	.LVL62:
 546:../i2c_comm.c **** 	I2C003_Handle0.I2CRegs->FMR = 0x00000002U  << USIC_CH_FMR_MTDV_Pos;	// clear TDV and TE
 1329              		.loc 1 546 0
 1330 0018 0221     		mov	r1, #2
 545:../i2c_comm.c **** 	I2C003_Handle0.I2CRegs->TRBSCR |= 0x8000;
 1331              		.loc 1 545 0
 1332 001a D461     		str	r4, [r2, #28]
 1333              		.loc 1 546 0
 1334 001c A966     		str	r1, [r5, #104]
 547:../i2c_comm.c **** 	I2C003_Handle0.I2CRegs->TRBSCR = USIC_CH_TRBSCR_FLUSHTB_Msk;			// flush FIFO transmit buffer
 1335              		.loc 1 547 0
 1336 001e D761     		str	r7, [r2, #28]
 548:../i2c_comm.c **** 	I2C003_Handle0.I2CRegs->PSCR |= USIC_CH_PSCR_CST5_Msk;
 1337              		.loc 1 548 0
 1338 0020 EB6C     		ldr	r3, [r5, #76]
 1339 0022 2022     		mov	r2, #32
 1340 0024 1343     		orr	r3, r2
 1341 0026 EB64     		str	r3, [r5, #76]
 549:../i2c_comm.c **** 	I2C003_Handle0.I2CRegs->PSCR |= USIC_CH_PSCR_CST2_Msk;
 1342              		.loc 1 549 0
 1343 0028 EC6C     		ldr	r4, [r5, #76]
 1344 002a 0420     		mov	r0, #4
 1345 002c 0443     		orr	r4, r0
 1346 002e EC64     		str	r4, [r5, #76]
 550:../i2c_comm.c **** 
 551:../i2c_comm.c **** 	temp = I2C003_Handle0.I2CRegs->PSR_IICMode;
 1347              		.loc 1 551 0
 1348 0030 AD6C     		ldr	r5, [r5, #72]
 1349              	.LVL63:
 552:../i2c_comm.c **** 	temp &= 0x00000080;
 1350              		.loc 1 552 0
 1351 0032 B24F     		ldr	r7, .L152+8
 1352 0034 8021     		mov	r1, #128
 1353 0036 2940     		and	r1, r5
 1354              	.LVL64:
 1355 0038 3960     		str	r1, [r7]
 1356              	.LVL65:
 1357 003a 341C     		mov	r4, r6
 1358 003c 3D1C     		mov	r5, r7
 553:../i2c_comm.c **** 	if (temp == 0x00000080) // slave read request event occured
 1359              		.loc 1 553 0
 1360 003e 8029     		cmp	r1, #128
 1361 0040 00D0     		beq	.LCB1099
 1362 0042 52E1     		b	.L100	@long jump
 1363              	.LCB1099:
 554:../i2c_comm.c **** 	{
 555:../i2c_comm.c **** 
 556:../i2c_comm.c **** 		if (Command == READ_INTENSITY_RED) // request for red colour intensity
 1364              		.loc 1 556 0
 1365 0044 AE4B     		ldr	r3, .L152+12
 1366 0046 1878     		ldrb	r0, [r3]
 1367 0048 8128     		cmp	r0, #129
 1368 004a 04D1     		bne	.L101
 557:../i2c_comm.c **** 		{
 558:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA; // transfer data code
 1369              		.loc 1 558 0
 1370 004c AD4C     		ldr	r4, .L152+16
 1371 004e 0123     		mov	r3, #1
 1372 0050 6370     		strb	r3, [r4, #1]
 559:../i2c_comm.c **** 			temp = BCCUCH01_GetIntensity(&BCCUCH01_Handle0); // BCCU Channel for red channel colour intensit
 1373              		.loc 1 559 0
 1374 0052 AD48     		ldr	r0, .L152+20
 1375 0054 05E0     		b	.L141
 1376              	.L101:
 560:../i2c_comm.c **** 			temp &= 0x00000FFF;
 561:../i2c_comm.c **** 
 562:../i2c_comm.c **** 			send = temp; // send lower 8 bits of data
 563:../i2c_comm.c **** 			data2.Payload = send;
 564:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 565:../i2c_comm.c **** 
 566:../i2c_comm.c **** 
 567:../i2c_comm.c **** 			send = temp >> 8; // send upper 8 bits of data
 568:../i2c_comm.c **** 			data2.Payload = send;
 569:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 570:../i2c_comm.c **** 		}
 571:../i2c_comm.c **** 
 572:../i2c_comm.c **** 		else if (Command == READ_INTENSITY_GREEN) // request for green colour intensity
 1377              		.loc 1 572 0
 1378 0056 8228     		cmp	r0, #130
 1379 0058 13D1     		bne	.L102
 573:../i2c_comm.c **** 		{
 574:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1380              		.loc 1 574 0
 1381 005a AA4C     		ldr	r4, .L152+16
 1382 005c 0121     		mov	r1, #1
 1383              	.LVL66:
 575:../i2c_comm.c **** 			temp = BCCUCH01_GetIntensity(&BCCUCH01_Handle1); // BCCU Channel for green channel colour intens
 1384              		.loc 1 575 0
 1385 005e AB48     		ldr	r0, .L152+24
 574:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1386              		.loc 1 574 0
 1387 0060 6170     		strb	r1, [r4, #1]
 1388              	.LVL67:
 1389              	.L141:
 1390              		.loc 1 575 0
 1391 0062 FFF7FEFF 		bl	BCCUCH01_GetIntensity
 1392              	.LVL68:
 1393              	.L143:
 576:../i2c_comm.c **** 			temp &= 0x00000FFF;
 1394              		.loc 1 576 0
 1395 0066 0005     		lsl	r0, r0, #20
 1396              	.LVL69:
 1397 0068 020D     		lsr	r2, r0, #20
 1398 006a 3A60     		str	r2, [r7]
 1399              	.LVL70:
 577:../i2c_comm.c **** 
 578:../i2c_comm.c **** 			send = temp;
 579:../i2c_comm.c **** 			data2.Payload = send;
 1400              		.loc 1 579 0
 1401 006c 2270     		strb	r2, [r4]
 1402              	.LVL71:
 1403              	.L142:
 580:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 1404              		.loc 1 580 0
 1405 006e 211C     		mov	r1, r4
 1406 0070 301C     		mov	r0, r6
 1407 0072 FFF7FEFF 		bl	I2C003_WriteData
 1408              	.LVL72:
 581:../i2c_comm.c **** 
 582:../i2c_comm.c **** 			send = temp >> 8;
 1409              		.loc 1 582 0
 1410 0076 3F68     		ldr	r7, [r7]
 583:../i2c_comm.c **** 			data2.Payload = send;
 584:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 1411              		.loc 1 584 0
 1412 0078 301C     		mov	r0, r6
 582:../i2c_comm.c **** 			send = temp >> 8;
 1413              		.loc 1 582 0
 1414 007a 3D0A     		lsr	r5, r7, #8
 583:../i2c_comm.c **** 			data2.Payload = send;
 1415              		.loc 1 583 0
 1416 007c 2570     		strb	r5, [r4]
 1417              		.loc 1 584 0
 1418 007e 211C     		mov	r1, r4
 1419 0080 31E1     		b	.L140
 1420              	.LVL73:
 1421              	.L102:
 585:../i2c_comm.c **** 		}
 586:../i2c_comm.c **** 
 587:../i2c_comm.c **** 		else if (Command == READ_INTENSITY_BLUE) // request for blue colour intensity
 1422              		.loc 1 587 0
 1423 0082 8328     		cmp	r0, #131
 1424 0084 04D1     		bne	.L103
 588:../i2c_comm.c **** 		{
 589:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1425              		.loc 1 589 0
 1426 0086 9F4C     		ldr	r4, .L152+16
 1427 0088 0125     		mov	r5, #1
 1428 008a 6570     		strb	r5, [r4, #1]
 590:../i2c_comm.c **** 			temp = BCCUCH01_GetIntensity(&BCCUCH01_Handle2); // BCCU Channel for blue channel colour intensi
 1429              		.loc 1 590 0
 1430 008c A048     		ldr	r0, .L152+28
 1431 008e E8E7     		b	.L141
 1432              	.L103:
 591:../i2c_comm.c **** 			temp &= 0x00000FFF;
 592:../i2c_comm.c **** 
 593:../i2c_comm.c **** 			send = temp;
 594:../i2c_comm.c **** 			data2.Payload = send;
 595:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 596:../i2c_comm.c **** 
 597:../i2c_comm.c **** 			send = temp >> 8;
 598:../i2c_comm.c **** 			data2.Payload = send;
 599:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 600:../i2c_comm.c **** 		}
 601:../i2c_comm.c **** 
 602:../i2c_comm.c **** 
 603:../i2c_comm.c **** 		else if (Command == READ_CURRENT_RED) // request for peak current reference of red channel
 1433              		.loc 1 603 0
 1434 0090 8428     		cmp	r0, #132
 1435 0092 04D1     		bne	.L104
 604:../i2c_comm.c **** 		{
 605:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1436              		.loc 1 605 0
 1437 0094 9B4C     		ldr	r4, .L152+16
 1438 0096 0122     		mov	r2, #1
 1439 0098 6270     		strb	r2, [r4, #1]
 606:../i2c_comm.c **** 			temp = BCCUCH01_GetIntensity(&BCCUCH01_Handle3); // BCCU channel for red channel
 1440              		.loc 1 606 0
 1441 009a 9E48     		ldr	r0, .L152+32
 1442 009c E1E7     		b	.L141
 1443              	.L104:
 607:../i2c_comm.c **** 			temp &= 0x00000FFF;
 608:../i2c_comm.c **** 
 609:../i2c_comm.c **** 			send = temp;
 610:../i2c_comm.c **** 			data2.Payload = send;
 611:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 612:../i2c_comm.c **** 
 613:../i2c_comm.c **** 			send = temp >> 8;
 614:../i2c_comm.c **** 			data2.Payload = send;
 615:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 616:../i2c_comm.c **** 		}
 617:../i2c_comm.c **** 
 618:../i2c_comm.c **** 		else if (Command == READ_CURRENT_GREEN) // request for peak current reference of green channel
 1444              		.loc 1 618 0
 1445 009e 8528     		cmp	r0, #133
 1446 00a0 04D1     		bne	.L105
 619:../i2c_comm.c **** 		{
 620:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1447              		.loc 1 620 0
 1448 00a2 984C     		ldr	r4, .L152+16
 1449 00a4 0120     		mov	r0, #1
 1450 00a6 6070     		strb	r0, [r4, #1]
 621:../i2c_comm.c **** 			temp = BCCUCH01_GetIntensity(&BCCUCH01_Handle4); // BCCU Channel for green channel
 1451              		.loc 1 621 0
 1452 00a8 9B48     		ldr	r0, .L152+36
 1453 00aa DAE7     		b	.L141
 1454              	.L105:
 622:../i2c_comm.c **** 			temp &= 0x00000FFF;
 623:../i2c_comm.c **** 
 624:../i2c_comm.c **** 			send = temp;
 625:../i2c_comm.c **** 			data2.Payload = send;
 626:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 627:../i2c_comm.c **** 
 628:../i2c_comm.c **** 			send = temp >> 8;
 629:../i2c_comm.c **** 			data2.Payload = send;
 630:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 631:../i2c_comm.c **** 		}
 632:../i2c_comm.c **** 
 633:../i2c_comm.c **** 		else if (Command == READ_CURRENT_BLUE) // request for peak current reference of blue channel
 1455              		.loc 1 633 0
 1456 00ac 8628     		cmp	r0, #134
 1457 00ae 04D1     		bne	.L106
 634:../i2c_comm.c **** 		{
 635:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1458              		.loc 1 635 0
 1459 00b0 944C     		ldr	r4, .L152+16
 1460 00b2 0123     		mov	r3, #1
 1461 00b4 6370     		strb	r3, [r4, #1]
 636:../i2c_comm.c **** 			temp = BCCUCH01_GetIntensity(&BCCUCH01_Handle5); // BCCU Channel for blue channel
 1462              		.loc 1 636 0
 1463 00b6 9948     		ldr	r0, .L152+40
 1464 00b8 D3E7     		b	.L141
 1465              	.L106:
 637:../i2c_comm.c **** 			temp &= 0x00000FFF;
 638:../i2c_comm.c **** 
 639:../i2c_comm.c **** 			send = temp;
 640:../i2c_comm.c **** 			data2.Payload = send;
 641:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 642:../i2c_comm.c **** 
 643:../i2c_comm.c **** 			send = temp >> 8;
 644:../i2c_comm.c **** 			data2.Payload = send;
 645:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 646:../i2c_comm.c **** 		}
 647:../i2c_comm.c **** 
 648:../i2c_comm.c **** 		else if (Command == READ_WALKTIME) // request for walk-time
 1466              		.loc 1 648 0
 1467 00ba 8A28     		cmp	r0, #138
 1468 00bc 09D1     		bne	.L107
 649:../i2c_comm.c **** 		{
 650:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 651:../i2c_comm.c **** 			temp = Lamphandle.LinearWalkPrescaler; // variable containing walk-time
 1469              		.loc 1 651 0
 1470 00be 9848     		ldr	r0, .L152+44
 650:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1471              		.loc 1 650 0
 1472 00c0 904C     		ldr	r4, .L152+16
 652:../i2c_comm.c **** 			temp &= 0x00003FF;
 1473              		.loc 1 652 0
 1474 00c2 8269     		ldr	r2, [r0, #24]
 650:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1475              		.loc 1 650 0
 1476 00c4 0123     		mov	r3, #1
 1477              		.loc 1 652 0
 1478 00c6 9505     		lsl	r5, r2, #22
 1479 00c8 A90D     		lsr	r1, r5, #22
 1480              	.LVL74:
 650:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1481              		.loc 1 650 0
 1482 00ca 6370     		strb	r3, [r4, #1]
 1483              		.loc 1 652 0
 1484 00cc 3960     		str	r1, [r7]
 1485              	.LVL75:
 653:../i2c_comm.c **** 			//send = temp >> 8;
 654:../i2c_comm.c **** 			send = temp;
 655:../i2c_comm.c **** 			data2.Payload = send;
 1486              		.loc 1 655 0
 1487 00ce 2170     		strb	r1, [r4]
 1488 00d0 CDE7     		b	.L142
 1489              	.LVL76:
 1490              	.L107:
 656:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 657:../i2c_comm.c **** 
 658:../i2c_comm.c **** 			send = temp >> 8;
 659:../i2c_comm.c **** 			data2.Payload = send;
 660:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 661:../i2c_comm.c **** 		}
 662:../i2c_comm.c **** 
 663:../i2c_comm.c **** 		else if (Command == READ_DIMMINGLEVEL) // request for dimming level
 1491              		.loc 1 663 0
 1492 00d2 8B28     		cmp	r0, #139
 1493 00d4 06D1     		bne	.L108
 664:../i2c_comm.c **** 		{
 665:../i2c_comm.c **** 
 666:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1494              		.loc 1 666 0
 1495 00d6 8B4C     		ldr	r4, .L152+16
 1496 00d8 0121     		mov	r1, #1
 1497              	.LVL77:
 667:../i2c_comm.c **** 			temp = BCCUDIM01_GetDimLvl(&BCCUDIM01_Handle0); // BCCU Channel for dimming engine
 1498              		.loc 1 667 0
 1499 00da 9248     		ldr	r0, .L152+48
 666:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1500              		.loc 1 666 0
 1501 00dc 6170     		strb	r1, [r4, #1]
 1502              		.loc 1 667 0
 1503 00de FFF7FEFF 		bl	BCCUDIM01_GetDimLvl
 1504              	.LVL78:
 1505 00e2 C0E7     		b	.L143
 1506              	.LVL79:
 1507              	.L108:
 668:../i2c_comm.c **** 			temp &= 0x0000FFF;
 669:../i2c_comm.c **** 			//send = temp >> 8;
 670:../i2c_comm.c **** 			send = temp;
 671:../i2c_comm.c **** 			data2.Payload = send;
 672:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 673:../i2c_comm.c **** 
 674:../i2c_comm.c **** 			send = temp >> 8;
 675:../i2c_comm.c **** 			data2.Payload = send;
 676:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 677:../i2c_comm.c **** 		}
 678:../i2c_comm.c **** 
 679:../i2c_comm.c **** 		else if (Command == READ_FADERATE) // request for fade rate
 1508              		.loc 1 679 0
 1509 00e4 8C28     		cmp	r0, #140
 1510 00e6 0AD1     		bne	.L109
 680:../i2c_comm.c **** 		{
 681:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1511              		.loc 1 681 0
 1512 00e8 864F     		ldr	r7, .L152+16
 1513 00ea 0123     		mov	r3, #1
 682:../i2c_comm.c **** 			temp = BCCUDIM01_GetDimDiv(&BCCUDIM01_Handle0); // dimming engine
 1514              		.loc 1 682 0
 1515 00ec 8D48     		ldr	r0, .L152+48
 681:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1516              		.loc 1 681 0
 1517 00ee 7B70     		strb	r3, [r7, #1]
 1518              		.loc 1 682 0
 1519 00f0 FFF7FEFF 		bl	BCCUDIM01_GetDimDiv
 1520              	.LVL80:
 683:../i2c_comm.c **** 			temp &= 0x00003FF;
 1521              		.loc 1 683 0
 1522 00f4 8005     		lsl	r0, r0, #22
 1523              	.LVL81:
 1524 00f6 820D     		lsr	r2, r0, #22
 1525 00f8 2A60     		str	r2, [r5]
 1526              	.LVL82:
 684:../i2c_comm.c **** 
 685:../i2c_comm.c **** 			send = temp;
 686:../i2c_comm.c **** 			data2.Payload = send;
 1527              		.loc 1 686 0
 1528 00fa 3A70     		strb	r2, [r7]
 1529 00fc 0BE0     		b	.L145
 1530              	.LVL83:
 1531              	.L109:
 687:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 688:../i2c_comm.c **** 
 689:../i2c_comm.c **** 			send = temp >> 8;
 690:../i2c_comm.c **** 			data2.Payload = send;
 691:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 692:../i2c_comm.c **** 		}
 693:../i2c_comm.c **** 
 694:../i2c_comm.c **** 		else if (Command == READ_OFFTIME_RED) // request for off-time of red channel
 1532              		.loc 1 694 0
 1533 00fe 8728     		cmp	r0, #135
 1534 0100 10D1     		bne	.L110
 695:../i2c_comm.c **** 		{
 696:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1535              		.loc 1 696 0
 1536 0102 804F     		ldr	r7, .L152+16
 1537 0104 0120     		mov	r0, #1
 697:../i2c_comm.c **** 			temp = PWMSP003_Handle0.CC4yRegsPtr->CRS; // compare value of red channel PWM
 1538              		.loc 1 697 0
 1539 0106 884E     		ldr	r6, .L152+52
 696:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1540              		.loc 1 696 0
 1541 0108 7870     		strb	r0, [r7, #1]
 1542              	.L148:
 1543              		.loc 1 697 0
 1544 010a F269     		ldr	r2, [r6, #28]
 1545 010c D16B     		ldr	r1, [r2, #60]
 698:../i2c_comm.c **** 			temp &= 0x00003FF;
 1546              		.loc 1 698 0
 1547 010e 8E05     		lsl	r6, r1, #22
 1548 0110 B20D     		lsr	r2, r6, #22
 1549              	.L147:
 1550 0112 2A60     		str	r2, [r5]
 1551              	.LVL84:
 1552              	.L146:
 699:../i2c_comm.c **** 
 700:../i2c_comm.c **** 			send = temp;
 701:../i2c_comm.c **** 			data2.Payload = send;
 1553              		.loc 1 701 0
 1554 0114 3A70     		strb	r2, [r7]
 1555              	.LVL85:
 1556              	.L145:
 702:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 1557              		.loc 1 702 0
 1558 0116 201C     		mov	r0, r4
 1559 0118 391C     		mov	r1, r7
 1560              	.LVL86:
 1561 011a FFF7FEFF 		bl	I2C003_WriteData
 1562              	.LVL87:
 703:../i2c_comm.c **** 
 704:../i2c_comm.c **** 			send = temp >> 8;
 1563              		.loc 1 704 0
 1564 011e 2D68     		ldr	r5, [r5]
 1565 0120 2D0A     		lsr	r5, r5, #8
 1566 0122 97E0     		b	.L144
 1567              	.LVL88:
 1568              	.L110:
 705:../i2c_comm.c **** 			data2.Payload = send;
 706:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 707:../i2c_comm.c **** 		}
 708:../i2c_comm.c **** 
 709:../i2c_comm.c **** 		else if (Command == READ_OFFTIME_GREEN) // request for off-time of green channel
 1569              		.loc 1 709 0
 1570 0124 8828     		cmp	r0, #136
 1571 0126 04D1     		bne	.L111
 710:../i2c_comm.c **** 		{
 711:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1572              		.loc 1 711 0
 1573 0128 764F     		ldr	r7, .L152+16
 1574 012a 0123     		mov	r3, #1
 1575 012c 7B70     		strb	r3, [r7, #1]
 712:../i2c_comm.c **** 			temp = PWMSP003_Handle1.CC4yRegsPtr->CRS; // compare value of green channel
 1576              		.loc 1 712 0
 1577 012e 7F4E     		ldr	r6, .L152+56
 1578 0130 EBE7     		b	.L148
 1579              	.L111:
 713:../i2c_comm.c **** 			temp &= 0x00003FF;
 714:../i2c_comm.c **** 
 715:../i2c_comm.c **** 			send = temp;
 716:../i2c_comm.c **** 			data2.Payload = send;
 717:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 718:../i2c_comm.c **** 
 719:../i2c_comm.c **** 			send = temp >> 8;
 720:../i2c_comm.c **** 			data2.Payload = send;
 721:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 722:../i2c_comm.c **** 		}
 723:../i2c_comm.c **** 		else if (Command == READ_OFFTIME_BLUE) // request for off-time of blue channel
 1580              		.loc 1 723 0
 1581 0132 8928     		cmp	r0, #137
 1582 0134 04D1     		bne	.L112
 724:../i2c_comm.c **** 		{
 725:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1583              		.loc 1 725 0
 1584 0136 734F     		ldr	r7, .L152+16
 1585 0138 0121     		mov	r1, #1
 1586              	.LVL89:
 1587 013a 7970     		strb	r1, [r7, #1]
 726:../i2c_comm.c **** 			temp = PWMSP003_Handle2.CC4yRegsPtr->CRS; // compare value of blue channel pwm
 1588              		.loc 1 726 0
 1589 013c 7C4E     		ldr	r6, .L152+60
 1590 013e E4E7     		b	.L148
 1591              	.LVL90:
 1592              	.L112:
 727:../i2c_comm.c **** 			temp &= 0x00003FF;
 728:../i2c_comm.c **** 
 729:../i2c_comm.c **** 			send = temp;
 730:../i2c_comm.c **** 			data2.Payload = send;
 731:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 732:../i2c_comm.c **** 
 733:../i2c_comm.c **** 			send = temp >> 8;
 734:../i2c_comm.c **** 			data2.Payload = send;
 735:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 736:../i2c_comm.c **** 		}
 737:../i2c_comm.c **** 
 738:../i2c_comm.c **** 		else if (Command == READ_DMX) // read dmx enable control
 1593              		.loc 1 738 0
 1594 0140 8D28     		cmp	r0, #141
 1595 0142 05D1     		bne	.L113
 739:../i2c_comm.c **** 		{
 740:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1596              		.loc 1 740 0
 1597 0144 6F4F     		ldr	r7, .L152+16
 741:../i2c_comm.c **** 			temp = DMXControl;
 1598              		.loc 1 741 0
 1599 0146 7B4A     		ldr	r2, .L152+64
 740:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1600              		.loc 1 740 0
 1601 0148 0120     		mov	r0, #1
 1602 014a 7870     		strb	r0, [r7, #1]
 1603              		.loc 1 741 0
 1604 014c 1268     		ldr	r2, [r2]
 1605 014e E0E7     		b	.L147
 1606              	.L113:
 742:../i2c_comm.c **** 
 743:../i2c_comm.c **** 			send = temp;
 744:../i2c_comm.c **** 			data2.Payload = send;
 745:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 746:../i2c_comm.c **** 
 747:../i2c_comm.c **** 			send = temp >> 8;
 748:../i2c_comm.c **** 			data2.Payload = send;
 749:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 750:../i2c_comm.c **** 		}
 751:../i2c_comm.c **** 
 752:../i2c_comm.c **** 		else if (Command == READ_DMXSLOT) // request for first dmx relevant slot
 1607              		.loc 1 752 0
 1608 0150 8E28     		cmp	r0, #142
 1609 0152 04D1     		bne	.L114
 753:../i2c_comm.c **** 		{
 754:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1610              		.loc 1 754 0
 1611 0154 6B4F     		ldr	r7, .L152+16
 1612 0156 0123     		mov	r3, #1
 1613 0158 7B70     		strb	r3, [r7, #1]
 755:../i2c_comm.c **** 			temp = startingSlot; // first relevant slot
 1614              		.loc 1 755 0
 1615 015a 774A     		ldr	r2, .L152+68
 1616 015c 48E0     		b	.L149
 1617              	.L114:
 756:../i2c_comm.c **** 
 757:../i2c_comm.c **** 			send = temp;
 758:../i2c_comm.c **** 			data2.Payload = send;
 759:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 760:../i2c_comm.c **** 
 761:../i2c_comm.c **** 			send = temp >> 8;
 762:../i2c_comm.c **** 			data2.Payload = send;
 763:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 764:../i2c_comm.c **** 		}
 765:../i2c_comm.c **** 
 766:../i2c_comm.c **** 		else if (Command == READ_DMXBIT) // request 8 or 16 bit dmx
 1618              		.loc 1 766 0
 1619 015e 8F28     		cmp	r0, #143
 1620 0160 0ED1     		bne	.L115
 767:../i2c_comm.c **** 		{
 768:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 769:../i2c_comm.c **** 			if (DMX_8 == 1) // 8 bit
 1621              		.loc 1 769 0
 1622 0162 764B     		ldr	r3, .L152+72
 768:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1623              		.loc 1 768 0
 1624 0164 674F     		ldr	r7, .L152+16
 1625              		.loc 1 769 0
 1626 0166 1868     		ldr	r0, [r3]
 768:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1627              		.loc 1 768 0
 1628 0168 0126     		mov	r6, #1
 1629 016a 7E70     		strb	r6, [r7, #1]
 1630              		.loc 1 769 0
 1631 016c 0128     		cmp	r0, #1
 1632 016e 01D1     		bne	.L116
 770:../i2c_comm.c **** 				temp = 8;
 1633              		.loc 1 770 0
 1634 0170 0826     		mov	r6, #8
 1635 0172 33E0     		b	.L138
 1636              	.L116:
 771:../i2c_comm.c **** 			else if (DMX_16 == 1) // 16 bit
 1637              		.loc 1 771 0
 1638 0174 724A     		ldr	r2, .L152+76
 1639 0176 1168     		ldr	r1, [r2]
 1640              	.LVL91:
 1641 0178 0129     		cmp	r1, #1
 1642 017a 30D1     		bne	.L125
 772:../i2c_comm.c **** 				temp = 16;
 1643              		.loc 1 772 0
 1644 017c 1026     		mov	r6, #16
 1645 017e 2DE0     		b	.L138
 1646              	.LVL92:
 1647              	.L115:
 773:../i2c_comm.c **** 
 774:../i2c_comm.c **** 			send = temp;
 775:../i2c_comm.c **** 			data2.Payload = send;
 776:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 777:../i2c_comm.c **** 
 778:../i2c_comm.c **** 			send = temp >> 8;
 779:../i2c_comm.c **** 			data2.Payload = send;
 780:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 781:../i2c_comm.c **** 		}
 782:../i2c_comm.c **** 
 783:../i2c_comm.c **** 		else if (Command == READ_DMXREDH) // request for higher 8 bits of red colour intensity from dmx
 1648              		.loc 1 783 0
 1649 0180 9428     		cmp	r0, #148
 1650 0182 04D1     		bne	.L118
 784:../i2c_comm.c **** 		{
 785:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA; // TDF_Ack0
 1651              		.loc 1 785 0
 1652 0184 5F4F     		ldr	r7, .L152+16
 1653 0186 0121     		mov	r1, #1
 1654              	.LVL93:
 1655 0188 7970     		strb	r1, [r7, #1]
 786:../i2c_comm.c **** 
 787:../i2c_comm.c **** 			temp = dmx_RedH;
 1656              		.loc 1 787 0
 1657 018a 6E4A     		ldr	r2, .L152+80
 1658 018c 30E0     		b	.L149
 1659              	.LVL94:
 1660              	.L118:
 788:../i2c_comm.c **** 			send = temp;
 789:../i2c_comm.c **** 			data2.Payload = send;
 790:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 791:../i2c_comm.c **** 
 792:../i2c_comm.c **** 			send = temp >> 8;
 793:../i2c_comm.c **** 			data2.Payload = send;
 794:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 795:../i2c_comm.c **** 		}
 796:../i2c_comm.c **** 
 797:../i2c_comm.c **** 		else if (Command == READ_DMXREDL) // request for lower 8 bits of red colour intensity from dmx. i
 1661              		.loc 1 797 0
 1662 018e 9528     		cmp	r0, #149
 1663 0190 0CD1     		bne	.L119
 798:../i2c_comm.c **** 		{
 799:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 800:../i2c_comm.c **** 
 801:../i2c_comm.c **** 			if (DMX_8 == 1)
 1664              		.loc 1 801 0
 1665 0192 6A4A     		ldr	r2, .L152+72
 799:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1666              		.loc 1 799 0
 1667 0194 5B4F     		ldr	r7, .L152+16
 1668              		.loc 1 801 0
 1669 0196 1168     		ldr	r1, [r2]
 1670              	.LVL95:
 799:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1671              		.loc 1 799 0
 1672 0198 0120     		mov	r0, #1
 1673 019a 7870     		strb	r0, [r7, #1]
 1674              		.loc 1 801 0
 1675 019c 0129     		cmp	r1, #1
 1676 019e 32D0     		beq	.L151
 1677              	.L120:
 802:../i2c_comm.c **** 				temp = 0x00;
 803:../i2c_comm.c **** 			else if (DMX_16 == 1)
 1678              		.loc 1 803 0
 1679 01a0 674E     		ldr	r6, .L152+76
 1680 01a2 3368     		ldr	r3, [r6]
 1681 01a4 012B     		cmp	r3, #1
 1682 01a6 37D1     		bne	.L129
 804:../i2c_comm.c **** 				temp = dmx_RedL;
 1683              		.loc 1 804 0
 1684 01a8 674B     		ldr	r3, .L152+84
 1685 01aa 33E0     		b	.L150
 1686              	.LVL96:
 1687              	.L119:
 805:../i2c_comm.c **** 
 806:../i2c_comm.c **** 			send = temp;
 807:../i2c_comm.c **** 			data2.Payload = send;
 808:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 809:../i2c_comm.c **** 
 810:../i2c_comm.c **** 			send = temp >> 8;
 811:../i2c_comm.c **** 			data2.Payload = send;
 812:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 813:../i2c_comm.c **** 		}
 814:../i2c_comm.c **** 
 815:../i2c_comm.c **** 		else if (Command == READ_DMXGREENH) // request for higher 8 bits of green colour intensity from d
 1688              		.loc 1 815 0
 1689 01ac 9628     		cmp	r0, #150
 1690 01ae 04D1     		bne	.L122
 816:../i2c_comm.c **** 		{
 817:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1691              		.loc 1 817 0
 1692 01b0 544F     		ldr	r7, .L152+16
 1693 01b2 0123     		mov	r3, #1
 1694 01b4 7B70     		strb	r3, [r7, #1]
 818:../i2c_comm.c **** 
 819:../i2c_comm.c **** 			temp = dmx_GreenH;
 1695              		.loc 1 819 0
 1696 01b6 654A     		ldr	r2, .L152+88
 1697 01b8 1AE0     		b	.L149
 1698              	.L122:
 820:../i2c_comm.c **** 			send = temp;
 821:../i2c_comm.c **** 			data2.Payload = send;
 822:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 823:../i2c_comm.c **** 
 824:../i2c_comm.c **** 			send = temp >> 8;
 825:../i2c_comm.c **** 			data2.Payload = send;
 826:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 827:../i2c_comm.c **** 		}
 828:../i2c_comm.c **** 
 829:../i2c_comm.c **** 		else if (Command == READ_DMXGREENL) // request for lower 8 bits of green colour intensity from dm
 1699              		.loc 1 829 0
 1700 01ba 9728     		cmp	r0, #151
 1701 01bc 12D1     		bne	.L123
 830:../i2c_comm.c **** 		{
 831:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 832:../i2c_comm.c **** 
 833:../i2c_comm.c **** 			if (DMX_8 == 1)
 1702              		.loc 1 833 0
 1703 01be 5F4E     		ldr	r6, .L152+72
 831:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1704              		.loc 1 831 0
 1705 01c0 504F     		ldr	r7, .L152+16
 1706              		.loc 1 833 0
 1707 01c2 3368     		ldr	r3, [r6]
 831:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1708              		.loc 1 831 0
 1709 01c4 0121     		mov	r1, #1
 1710              	.LVL97:
 1711 01c6 7970     		strb	r1, [r7, #1]
 1712              		.loc 1 833 0
 1713 01c8 012B     		cmp	r3, #1
 1714 01ca 01D1     		bne	.L124
 834:../i2c_comm.c **** 				temp = 0x00;
 1715              		.loc 1 834 0
 1716 01cc 0026     		mov	r6, #0
 1717 01ce 05E0     		b	.L138
 1718              	.L124:
 835:../i2c_comm.c **** 			else if (DMX_16 == 1)
 1719              		.loc 1 835 0
 1720 01d0 5B48     		ldr	r0, .L152+76
 1721 01d2 0268     		ldr	r2, [r0]
 1722 01d4 012A     		cmp	r2, #1
 1723 01d6 02D1     		bne	.L125
 836:../i2c_comm.c **** 				temp = dmx_GreenL;
 1724              		.loc 1 836 0
 1725 01d8 5D49     		ldr	r1, .L152+92
 1726 01da 0E88     		ldrh	r6, [r1]
 1727              	.LVL98:
 1728              	.L138:
 1729 01dc 2E60     		str	r6, [r5]
 1730              	.L125:
 1731              	.LVL99:
 837:../i2c_comm.c **** 
 838:../i2c_comm.c **** 			send = temp;
 839:../i2c_comm.c **** 			data2.Payload = send;
 1732              		.loc 1 839 0
 1733 01de 2E68     		ldr	r6, [r5]
 1734 01e0 3E70     		strb	r6, [r7]
 1735 01e2 98E7     		b	.L145
 1736              	.LVL100:
 1737              	.L123:
 840:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 841:../i2c_comm.c **** 
 842:../i2c_comm.c **** 			send = temp >> 8;
 843:../i2c_comm.c **** 			data2.Payload = send;
 844:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 845:../i2c_comm.c **** 		}
 846:../i2c_comm.c **** 
 847:../i2c_comm.c **** 		else if (Command == READ_DMXBLUEH) // request for higher 8 bits of blue colour intensity.
 1738              		.loc 1 847 0
 1739 01e4 9828     		cmp	r0, #152
 1740 01e6 05D1     		bne	.L126
 848:../i2c_comm.c **** 		{
 849:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1741              		.loc 1 849 0
 1742 01e8 464F     		ldr	r7, .L152+16
 1743 01ea 0120     		mov	r0, #1
 850:../i2c_comm.c **** 
 851:../i2c_comm.c **** 			temp = dmx_BlueH;
 1744              		.loc 1 851 0
 1745 01ec 594A     		ldr	r2, .L152+96
 849:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1746              		.loc 1 849 0
 1747 01ee 7870     		strb	r0, [r7, #1]
 1748              	.L149:
 1749              		.loc 1 851 0
 1750 01f0 1288     		ldrh	r2, [r2]
 1751 01f2 8EE7     		b	.L147
 1752              	.L126:
 852:../i2c_comm.c **** 			send = temp;
 853:../i2c_comm.c **** 			data2.Payload = send;
 854:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 855:../i2c_comm.c **** 
 856:../i2c_comm.c **** 			send = temp >> 8;
 857:../i2c_comm.c **** 			data2.Payload = send;
 858:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 859:../i2c_comm.c **** 		}
 860:../i2c_comm.c **** 
 861:../i2c_comm.c **** 		else if (Command == READ_DMXBLUEL) //request for lower 8 bits of blue colour intensity
 1753              		.loc 1 861 0
 1754 01f4 9928     		cmp	r0, #153
 1755 01f6 11D1     		bne	.L127
 862:../i2c_comm.c **** 		{
 863:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 864:../i2c_comm.c **** 
 865:../i2c_comm.c **** 			if (DMX_8 == 1)
 1756              		.loc 1 865 0
 1757 01f8 5048     		ldr	r0, .L152+72
 863:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1758              		.loc 1 863 0
 1759 01fa 424F     		ldr	r7, .L152+16
 1760              		.loc 1 865 0
 1761 01fc 0268     		ldr	r2, [r0]
 863:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1762              		.loc 1 863 0
 1763 01fe 0123     		mov	r3, #1
 1764 0200 7B70     		strb	r3, [r7, #1]
 1765              		.loc 1 865 0
 1766 0202 012A     		cmp	r2, #1
 1767 0204 01D1     		bne	.L128
 1768              	.L151:
 866:../i2c_comm.c **** 				temp = 0x00;
 1769              		.loc 1 866 0
 1770 0206 0020     		mov	r0, #0
 1771 0208 05E0     		b	.L139
 1772              	.L128:
 867:../i2c_comm.c **** 			else if (DMX_16 == 1)
 1773              		.loc 1 867 0
 1774 020a 4D49     		ldr	r1, .L152+76
 1775              	.LVL101:
 1776 020c 0E68     		ldr	r6, [r1]
 1777 020e 012E     		cmp	r6, #1
 1778 0210 02D1     		bne	.L129
 868:../i2c_comm.c **** 				temp = dmx_BlueL;
 1779              		.loc 1 868 0
 1780 0212 514B     		ldr	r3, .L152+100
 1781              	.L150:
 1782 0214 1888     		ldrh	r0, [r3]
 1783              	.LVL102:
 1784              	.L139:
 1785 0216 2860     		str	r0, [r5]
 1786              	.L129:
 1787              	.LVL103:
 869:../i2c_comm.c **** 
 870:../i2c_comm.c **** 			send = temp;
 871:../i2c_comm.c **** 			data2.Payload = send;
 1788              		.loc 1 871 0
 1789 0218 2A68     		ldr	r2, [r5]
 1790 021a 7BE7     		b	.L146
 1791              	.LVL104:
 1792              	.L127:
 872:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 873:../i2c_comm.c **** 
 874:../i2c_comm.c **** 			send = temp >> 8;
 875:../i2c_comm.c **** 			data2.Payload = send;
 876:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 877:../i2c_comm.c **** 		}
 878:../i2c_comm.c **** 
 879:../i2c_comm.c **** 
 880:../i2c_comm.c **** 
 881:../i2c_comm.c **** 
 882:../i2c_comm.c **** 
 883:../i2c_comm.c **** 		else if (Command == DIRECTACCESS_READ) // request for data in a register
 1793              		.loc 1 883 0
 1794 021c 9028     		cmp	r0, #144
 1795 021e 1DD1     		bne	.L130
 1796              	.LVL105:
 1797              	.LBB5:
 884:../i2c_comm.c **** 		{
 885:../i2c_comm.c **** 			uint32_t *access;
 886:../i2c_comm.c **** 			access = registerAddress;
 887:../i2c_comm.c **** 			temp = *access;
 1798              		.loc 1 887 0
 1799 0220 4E49     		ldr	r1, .L152+104
 1800              	.LVL106:
 888:../i2c_comm.c **** 
 889:../i2c_comm.c **** 
 890:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1801              		.loc 1 890 0
 1802 0222 0120     		mov	r0, #1
 887:../i2c_comm.c **** 			temp = *access;
 1803              		.loc 1 887 0
 1804 0224 0E68     		ldr	r6, [r1]
 1805 0226 3368     		ldr	r3, [r6]
 1806 0228 3B60     		str	r3, [r7]
 1807              	.LVL107:
 1808              		.loc 1 890 0
 1809 022a 364F     		ldr	r7, .L152+16
 1810 022c 7870     		strb	r0, [r7, #1]
 1811              	.LVL108:
 891:../i2c_comm.c **** 
 892:../i2c_comm.c **** 			send = (uint8_t) (temp);
 893:../i2c_comm.c **** 			data2.Payload = send;
 894:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 1812              		.loc 1 894 0
 1813 022e 391C     		mov	r1, r7
 1814              	.LVL109:
 1815 0230 201C     		mov	r0, r4
 893:../i2c_comm.c **** 			data2.Payload = send;
 1816              		.loc 1 893 0
 1817 0232 3B70     		strb	r3, [r7]
 1818              		.loc 1 894 0
 1819 0234 FFF7FEFF 		bl	I2C003_WriteData
 1820              	.LVL110:
 895:../i2c_comm.c **** 
 896:../i2c_comm.c **** 			send = temp >> 8;
 1821              		.loc 1 896 0
 1822 0238 2A68     		ldr	r2, [r5]
 897:../i2c_comm.c **** 			data2.Payload = send;
 898:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 1823              		.loc 1 898 0
 1824 023a 201C     		mov	r0, r4
 896:../i2c_comm.c **** 			send = temp >> 8;
 1825              		.loc 1 896 0
 1826 023c 110A     		lsr	r1, r2, #8
 897:../i2c_comm.c **** 			data2.Payload = send;
 1827              		.loc 1 897 0
 1828 023e 3970     		strb	r1, [r7]
 1829              		.loc 1 898 0
 1830 0240 391C     		mov	r1, r7
 1831 0242 FFF7FEFF 		bl	I2C003_WriteData
 1832              	.LVL111:
 899:../i2c_comm.c **** 
 900:../i2c_comm.c **** 			send = temp >> 16;
 1833              		.loc 1 900 0
 1834 0246 6E88     		ldrh	r6, [r5, #2]
 1835              	.LVL112:
 901:../i2c_comm.c **** 			data2.Payload = send;
 902:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 1836              		.loc 1 902 0
 1837 0248 201C     		mov	r0, r4
 1838 024a 391C     		mov	r1, r7
 901:../i2c_comm.c **** 			data2.Payload = send;
 1839              		.loc 1 901 0
 1840 024c 3E70     		strb	r6, [r7]
 1841              		.loc 1 902 0
 1842 024e FFF7FEFF 		bl	I2C003_WriteData
 1843              	.LVL113:
 903:../i2c_comm.c **** 
 904:../i2c_comm.c **** 			send = temp >> 24;
 1844              		.loc 1 904 0
 1845 0252 ED78     		ldrb	r5, [r5, #3]
 1846              	.LVL114:
 1847              	.L144:
 905:../i2c_comm.c **** 			data2.Payload = send;
 1848              		.loc 1 905 0
 1849 0254 3D70     		strb	r5, [r7]
 906:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 1850              		.loc 1 906 0
 1851 0256 201C     		mov	r0, r4
 1852 0258 391C     		mov	r1, r7
 1853 025a 44E0     		b	.L140
 1854              	.LVL115:
 1855              	.L130:
 1856              	.LBE5:
 907:../i2c_comm.c **** 
 908:../i2c_comm.c **** 
 909:../i2c_comm.c **** 		}
 910:../i2c_comm.c **** 
 911:../i2c_comm.c **** 		else if (writeToFlash == 1) // request to save prameters to flash
 1857              		.loc 1 911 0
 1858 025c 404E     		ldr	r6, .L152+108
 1859 025e 3768     		ldr	r7, [r6]
 1860 0260 012F     		cmp	r7, #1
 1861 0262 32D1     		bne	.L131
 1862              	.LBB6:
 912:../i2c_comm.c **** 		{
 913:../i2c_comm.c **** 			flashBuffer[0] ++;
 1863              		.loc 1 913 0
 1864 0264 3F4E     		ldr	r6, .L152+112
 1865 0266 3068     		ldr	r0, [r6]
 1866 0268 0130     		add	r0, r0, #1
 1867 026a 3060     		str	r0, [r6]
 914:../i2c_comm.c **** 
 915:../i2c_comm.c **** 			status_t status;
 916:../i2c_comm.c **** 			FLASH003_ClearStatus();
 1868              		.loc 1 916 0
 1869 026c FFF7FEFF 		bl	FLASH003_ClearStatus
 1870              	.LVL116:
 917:../i2c_comm.c **** 			if ( ! (flashBuffer[0] % 2 )) // if odd number in first element in buffer, store in first half o
 1871              		.loc 1 917 0
 1872 0270 3268     		ldr	r2, [r6]
 1873 0272 3D4D     		ldr	r5, .L152+116
 1874 0274 3A42     		tst	r2, r7
 1875 0276 07D1     		bne	.L132
 918:../i2c_comm.c **** 			{
 919:../i2c_comm.c **** 				flashAddress = 0x10004F00;
 1876              		.loc 1 919 0
 1877 0278 3C49     		ldr	r1, .L152+120
 1878 027a 2960     		str	r1, [r5]
 1879              	.L133:
 920:../i2c_comm.c **** 				while ( FLASH003_ErasePage((unsigned long )flashAddress) != FLASH003_COMPLETE ); // erase page
 1880              		.loc 1 920 0 discriminator 1
 1881 027c 2868     		ldr	r0, [r5]
 1882 027e FFF7FEFF 		bl	FLASH003_ErasePage
 1883              	.LVL117:
 1884 0282 0028     		cmp	r0, #0
 1885 0284 FAD1     		bne	.L133
 1886 0286 01E0     		b	.L134
 1887              	.L132:
 921:../i2c_comm.c **** 			}
 922:../i2c_comm.c **** 
 923:../i2c_comm.c **** 			else if (flashBuffer[0] %2) // if even number, store in second half of page. Address is 0x10004F
 924:../i2c_comm.c **** 				flashAddress = 0x10004F80;
 1888              		.loc 1 924 0
 1889 0288 394F     		ldr	r7, .L152+124
 1890 028a 2F60     		str	r7, [r5]
 1891              	.L134:
 925:../i2c_comm.c **** 
 926:../i2c_comm.c **** 
 927:../i2c_comm.c **** 			FLASH003_WriteMultipleBlocks(flashAddress, flashBuffer, 6U); // write to flash
 1892              		.loc 1 927 0
 1893 028c 311C     		mov	r1, r6
 1894 028e 2868     		ldr	r0, [r5]
 1895 0290 0622     		mov	r2, #6
 1896 0292 FFF7FEFF 		bl	FLASH003_WriteMultipleBlocks
 1897              	.LVL118:
 928:../i2c_comm.c **** 			FLASH003_ReadBytes(flashAddress, flashBuffer, 92); // update array containing variables
 1898              		.loc 1 928 0
 1899 0296 5C22     		mov	r2, #92
 1900 0298 311C     		mov	r1, r6
 1901 029a 2868     		ldr	r0, [r5]
 1902 029c FFF7FEFF 		bl	FLASH003_ReadBytes
 1903              	.LVL119:
 929:../i2c_comm.c **** 
 930:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1904              		.loc 1 930 0
 1905 02a0 184D     		ldr	r5, .L152+16
 931:../i2c_comm.c **** 
 932:../i2c_comm.c **** 			send = 0x11;
 933:../i2c_comm.c **** 			data2.Payload = send;
 1906              		.loc 1 933 0
 1907 02a2 1123     		mov	r3, #17
 930:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1908              		.loc 1 930 0
 1909 02a4 0126     		mov	r6, #1
 934:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2); // send data back to master to indicate write operatio
 1910              		.loc 1 934 0
 1911 02a6 201C     		mov	r0, r4
 1912 02a8 291C     		mov	r1, r5
 933:../i2c_comm.c **** 			data2.Payload = send;
 1913              		.loc 1 933 0
 1914 02aa 2B70     		strb	r3, [r5]
 930:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1915              		.loc 1 930 0
 1916 02ac 6E70     		strb	r6, [r5, #1]
 1917              	.LVL120:
 1918              		.loc 1 934 0
 1919 02ae FFF7FEFF 		bl	I2C003_WriteData
 1920              	.LVL121:
 935:../i2c_comm.c **** 
 936:../i2c_comm.c **** 			send = 0x12;
 937:../i2c_comm.c **** 			data2.Payload = send;
 1921              		.loc 1 937 0
 1922 02b2 1220     		mov	r0, #18
 1923 02b4 2870     		strb	r0, [r5]
 938:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 1924              		.loc 1 938 0
 1925 02b6 291C     		mov	r1, r5
 1926 02b8 201C     		mov	r0, r4
 1927 02ba FFF7FEFF 		bl	I2C003_WriteData
 1928              	.LVL122:
 939:../i2c_comm.c **** 
 940:../i2c_comm.c **** 			writeToFlash = 0;
 1929              		.loc 1 940 0
 1930 02be 284A     		ldr	r2, .L152+108
 941:../i2c_comm.c **** 			configStatus = 1;
 1931              		.loc 1 941 0
 1932 02c0 2C4F     		ldr	r7, .L152+128
 940:../i2c_comm.c **** 			writeToFlash = 0;
 1933              		.loc 1 940 0
 1934 02c2 0024     		mov	r4, #0
 1935 02c4 1460     		str	r4, [r2]
 1936              		.loc 1 941 0
 1937 02c6 3E60     		str	r6, [r7]
 1938 02c8 0FE0     		b	.L100
 1939              	.LVL123:
 1940              	.L131:
 1941              	.LBE6:
 942:../i2c_comm.c **** 		}
 943:../i2c_comm.c **** 
 944:../i2c_comm.c **** 		else if (Command == READ_CONFIG) // request for configuration status
 1942              		.loc 1 944 0
 1943 02ca 8028     		cmp	r0, #128
 1944 02cc 0DD1     		bne	.L100
 945:../i2c_comm.c **** 		{
 946:../i2c_comm.c **** 
 947:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 948:../i2c_comm.c **** 
 949:../i2c_comm.c **** 			send = (uint8_t) (configStatus);
 1945              		.loc 1 949 0
 1946 02ce 2949     		ldr	r1, .L152+128
 1947              	.LVL124:
 947:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1948              		.loc 1 947 0
 1949 02d0 0C4D     		ldr	r5, .L152+16
 1950              		.loc 1 949 0
 1951 02d2 0B68     		ldr	r3, [r1]
 947:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1952              		.loc 1 947 0
 1953 02d4 0122     		mov	r2, #1
 950:../i2c_comm.c **** 			data2.Payload = send;
 951:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 1954              		.loc 1 951 0
 1955 02d6 291C     		mov	r1, r5
 1956 02d8 201C     		mov	r0, r4
 947:../i2c_comm.c **** 			data2.TDF_Type = I2C003_TDF_STXDATA;
 1957              		.loc 1 947 0
 1958 02da 6A70     		strb	r2, [r5, #1]
 1959              	.LVL125:
 950:../i2c_comm.c **** 			data2.Payload = send;
 1960              		.loc 1 950 0
 1961 02dc 2B70     		strb	r3, [r5]
 1962              		.loc 1 951 0
 1963 02de FFF7FEFF 		bl	I2C003_WriteData
 1964              	.LVL126:
 952:../i2c_comm.c **** 
 953:../i2c_comm.c **** 			I2C003_WriteData(&I2C003_Handle0,&data2);
 1965              		.loc 1 953 0
 1966 02e2 201C     		mov	r0, r4
 1967 02e4 291C     		mov	r1, r5
 1968              	.L140:
 1969 02e6 FFF7FEFF 		bl	I2C003_WriteData
 1970              	.LVL127:
 1971              	.L100:
 954:../i2c_comm.c **** 
 955:../i2c_comm.c **** 			send = temp >> 16;
 956:../i2c_comm.c **** 
 957:../i2c_comm.c **** 		}
 958:../i2c_comm.c **** 
 959:../i2c_comm.c **** 
 960:../i2c_comm.c **** 	}
 961:../i2c_comm.c **** 	byteCount = 0;
 1972              		.loc 1 961 0
 1973 02ea 034C     		ldr	r4, .L152+4
 1974 02ec 0026     		mov	r6, #0
 1975 02ee 2660     		str	r6, [r4]
 962:../i2c_comm.c **** 
 963:../i2c_comm.c **** }
 1976              		.loc 1 963 0
 1977              		@ sp needed for prologue
 1978 02f0 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1979              	.L153:
 1980 02f2 C046     		.align	2
 1981              	.L152:
 1982 02f4 00000000 		.word	I2C003_Handle0
 1983 02f8 00000000 		.word	byteCount
 1984 02fc 00000000 		.word	temp
 1985 0300 00000000 		.word	Command
 1986 0304 00000000 		.word	data2
 1987 0308 00000000 		.word	BCCUCH01_Handle0
 1988 030c 00000000 		.word	BCCUCH01_Handle1
 1989 0310 00000000 		.word	BCCUCH01_Handle2
 1990 0314 00000000 		.word	BCCUCH01_Handle3
 1991 0318 00000000 		.word	BCCUCH01_Handle4
 1992 031c 00000000 		.word	BCCUCH01_Handle5
 1993 0320 00000000 		.word	Lamphandle
 1994 0324 00000000 		.word	BCCUDIM01_Handle0
 1995 0328 00000000 		.word	PWMSP003_Handle0
 1996 032c 00000000 		.word	PWMSP003_Handle1
 1997 0330 00000000 		.word	PWMSP003_Handle2
 1998 0334 00000000 		.word	DMXControl
 1999 0338 00000000 		.word	startingSlot
 2000 033c 00000000 		.word	DMX_8
 2001 0340 00000000 		.word	DMX_16
 2002 0344 00000000 		.word	dmx_RedH
 2003 0348 00000000 		.word	dmx_RedL
 2004 034c 00000000 		.word	dmx_GreenH
 2005 0350 00000000 		.word	dmx_GreenL
 2006 0354 00000000 		.word	dmx_BlueH
 2007 0358 00000000 		.word	dmx_BlueL
 2008 035c 00000000 		.word	registerAddress
 2009 0360 00000000 		.word	writeToFlash
 2010 0364 00000000 		.word	flashBuffer
 2011 0368 00000000 		.word	flashAddress
 2012 036c 004F0010 		.word	268455680
 2013 0370 804F0010 		.word	268455808
 2014 0374 00000000 		.word	configStatus
 2015              		.cfi_endproc
 2016              	.LFE39:
 2018              		.comm	data5,2,1
 2019              		.comm	data4,2,1
 2020              		.comm	data3,2,1
 2021              		.comm	data2,2,1
 2022              		.comm	data1,2,1
 2023              		.text
 2024              	.Letext0:
 2025              		.file 2 "c:\\dave-3.1.10\\arm-gcc\\bin\\../lib/gcc/arm-none-eabi/4.7.4/../../../../arm-none-eabi/i
 2026              		.file 3 "C:\\DAVE-3.1.10\\eclipse\\/../CMSIS/Infineon/XMC1200_series/Include/XMC1200.h"
 2027              		.file 4 "C:\\Users\\tomasoat\\Userdata\\AEPrograms\\DAVE3_workspace_32_DAVE3110\\RGB_LED_Shield_v5
 2028              		.file 5 "C:\\Users\\tomasoat\\Userdata\\AEPrograms\\DAVE3_workspace_32_DAVE3110\\RGB_LED_Shield_v5
 2029              		.file 6 "C:\\Users\\tomasoat\\Userdata\\AEPrograms\\DAVE3_workspace_32_DAVE3110\\RGB_LED_Shield_v5
 2030              		.file 7 "C:\\Users\\tomasoat\\Userdata\\AEPrograms\\DAVE3_workspace_32_DAVE3110\\RGB_LED_Shield_v5
 2031              		.file 8 "C:\\Users\\tomasoat\\Userdata\\AEPrograms\\DAVE3_workspace_32_DAVE3110\\RGB_LED_Shield_v5
 2032              		.file 9 "C:\\Users\\tomasoat\\Userdata\\AEPrograms\\DAVE3_workspace_32_DAVE3110\\RGB_LED_Shield_v5
 2033              		.file 10 "C:\\Users\\tomasoat\\Userdata\\AEPrograms\\DAVE3_workspace_32_DAVE3110\\RGB_LED_Shield_v
 2034              		.file 11 "C:\\Users\\tomasoat\\Userdata\\AEPrograms\\DAVE3_workspace_32_DAVE3110\\RGB_LED_Shield_v
 2035              		.file 12 "C:\\Users\\tomasoat\\Userdata\\AEPrograms\\DAVE3_workspace_32_DAVE3110\\RGB_LED_Shield_v
 2036              		.file 13 "C:\\Users\\tomasoat\\Userdata\\AEPrograms\\DAVE3_workspace_32_DAVE3110\\RGB_LED_Shield_v
 2037              		.file 14 "C:\\Users\\tomasoat\\Userdata\\AEPrograms\\DAVE3_workspace_32_DAVE3110\\RGB_LED_Shield_v
 2038              		.file 15 "C:\\Users\\tomasoat\\Userdata\\AEPrograms\\DAVE3_workspace_32_DAVE3110\\RGB_LED_Shield_v
 2039              		.file 16 "C:\\Users\\tomasoat\\Userdata\\AEPrograms\\DAVE3_workspace_32_DAVE3110\\RGB_LED_Shield_v
 2040              		.file 17 "../i2c_comm.h"
DEFINED SYMBOLS
                            *ABS*:00000000 i2c_comm.c
C:\Users\tomasoat\AppData\Local\Temp\ccIZPjkN.s:18     .text.USIC0_1_IRQHandler:00000000 $t
C:\Users\tomasoat\AppData\Local\Temp\ccIZPjkN.s:23     .text.USIC0_1_IRQHandler:00000000 USIC0_1_IRQHandler
C:\Users\tomasoat\AppData\Local\Temp\ccIZPjkN.s:637    .text.USIC0_1_IRQHandler:00000318 $d
C:\Users\tomasoat\AppData\Local\Temp\ccIZPjkN.s:658    .text.USIC0_1_IRQHandler:00000364 $t
C:\Users\tomasoat\AppData\Local\Temp\ccIZPjkN.s:1265   .text.USIC0_1_IRQHandler:00000644 $d
C:\Users\tomasoat\AppData\Local\Temp\ccIZPjkN.s:1293   .text.USIC0_2_IRQHandler:00000000 $t
C:\Users\tomasoat\AppData\Local\Temp\ccIZPjkN.s:1298   .text.USIC0_2_IRQHandler:00000000 USIC0_2_IRQHandler
C:\Users\tomasoat\AppData\Local\Temp\ccIZPjkN.s:1982   .text.USIC0_2_IRQHandler:000002f4 $d
                            *COM*:00000002 data2
                            *COM*:00000002 data5
                            *COM*:00000002 data4
                            *COM*:00000002 data3
                            *COM*:00000002 data1
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.e09b9dd5224853206c418479f14d6963
                           .group:00000000 wm4.XMC1200.h.45.4c899b4822ac22c0f00d6fd7f173cc96
                           .group:00000000 wm4.core_cm0.h.47.022e66414e77714da7c4b30b3ad99fe8
                           .group:00000000 wm4.newlib.h.8.a9901dc52d1357e3e94003403d43f8b5
                           .group:00000000 wm4.features.h.22.b72b3baab2bb2eab3661375590100b6b
                           .group:00000000 wm4.config.h.193.5fb8ef056cdff92dec3dee9552839d8c
                           .group:00000000 wm4._ansi.h.23.7aefdac4826acebbfc9f3822a0aeb14c
                           .group:00000000 wm4.stdint.h.20.54ad762faa59e3c05491630641c8d8bf
                           .group:00000000 wm4.core_cmInstr.h.39.b7b6650bdd2316848d940915272d75b8
                           .group:00000000 wm4.core_cm0.h.135.ca70469f87e143609670bb393bfa6518
                           .group:00000000 wm4.XMC1000_RomFunctionTable.h.31.6d9a94465618f31b040dc9cea9a47ad7
                           .group:00000000 wm4.XMC1200.h.122.96b58b1204def4c9f76341a4e21abaf6
                           .group:00000000 wm4.stddef.h.40.50cf36416e06376af8a9dca28536f2e4
                           .group:00000000 wm4.types.h.60.e75c47576398c648cdcf9000ace5e3d8
                           .group:00000000 wm4.MULTIPLEXER.h.46.383e3edbb9cbf6e538f7c1532ef623c1
                           .group:00000000 wm4.uc_id.h.35.62dcba5f6261c1436e3866a751c1a98b
                           .group:00000000 wm4.BCCUDIM01_Conf.h.46.1e3ffd6581cbd401bcc28a6ce60f19f0
                           .group:00000000 wm4.BCCUCH01_Conf.h.48.2ce679450068d1645a9e0c3a7937e697
                           .group:00000000 wm4.CCU4Global_Conf.h.63.a52fac0daa39b5f58343578312b4eb54
                           .group:00000000 wm4.PWMSP003_Conf.h.49.a3ea83c25b3af429e78acb0f2dc45bd4
                           .group:00000000 wm4.PWMSP003.h.103.903071678b9af5683776405c5b299fbb
                           .group:00000000 wm4.IO002_Conf.h.51.9fc2eb43e77e0a2c02912a3744f3ec9d
                           .group:00000000 wm4.IO001.h.49.4efcabb368feaef60c65bd7504b48505
                           .group:00000000 wm4.NVIC002_Conf.h.62.64042456dc7f2eb96fc713abacb4c5d4
                           .group:00000000 wm4.DMX512RD01_Conf.h.49.036b57ce74a404ea8f8ade310b364436
                           .group:00000000 wm4.IO004.h.53.442ea5eb47ad9eedc675253aa35f3107
                           .group:00000000 wm4.Usic.h.40.f6a4fed014760114cf5039d398d6dd2c
                           .group:00000000 wm4.I2C003_Conf.h.50.5fb7c255d386301836868ba2fd78b91f
                           .group:00000000 wm4.FLASH003.h.76.20bf3d34b222314a45adfdfb414ab1b6
                           .group:00000000 wm4.FLASH003_Conf.h.72.6d366060eda228c6c8843c467361c30c

UNDEFINED SYMBOLS
I2C003_ClearFlag
I2C003_ReadData
BCCUCH01_AbortLinearWalk
BCCUCH01_SetIntensity
BCCUCH01_StartLinearWalk
PWMSP003_UpdateCompare
I2C003_Handle0
byteCount
Command
DataUpper
DataLower
DMXControl
flashBuffer
writeToFlash
DataTotal
BCCUCH01_Handle0
BCCUCH01_Handle1
BCCUCH01_Handle2
Lamphandle
BCCUCH01_Handle3
BCCUCH01_Handle4
BCCUCH01_Handle5
changeAddress
PWMSP003_Handle0
PWMSP003_Handle1
BCCUCH01_SetLinearWalkPrescaler
GET_CHANNEL_DIM_MASK
BCCUDIM01_AbortDimming
BCCUDIM01_SetDimLvl
BCCUDIM01_StartDimming
BCCUDIM01_SetDimDiv
COLORLAMP01_SetColor
PWMSP003_Handle2
BCCUDIM01_Handle0
registerAddress
startingSlot
DMX_8
DMX_16
dmx_RedH
dmx_RedL
COLORLAMP01_ConfigHandle0
DataDirect
dmx_BlueH
dmx_GreenH
dmx_GreenL
dmx_BlueL
BCCUCH01_GetIntensity
I2C003_WriteData
BCCUDIM01_GetDimLvl
BCCUDIM01_GetDimDiv
FLASH003_ClearStatus
FLASH003_ErasePage
FLASH003_WriteMultipleBlocks
FLASH003_ReadBytes
temp
flashAddress
configStatus
