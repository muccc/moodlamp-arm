
RGB_LED_Shield_v5.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000030b8  10001000  10001000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000010  100040b8  100040b8  000040b8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .rodata       000006d4  100040c8  100040c8  000040c8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .VENEER_Code  0000012c  2000000c  100047a0  0000800c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .GUARD_Band   00000008  20000138  00000000  00000138  2**0
                  ALLOC
  5 Stack         00000400  20000140  00000000  00000140  2**0
                  ALLOC
  6 .bss          000000ec  20000540  20000540  00010540  2**2
                  ALLOC
  7 .data         00000074  20000630  100048cc  00008630  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .debug_aranges 00000800  00000000  00000000  000086a8  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00010e97  00000000  00000000  00008ea8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00002ee9  00000000  00000000  00019d3f  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   000201c6  00000000  00000000  0001cc28  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00001084  00000000  00000000  0003cdf0  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00034c70  00000000  00000000  0003de74  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00004938  00000000  00000000  00072ae4  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00000658  00000000  00000000  00077420  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .build_attributes 00000909  00000000  00000000  00077a78  2**0
                  CONTENTS, READONLY
 17 .debug_macro  0000d38c  00000000  00000000  00078381  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

10001000 <__Xmc1200_interrupt_vector_cortex_m>:
10001000:	40 05 00 20 19 10 00 10 d1 1d 00 10 d3 1d 00 10     @.. ............
10001010:	00 04 00 00 00 00 00 00                             ........

10001018 <__Xmc1200_reset_cortex_m>:
__Xmc1200_reset_cortex_m:
    .fnstart

    /* C routines are likely to be called. Setup the stack now */
    /* This is already setup by BootROM,hence this step is optional */ 
    LDR R0,=__Xmc1200_stack
10001018:	4802      	ldr	r0, [pc, #8]	; (10001024 <__Xmc1200_reset_cortex_m+0xc>)
    MOV SP,R0
1000101a:	4685      	mov	sp, r0

    /* Launch custom pre-program loading startup procedure */
    LDR R0,=hardware_init_hook
1000101c:	4802      	ldr	r0, [pc, #8]	; (10001028 <__Xmc1200_reset_cortex_m+0x10>)
    BLX R0
1000101e:	4780      	blx	r0
    
    /* Branch to the program loader */
    B       __Xmc1200_Program_Loader 
10001020:	e004      	b.n	1000102c <__Xmc1200_Program_Loader>
10001022:	0000      	.short	0x0000
__Xmc1200_reset_cortex_m:
    .fnstart

    /* C routines are likely to be called. Setup the stack now */
    /* This is already setup by BootROM,hence this step is optional */ 
    LDR R0,=__Xmc1200_stack
10001024:	20000540 	.word	0x20000540
    MOV SP,R0

    /* Launch custom pre-program loading startup procedure */
    LDR R0,=hardware_init_hook
10001028:	100010bd 	.word	0x100010bd

1000102c <__Xmc1200_Program_Loader>:
   .fnstart
   /* Memories are accessible now*/
   
   /* DATA COPY */
   /* R0 = Start address, R1 = Destination address, R2 = Size */
   LDR R0, =DataLoadAddr
1000102c:	4816      	ldr	r0, [pc, #88]	; (10001088 <SKIPVENEERCOPY+0x16>)
   LDR R1, =__Xmc1200_sData
1000102e:	4917      	ldr	r1, [pc, #92]	; (1000108c <SKIPVENEERCOPY+0x1a>)
   LDR R2, =__Xmc1200_Data_Size
10001030:	4a17      	ldr	r2, [pc, #92]	; (10001090 <SKIPVENEERCOPY+0x1e>)

   /* Is there anything to be copied? */
   CMP R2,#0
10001032:	2a00      	cmp	r2, #0
   BEQ SKIPCOPY
10001034:	d007      	beq.n	10001046 <SKIPCOPY>

10001036 <STARTCOPY>:
STARTCOPY:
   /* 
      R2 contains byte count. Change it to word count. It is ensured in the 
      linker script that the length is always word aligned.
   */
   LSRS R2,R2,#2 /* Divide by 4 to obtain word count */
10001036:	0892      	lsrs	r2, r2, #2

10001038 <COPYLOOP>:

   /* The proverbial loop from the schooldays */
COPYLOOP:
   LDR R3,[R0]
10001038:	6803      	ldr	r3, [r0, #0]
   STR R3,[R1]
1000103a:	600b      	str	r3, [r1, #0]
   SUBS R2,#1
1000103c:	3a01      	subs	r2, #1
   BEQ SKIPCOPY
1000103e:	d002      	beq.n	10001046 <SKIPCOPY>
   ADDS R0,#4
10001040:	3004      	adds	r0, #4
   ADDS R1,#4
10001042:	3104      	adds	r1, #4
   B COPYLOOP
10001044:	e7f8      	b.n	10001038 <COPYLOOP>

10001046 <SKIPCOPY>:
    
SKIPCOPY:
   /* BSS CLEAR */
   LDR R0, =__Xmc1200_sBSS     /* Start of BSS */
10001046:	4813      	ldr	r0, [pc, #76]	; (10001094 <SKIPVENEERCOPY+0x22>)
   LDR R1, =__Xmc1200_BSS_Size /* BSS size in bytes */
10001048:	4913      	ldr	r1, [pc, #76]	; (10001098 <SKIPVENEERCOPY+0x26>)

   /* Find out if there are items assigned to BSS */   
   CMP R1,#0 
1000104a:	2900      	cmp	r1, #0
   BEQ SKIPCLEAR
1000104c:	d006      	beq.n	1000105c <SKIPCLEAR>

1000104e <STARTCLEAR>:

STARTCLEAR:
   LSRS R1,R1,#2            /* BSS size in words */
1000104e:	0889      	lsrs	r1, r1, #2
   
   MOVS R2,#0
10001050:	2200      	movs	r2, #0

10001052 <CLEARLOOP>:
CLEARLOOP:
   STR R2,[R0]
10001052:	6002      	str	r2, [r0, #0]
   SUBS R1,#1
10001054:	3901      	subs	r1, #1
   BEQ SKIPCLEAR
10001056:	d001      	beq.n	1000105c <SKIPCLEAR>
   ADDS R0,#4
10001058:	3004      	adds	r0, #4
   B CLEARLOOP
1000105a:	e7fa      	b.n	10001052 <CLEARLOOP>

1000105c <SKIPCLEAR>:
    
SKIPCLEAR:

   /* VENEER COPY */
   /* R0 = Start address, R1 = Destination address, R2 = Size */
   LDR R0, =VeneerLoadAddr
1000105c:	480f      	ldr	r0, [pc, #60]	; (1000109c <SKIPVENEERCOPY+0x2a>)
   LDR R1, =VeneerStart
1000105e:	4910      	ldr	r1, [pc, #64]	; (100010a0 <SKIPVENEERCOPY+0x2e>)
   LDR R2, =VeneerSize
10001060:	4a10      	ldr	r2, [pc, #64]	; (100010a4 <SKIPVENEERCOPY+0x32>)

10001062 <STARTVENEERCOPY>:
STARTVENEERCOPY:
   /* 
      R2 contains byte count. Change it to word count. It is ensured in the 
      linker script that the length is always word aligned.
   */
   LSRS R2,R2,#2 /* Divide by 4 to obtain word count */
10001062:	0892      	lsrs	r2, r2, #2

10001064 <VENEERCOPYLOOP>:

   /* The proverbial loop from the schooldays */
VENEERCOPYLOOP:
   LDR R3,[R0]
10001064:	6803      	ldr	r3, [r0, #0]
   STR R3,[R1]
10001066:	600b      	str	r3, [r1, #0]
   SUBS R2,#1
10001068:	3a01      	subs	r2, #1
   BEQ SKIPVENEERCOPY
1000106a:	d002      	beq.n	10001072 <SKIPVENEERCOPY>
   ADDS R0,#4
1000106c:	3004      	adds	r0, #4
   ADDS R1,#4
1000106e:	3104      	adds	r1, #4
   B VENEERCOPYLOOP
10001070:	e7f8      	b.n	10001064 <VENEERCOPYLOOP>

10001072 <SKIPVENEERCOPY>:
    
SKIPVENEERCOPY:

   /* Reset stack pointer before zipping off to user application, Optional */
   LDR R0,=__Xmc1200_stack 
10001072:	480d      	ldr	r0, [pc, #52]	; (100010a8 <SKIPVENEERCOPY+0x36>)
   MOV SP,R0
10001074:	4685      	mov	sp, r0

   /* Perform System Initialization */   
   LDR R0,=SystemInit
10001076:	480d      	ldr	r0, [pc, #52]	; (100010ac <SKIPVENEERCOPY+0x3a>)
   BLX R0
10001078:	4780      	blx	r0

   /* Launch custom post-program loading startup procedure */
   LDR R0,=software_init_hook
1000107a:	480d      	ldr	r0, [pc, #52]	; (100010b0 <SKIPVENEERCOPY+0x3e>)
   BLX R0
1000107c:	4780      	blx	r0

   MOVS R0,#0
1000107e:	2000      	movs	r0, #0
   MOVS R1,#0
10001080:	2100      	movs	r1, #0
   LDR R2, =main
10001082:	4a0c      	ldr	r2, [pc, #48]	; (100010b4 <SKIPVENEERCOPY+0x42>)
   MOV PC,R2
10001084:	4697      	mov	pc, r2
10001086:	0000      	.short	0x0000
   .fnstart
   /* Memories are accessible now*/
   
   /* DATA COPY */
   /* R0 = Start address, R1 = Destination address, R2 = Size */
   LDR R0, =DataLoadAddr
10001088:	100048cc 	.word	0x100048cc
   LDR R1, =__Xmc1200_sData
1000108c:	20000630 	.word	0x20000630
   LDR R2, =__Xmc1200_Data_Size
10001090:	00000074 	.word	0x00000074
   ADDS R1,#4
   B COPYLOOP
    
SKIPCOPY:
   /* BSS CLEAR */
   LDR R0, =__Xmc1200_sBSS     /* Start of BSS */
10001094:	20000540 	.word	0x20000540
   LDR R1, =__Xmc1200_BSS_Size /* BSS size in bytes */
10001098:	000000ec 	.word	0x000000ec
    
SKIPCLEAR:

   /* VENEER COPY */
   /* R0 = Start address, R1 = Destination address, R2 = Size */
   LDR R0, =VeneerLoadAddr
1000109c:	100047a0 	.word	0x100047a0
   LDR R1, =VeneerStart
100010a0:	2000000c 	.word	0x2000000c
   LDR R2, =VeneerSize
100010a4:	0000012c 	.word	0x0000012c
   B VENEERCOPYLOOP
    
SKIPVENEERCOPY:

   /* Reset stack pointer before zipping off to user application, Optional */
   LDR R0,=__Xmc1200_stack 
100010a8:	20000540 	.word	0x20000540
   MOV SP,R0

   /* Perform System Initialization */   
   LDR R0,=SystemInit
100010ac:	10001e49 	.word	0x10001e49
   BLX R0

   /* Launch custom post-program loading startup procedure */
   LDR R0,=software_init_hook
100010b0:	100010b9 	.word	0x100010b9
   BLX R0

   MOVS R0,#0
   MOVS R1,#0
   LDR R2, =main
100010b4:	100010c1 	.word	0x100010c1

100010b8 <software_init_hook>:
   has not been started.
 */
     .weak software_init_hook
     .type software_init_hook, %function
software_init_hook:
     NOP
100010b8:	46c0      	nop			; (mov r8, r8)
     BX LR
100010ba:	4770      	bx	lr

100010bc <hardware_init_hook>:
     .size software_init_hook, . - software_init_hook

     .weak hardware_init_hook
     .type hardware_init_hook, %function
hardware_init_hook:
     NOP
100010bc:	46c0      	nop			; (mov r8, r8)
     BX LR
100010be:	4770      	bx	lr

100010c0 <main>:
int writeToFlash = 0;
int configStatus = 1;


int main(void)
{
100010c0:	b573      	push	{r0, r1, r4, r5, r6, lr}

	// status_t status;		// Declaration of return variable for DAVE3 APIs (toggle comment if required)

	DAVE_Init();			// Initialization of DAVE Apps
100010c2:	f001 fdd9 	bl	10002c78 <DAVE_Init>

	// Stored data format: counter, Red, Green, Blue, Red, Green, Blue, DMXOFFON, DMXSTARING, DMXBIT, DMXRED, DMXGREEN, DMXBLUE, DMXREDL, DMXGREENL, DMXBLUEL, OFFRED, OFFGREEN, OFFBLUE, WALKTIME, DIMMINGLEVEL, FADERATE, ADDRESS
	FLASH003_ClearStatus();
100010c6:	f001 fc5f 	bl	10002988 <FLASH003_ClearStatus>
	//FLASH003_ErasePage((unsigned long )0x10004F00);
	FLASH003_ReadBytes(0x10004F80, flashBuffer, 92); // new address = 16 * number of blocks
100010ca:	4c82      	ldr	r4, [pc, #520]	; (100012d4 <main+0x214>)
100010cc:	4882      	ldr	r0, [pc, #520]	; (100012d8 <main+0x218>)
100010ce:	1c21      	adds	r1, r4, #0
100010d0:	225c      	movs	r2, #92	; 0x5c
100010d2:	f001 fcf1 	bl	10002ab8 <FLASH003_ReadBytes>

	if (flashBuffer[0] == 0xFFFFFFFF) // Last saved parameters in first half of page
100010d6:	6823      	ldr	r3, [r4, #0]
100010d8:	3301      	adds	r3, #1
100010da:	d104      	bne.n	100010e6 <main+0x26>
		FLASH003_ReadBytes(0x10004F00, flashBuffer, 92); // new address = 16 * number of blocks
100010dc:	487f      	ldr	r0, [pc, #508]	; (100012dc <main+0x21c>)
100010de:	1c21      	adds	r1, r4, #0
100010e0:	225c      	movs	r2, #92	; 0x5c
100010e2:	f001 fce9 	bl	10002ab8 <FLASH003_ReadBytes>

	if (flashBuffer[1] == 0xFFFFFFFF || flashBuffer[2] == 0xFFFFFFFF || flashBuffer[3] == 0xFFFFFFFF ||
100010e6:	6860      	ldr	r0, [r4, #4]
100010e8:	4a7d      	ldr	r2, [pc, #500]	; (100012e0 <main+0x220>)
100010ea:	1c43      	adds	r3, r0, #1
100010ec:	d03e      	beq.n	1000116c <main+0xac>
100010ee:	68a1      	ldr	r1, [r4, #8]
100010f0:	1c4b      	adds	r3, r1, #1
100010f2:	d03b      	beq.n	1000116c <main+0xac>
100010f4:	68e5      	ldr	r5, [r4, #12]
100010f6:	1c6b      	adds	r3, r5, #1
100010f8:	d038      	beq.n	1000116c <main+0xac>
100010fa:	6926      	ldr	r6, [r4, #16]
100010fc:	1c73      	adds	r3, r6, #1
100010fe:	d035      	beq.n	1000116c <main+0xac>
			flashBuffer[4] == 0xFFFFFFFF || flashBuffer[5] == 0xFFFFFFFF || flashBuffer[6] == 0xFFFFFFFF ||
10001100:	6963      	ldr	r3, [r4, #20]
10001102:	3301      	adds	r3, #1
10001104:	d032      	beq.n	1000116c <main+0xac>
10001106:	69a0      	ldr	r0, [r4, #24]
10001108:	1c43      	adds	r3, r0, #1
1000110a:	d02f      	beq.n	1000116c <main+0xac>
1000110c:	69e1      	ldr	r1, [r4, #28]
1000110e:	1c4b      	adds	r3, r1, #1
10001110:	d02c      	beq.n	1000116c <main+0xac>
			flashBuffer[7] == 0xFFFFFFFF || flashBuffer[8] == 0xFFFFFFFF || flashBuffer[9] == 0xFFFFFFFF ||
10001112:	6a25      	ldr	r5, [r4, #32]
10001114:	1c6b      	adds	r3, r5, #1
10001116:	d029      	beq.n	1000116c <main+0xac>
10001118:	6a66      	ldr	r6, [r4, #36]	; 0x24
1000111a:	1c73      	adds	r3, r6, #1
1000111c:	d026      	beq.n	1000116c <main+0xac>
1000111e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
10001120:	3301      	adds	r3, #1
10001122:	d023      	beq.n	1000116c <main+0xac>
			flashBuffer[10] == 0xFFFFFFFF || flashBuffer[11] == 0xFFFFFFFF || flashBuffer[12] == 0xFFFFFFFF ||
10001124:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
10001126:	1c43      	adds	r3, r0, #1
10001128:	d020      	beq.n	1000116c <main+0xac>
1000112a:	6b21      	ldr	r1, [r4, #48]	; 0x30
1000112c:	1c4b      	adds	r3, r1, #1
1000112e:	d01d      	beq.n	1000116c <main+0xac>
10001130:	6b65      	ldr	r5, [r4, #52]	; 0x34
10001132:	1c6b      	adds	r3, r5, #1
10001134:	d01a      	beq.n	1000116c <main+0xac>
			flashBuffer[13] == 0xFFFFFFFF || flashBuffer[14] == 0xFFFFFFFF || flashBuffer[15] == 0xFFFFFFFF ||
10001136:	6ba6      	ldr	r6, [r4, #56]	; 0x38
10001138:	1c73      	adds	r3, r6, #1
1000113a:	d017      	beq.n	1000116c <main+0xac>
1000113c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
1000113e:	3301      	adds	r3, #1
10001140:	d014      	beq.n	1000116c <main+0xac>
10001142:	6c20      	ldr	r0, [r4, #64]	; 0x40
10001144:	1c43      	adds	r3, r0, #1
10001146:	d011      	beq.n	1000116c <main+0xac>
			flashBuffer[16] == 0xFFFFFFFF || flashBuffer[17] == 0xFFFFFFFF || flashBuffer[18] == 0xFFFFFFFF ||
10001148:	6c61      	ldr	r1, [r4, #68]	; 0x44
1000114a:	1c4b      	adds	r3, r1, #1
1000114c:	d00e      	beq.n	1000116c <main+0xac>
1000114e:	6ca5      	ldr	r5, [r4, #72]	; 0x48
10001150:	1c6b      	adds	r3, r5, #1
10001152:	d00b      	beq.n	1000116c <main+0xac>
10001154:	6ce6      	ldr	r6, [r4, #76]	; 0x4c
10001156:	1c73      	adds	r3, r6, #1
10001158:	d008      	beq.n	1000116c <main+0xac>
			flashBuffer[19] == 0xFFFFFFFF || flashBuffer[20] == 0xFFFFFFFF || flashBuffer[21] == 0xFFFFFFFF || flashBuffer[22] == 0xFFFFFFFF )
1000115a:	6d23      	ldr	r3, [r4, #80]	; 0x50
1000115c:	3301      	adds	r3, #1
1000115e:	d005      	beq.n	1000116c <main+0xac>
10001160:	6d60      	ldr	r0, [r4, #84]	; 0x54
10001162:	1c43      	adds	r3, r0, #1
10001164:	d002      	beq.n	1000116c <main+0xac>
10001166:	6da1      	ldr	r1, [r4, #88]	; 0x58
10001168:	1c4b      	adds	r3, r1, #1
1000116a:	d121      	bne.n	100011b0 <main+0xf0>
	{
		configStatus = 0;	// virgin device, nothing has been saved in Flash yet
1000116c:	2500      	movs	r5, #0
		flashBuffer[9] = 8; // DMX 8 Bit
		flashBuffer[10] = 0; // Default dmx_RedH = 0 offset
		flashBuffer[11] = 0; // Default DMX_RedL
		flashBuffer[12] = 1; // Default DMX_GreenH = 1 offset
		flashBuffer[13] = 0; // Default dmx_GreenL
		flashBuffer[14] = 2;  // Default DMX_BlueH = 2 offset
1000116e:	2102      	movs	r1, #2
			flashBuffer[13] == 0xFFFFFFFF || flashBuffer[14] == 0xFFFFFFFF || flashBuffer[15] == 0xFFFFFFFF ||
			flashBuffer[16] == 0xFFFFFFFF || flashBuffer[17] == 0xFFFFFFFF || flashBuffer[18] == 0xFFFFFFFF ||
			flashBuffer[19] == 0xFFFFFFFF || flashBuffer[20] == 0xFFFFFFFF || flashBuffer[21] == 0xFFFFFFFF || flashBuffer[22] == 0xFFFFFFFF )
	{
		configStatus = 0;	// virgin device, nothing has been saved in Flash yet
		flashBuffer[0] = 1;
10001170:	2601      	movs	r6, #1
		flashBuffer[1] = 0; // Default Red Intensity
		flashBuffer[2] = 0; // Default Green Intensity
		flashBuffer[3] = 0; // Default Blue Intensity
		flashBuffer[4] = 0x15; // Default Red Current
10001172:	2315      	movs	r3, #21
		flashBuffer[5] = 0x15; // Default Green Current
		flashBuffer[6] = 0x15; // Default Blue Current
		flashBuffer[7] = 0; // Default DMX off
		flashBuffer[8] = 1; // DMX Starting Slot - 1
		flashBuffer[9] = 8; // DMX 8 Bit
10001174:	2008      	movs	r0, #8
			flashBuffer[10] == 0xFFFFFFFF || flashBuffer[11] == 0xFFFFFFFF || flashBuffer[12] == 0xFFFFFFFF ||
			flashBuffer[13] == 0xFFFFFFFF || flashBuffer[14] == 0xFFFFFFFF || flashBuffer[15] == 0xFFFFFFFF ||
			flashBuffer[16] == 0xFFFFFFFF || flashBuffer[17] == 0xFFFFFFFF || flashBuffer[18] == 0xFFFFFFFF ||
			flashBuffer[19] == 0xFFFFFFFF || flashBuffer[20] == 0xFFFFFFFF || flashBuffer[21] == 0xFFFFFFFF || flashBuffer[22] == 0xFFFFFFFF )
	{
		configStatus = 0;	// virgin device, nothing has been saved in Flash yet
10001176:	6015      	str	r5, [r2, #0]
		flashBuffer[0] = 1;
		flashBuffer[1] = 0; // Default Red Intensity
10001178:	6065      	str	r5, [r4, #4]
		flashBuffer[2] = 0; // Default Green Intensity
1000117a:	60a5      	str	r5, [r4, #8]
		flashBuffer[3] = 0; // Default Blue Intensity
1000117c:	60e5      	str	r5, [r4, #12]
		flashBuffer[4] = 0x15; // Default Red Current
		flashBuffer[5] = 0x15; // Default Green Current
		flashBuffer[6] = 0x15; // Default Blue Current
		flashBuffer[7] = 0; // Default DMX off
1000117e:	61e5      	str	r5, [r4, #28]
		flashBuffer[8] = 1; // DMX Starting Slot - 1
		flashBuffer[9] = 8; // DMX 8 Bit
		flashBuffer[10] = 0; // Default dmx_RedH = 0 offset
10001180:	62a5      	str	r5, [r4, #40]	; 0x28
		flashBuffer[11] = 0; // Default DMX_RedL
10001182:	62e5      	str	r5, [r4, #44]	; 0x2c
		flashBuffer[12] = 1; // Default DMX_GreenH = 1 offset
		flashBuffer[13] = 0; // Default dmx_GreenL
10001184:	6365      	str	r5, [r4, #52]	; 0x34
		flashBuffer[14] = 2;  // Default DMX_BlueH = 2 offset
10001186:	63a1      	str	r1, [r4, #56]	; 0x38
		flashBuffer[15] = 0; // Default DMX_BlueL
10001188:	63e5      	str	r5, [r4, #60]	; 0x3c
		flashBuffer[16] = 0x38; // Red Off Time
		flashBuffer[17] = 0x39; // Green Off Time
		flashBuffer[18] = 0x38; // Blue Off Time
		flashBuffer[19] = 0x10; // Walktime
		flashBuffer[20] = 0xFFF; // Dimming Level
1000118a:	4956      	ldr	r1, [pc, #344]	; (100012e4 <main+0x224>)
		flashBuffer[21] = 0x00; // Fade Rate
1000118c:	6565      	str	r5, [r4, #84]	; 0x54
		flashBuffer[22] = 0xF25E; // Address
1000118e:	4d56      	ldr	r5, [pc, #344]	; (100012e8 <main+0x228>)
			flashBuffer[13] == 0xFFFFFFFF || flashBuffer[14] == 0xFFFFFFFF || flashBuffer[15] == 0xFFFFFFFF ||
			flashBuffer[16] == 0xFFFFFFFF || flashBuffer[17] == 0xFFFFFFFF || flashBuffer[18] == 0xFFFFFFFF ||
			flashBuffer[19] == 0xFFFFFFFF || flashBuffer[20] == 0xFFFFFFFF || flashBuffer[21] == 0xFFFFFFFF || flashBuffer[22] == 0xFFFFFFFF )
	{
		configStatus = 0;	// virgin device, nothing has been saved in Flash yet
		flashBuffer[0] = 1;
10001190:	6026      	str	r6, [r4, #0]
		flashBuffer[1] = 0; // Default Red Intensity
		flashBuffer[2] = 0; // Default Green Intensity
		flashBuffer[3] = 0; // Default Blue Intensity
		flashBuffer[4] = 0x15; // Default Red Current
10001192:	6123      	str	r3, [r4, #16]
		flashBuffer[5] = 0x15; // Default Green Current
10001194:	6163      	str	r3, [r4, #20]
		flashBuffer[6] = 0x15; // Default Blue Current
10001196:	61a3      	str	r3, [r4, #24]
		flashBuffer[7] = 0; // Default DMX off
		flashBuffer[8] = 1; // DMX Starting Slot - 1
10001198:	6226      	str	r6, [r4, #32]
		flashBuffer[9] = 8; // DMX 8 Bit
1000119a:	6260      	str	r0, [r4, #36]	; 0x24
		flashBuffer[10] = 0; // Default dmx_RedH = 0 offset
		flashBuffer[11] = 0; // Default DMX_RedL
		flashBuffer[12] = 1; // Default DMX_GreenH = 1 offset
1000119c:	6326      	str	r6, [r4, #48]	; 0x30
		flashBuffer[13] = 0; // Default dmx_GreenL
		flashBuffer[14] = 2;  // Default DMX_BlueH = 2 offset
		flashBuffer[15] = 0; // Default DMX_BlueL
		flashBuffer[16] = 0x38; // Red Off Time
		flashBuffer[17] = 0x39; // Green Off Time
1000119e:	2339      	movs	r3, #57	; 0x39
		flashBuffer[11] = 0; // Default DMX_RedL
		flashBuffer[12] = 1; // Default DMX_GreenH = 1 offset
		flashBuffer[13] = 0; // Default dmx_GreenL
		flashBuffer[14] = 2;  // Default DMX_BlueH = 2 offset
		flashBuffer[15] = 0; // Default DMX_BlueL
		flashBuffer[16] = 0x38; // Red Off Time
100011a0:	2638      	movs	r6, #56	; 0x38
		flashBuffer[17] = 0x39; // Green Off Time
		flashBuffer[18] = 0x38; // Blue Off Time
		flashBuffer[19] = 0x10; // Walktime
100011a2:	2010      	movs	r0, #16
		flashBuffer[11] = 0; // Default DMX_RedL
		flashBuffer[12] = 1; // Default DMX_GreenH = 1 offset
		flashBuffer[13] = 0; // Default dmx_GreenL
		flashBuffer[14] = 2;  // Default DMX_BlueH = 2 offset
		flashBuffer[15] = 0; // Default DMX_BlueL
		flashBuffer[16] = 0x38; // Red Off Time
100011a4:	6426      	str	r6, [r4, #64]	; 0x40
		flashBuffer[17] = 0x39; // Green Off Time
100011a6:	6463      	str	r3, [r4, #68]	; 0x44
		flashBuffer[18] = 0x38; // Blue Off Time
100011a8:	64a6      	str	r6, [r4, #72]	; 0x48
		flashBuffer[19] = 0x10; // Walktime
100011aa:	64e0      	str	r0, [r4, #76]	; 0x4c
		flashBuffer[20] = 0xFFF; // Dimming Level
100011ac:	6521      	str	r1, [r4, #80]	; 0x50
		flashBuffer[21] = 0x00; // Fade Rate
		flashBuffer[22] = 0xF25E; // Address
100011ae:	65a5      	str	r5, [r4, #88]	; 0x58
	}


	DMXControl = flashBuffer[7];
100011b0:	69e6      	ldr	r6, [r4, #28]
	startingSlot = flashBuffer[8];
100011b2:	8c23      	ldrh	r3, [r4, #32]
	if (flashBuffer[9] == 0x8) // 8 bit DMX
100011b4:	6a60      	ldr	r0, [r4, #36]	; 0x24
		flashBuffer[21] = 0x00; // Fade Rate
		flashBuffer[22] = 0xF25E; // Address
	}


	DMXControl = flashBuffer[7];
100011b6:	6056      	str	r6, [r2, #4]
	startingSlot = flashBuffer[8];
100011b8:	8113      	strh	r3, [r2, #8]
	if (flashBuffer[9] == 0x8) // 8 bit DMX
100011ba:	2808      	cmp	r0, #8
100011bc:	d10b      	bne.n	100011d6 <main+0x116>
	{
		DMX_8 = 1;
100011be:	2501      	movs	r5, #1
		DMX_16 = 0;
100011c0:	4b4a      	ldr	r3, [pc, #296]	; (100012ec <main+0x22c>)

	DMXControl = flashBuffer[7];
	startingSlot = flashBuffer[8];
	if (flashBuffer[9] == 0x8) // 8 bit DMX
	{
		DMX_8 = 1;
100011c2:	60d5      	str	r5, [r2, #12]
		DMX_16 = 0;
		dmx_RedH = flashBuffer[10]; // dmx slot for red colour intensity
100011c4:	8d21      	ldrh	r1, [r4, #40]	; 0x28
		dmx_GreenH = flashBuffer[12]; // dmx slot for green colour intensity
100011c6:	8e22      	ldrh	r2, [r4, #48]	; 0x30
		dmx_BlueH = flashBuffer[14]; // dmx slot for blue colour intensity
100011c8:	8f26      	ldrh	r6, [r4, #56]	; 0x38
	DMXControl = flashBuffer[7];
	startingSlot = flashBuffer[8];
	if (flashBuffer[9] == 0x8) // 8 bit DMX
	{
		DMX_8 = 1;
		DMX_16 = 0;
100011ca:	2000      	movs	r0, #0
100011cc:	6018      	str	r0, [r3, #0]
		dmx_RedH = flashBuffer[10]; // dmx slot for red colour intensity
100011ce:	8099      	strh	r1, [r3, #4]
		dmx_GreenH = flashBuffer[12]; // dmx slot for green colour intensity
100011d0:	80da      	strh	r2, [r3, #6]
		dmx_BlueH = flashBuffer[14]; // dmx slot for blue colour intensity
100011d2:	811e      	strh	r6, [r3, #8]
100011d4:	e012      	b.n	100011fc <main+0x13c>
	}

	else if (flashBuffer[9] == 0x16) // 16 bit DMX
100011d6:	2816      	cmp	r0, #22
100011d8:	d110      	bne.n	100011fc <main+0x13c>
	{
		DMX_8 = 0;
		DMX_16 = 1;
100011da:	4d44      	ldr	r5, [pc, #272]	; (100012ec <main+0x22c>)
		dmx_BlueH = flashBuffer[14]; // dmx slot for blue colour intensity
	}

	else if (flashBuffer[9] == 0x16) // 16 bit DMX
	{
		DMX_8 = 0;
100011dc:	2100      	movs	r1, #0
		DMX_16 = 1;
		dmx_RedH = flashBuffer[10]; // dmx slot for higher bits of red colour intensity
100011de:	8d26      	ldrh	r6, [r4, #40]	; 0x28
		dmx_BlueH = flashBuffer[14]; // dmx slot for blue colour intensity
	}

	else if (flashBuffer[9] == 0x16) // 16 bit DMX
	{
		DMX_8 = 0;
100011e0:	60d1      	str	r1, [r2, #12]
		DMX_16 = 1;
100011e2:	2201      	movs	r2, #1
100011e4:	602a      	str	r2, [r5, #0]
		dmx_RedH = flashBuffer[10]; // dmx slot for higher bits of red colour intensity
100011e6:	80ae      	strh	r6, [r5, #4]
		dmx_GreenH = flashBuffer[12]; // dmx slot for lower 8 bits of red colour intensity
100011e8:	8e23      	ldrh	r3, [r4, #48]	; 0x30
		dmx_BlueH = flashBuffer[14]; // dmx slot for higher bits of green colour intensity
100011ea:	8f20      	ldrh	r0, [r4, #56]	; 0x38
		dmx_RedL = flashBuffer[11]; // dmx slot for lower 8 bits of green colour intensity
100011ec:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
		dmx_GreenL = flashBuffer[13]; // dmx slot for higher 8 bits of blue colour intensity
100011ee:	8ea2      	ldrh	r2, [r4, #52]	; 0x34
		dmx_BlueL = flashBuffer[15]; // dmx slot for lower 8 bits of blue colour intensity
100011f0:	8fa6      	ldrh	r6, [r4, #60]	; 0x3c
	else if (flashBuffer[9] == 0x16) // 16 bit DMX
	{
		DMX_8 = 0;
		DMX_16 = 1;
		dmx_RedH = flashBuffer[10]; // dmx slot for higher bits of red colour intensity
		dmx_GreenH = flashBuffer[12]; // dmx slot for lower 8 bits of red colour intensity
100011f2:	80eb      	strh	r3, [r5, #6]
		dmx_BlueH = flashBuffer[14]; // dmx slot for higher bits of green colour intensity
100011f4:	8128      	strh	r0, [r5, #8]
		dmx_RedL = flashBuffer[11]; // dmx slot for lower 8 bits of green colour intensity
100011f6:	8169      	strh	r1, [r5, #10]
		dmx_GreenL = flashBuffer[13]; // dmx slot for higher 8 bits of blue colour intensity
100011f8:	81aa      	strh	r2, [r5, #12]
		dmx_BlueL = flashBuffer[15]; // dmx slot for lower 8 bits of blue colour intensity
100011fa:	81ee      	strh	r6, [r5, #14]
	}


	// Configure Off Times (compare values)
	PWMSP003_UpdateCompare(&PWMSP003_Handle0, flashBuffer[16], FALSE); // pwm of red channel
100011fc:	6c21      	ldr	r1, [r4, #64]	; 0x40
100011fe:	2200      	movs	r2, #0
10001200:	483b      	ldr	r0, [pc, #236]	; (100012f0 <main+0x230>)
10001202:	f001 f8df 	bl	100023c4 <PWMSP003_UpdateCompare>
	PWMSP003_UpdateCompare(&PWMSP003_Handle1, flashBuffer[17], FALSE); // pwm of green channel
10001206:	6c61      	ldr	r1, [r4, #68]	; 0x44
10001208:	2200      	movs	r2, #0
1000120a:	483a      	ldr	r0, [pc, #232]	; (100012f4 <main+0x234>)
1000120c:	f001 f8da 	bl	100023c4 <PWMSP003_UpdateCompare>
	PWMSP003_UpdateCompare(&PWMSP003_Handle2, flashBuffer[18], FALSE); // pwm of blue channel
10001210:	2200      	movs	r2, #0
10001212:	6ca1      	ldr	r1, [r4, #72]	; 0x48
10001214:	4838      	ldr	r0, [pc, #224]	; (100012f8 <main+0x238>)
10001216:	f001 f8d5 	bl	100023c4 <PWMSP003_UpdateCompare>

	// Configure Current Intensities
	BCCUCH01_SetIntensity(&BCCUCH01_Handle3, flashBuffer[4]); // BCCU for red channel colour intensity
1000121a:	4d38      	ldr	r5, [pc, #224]	; (100012fc <main+0x23c>)
1000121c:	6921      	ldr	r1, [r4, #16]
1000121e:	1c28      	adds	r0, r5, #0
10001220:	f002 f875 	bl	1000330e <BCCUCH01_SetIntensity>
	BCCUCH01_StartLinearWalk(&BCCUCH01_Handle3, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle3.ChNum));
10001224:	2601      	movs	r6, #1
10001226:	68ab      	ldr	r3, [r5, #8]
10001228:	1c31      	adds	r1, r6, #0
1000122a:	4099      	lsls	r1, r3
1000122c:	1c28      	adds	r0, r5, #0
1000122e:	f002 f863 	bl	100032f8 <BCCUCH01_StartLinearWalk>
	BCCUCH01_SetIntensity(&BCCUCH01_Handle4, flashBuffer[5]); // BCCU for green channel colour intensity
10001232:	4d33      	ldr	r5, [pc, #204]	; (10001300 <main+0x240>)
10001234:	6961      	ldr	r1, [r4, #20]
10001236:	1c28      	adds	r0, r5, #0
10001238:	f002 f869 	bl	1000330e <BCCUCH01_SetIntensity>
	BCCUCH01_StartLinearWalk(&BCCUCH01_Handle4, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle4.ChNum));
1000123c:	68a8      	ldr	r0, [r5, #8]
1000123e:	1c31      	adds	r1, r6, #0
10001240:	4081      	lsls	r1, r0
10001242:	1c28      	adds	r0, r5, #0
10001244:	f002 f858 	bl	100032f8 <BCCUCH01_StartLinearWalk>
	BCCUCH01_SetIntensity(&BCCUCH01_Handle5, flashBuffer[6]); // BCCU for blue channel colour intensity
10001248:	4d2e      	ldr	r5, [pc, #184]	; (10001304 <main+0x244>)
1000124a:	69a1      	ldr	r1, [r4, #24]
1000124c:	1c28      	adds	r0, r5, #0
1000124e:	f002 f85e 	bl	1000330e <BCCUCH01_SetIntensity>
	BCCUCH01_StartLinearWalk(&BCCUCH01_Handle5, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle5.ChNum));
10001252:	68aa      	ldr	r2, [r5, #8]
10001254:	1c31      	adds	r1, r6, #0
10001256:	4091      	lsls	r1, r2
10001258:	1c28      	adds	r0, r5, #0
1000125a:	f002 f84d 	bl	100032f8 <BCCUCH01_StartLinearWalk>

	// Set Fade Rate + Dimming Level
	BCCUDIM01_AbortDimming(&BCCUDIM01_Handle0, GET_CHANNEL_DIM_MASK(BCCUDIM01_Handle0.DE_Num));
1000125e:	4d2a      	ldr	r5, [pc, #168]	; (10001308 <main+0x248>)
10001260:	7a2e      	ldrb	r6, [r5, #8]
10001262:	1c30      	adds	r0, r6, #0
10001264:	f001 ff3c 	bl	100030e0 <GET_CHANNEL_DIM_MASK>
10001268:	1c01      	adds	r1, r0, #0
1000126a:	1c28      	adds	r0, r5, #0
1000126c:	f001 ffa7 	bl	100031be <BCCUDIM01_AbortDimming>
	BCCUDIM01_SetDimDiv(&BCCUDIM01_Handle0, flashBuffer[21]); // dimming engine 2
10001270:	6d61      	ldr	r1, [r4, #84]	; 0x54
10001272:	1c28      	adds	r0, r5, #0
10001274:	f001 ffb7 	bl	100031e6 <BCCUDIM01_SetDimDiv>
	BCCUDIM01_AbortDimming(&BCCUDIM01_Handle0, GET_CHANNEL_DIM_MASK(BCCUDIM01_Handle0.DE_Num));
10001278:	1c30      	adds	r0, r6, #0
1000127a:	f001 ff31 	bl	100030e0 <GET_CHANNEL_DIM_MASK>
1000127e:	1c01      	adds	r1, r0, #0
10001280:	1c28      	adds	r0, r5, #0
10001282:	f001 ff9c 	bl	100031be <BCCUDIM01_AbortDimming>
	BCCUDIM01_SetDimLvl(&BCCUDIM01_Handle0, flashBuffer[20]);
10001286:	6d21      	ldr	r1, [r4, #80]	; 0x50
10001288:	1c28      	adds	r0, r5, #0
1000128a:	f001 ff9e 	bl	100031ca <BCCUDIM01_SetDimLvl>
	BCCUDIM01_StartDimming(&BCCUDIM01_Handle0, GET_CHANNEL_DIM_MASK(BCCUDIM01_Handle0.DE_Num));
1000128e:	1c30      	adds	r0, r6, #0
10001290:	f001 ff26 	bl	100030e0 <GET_CHANNEL_DIM_MASK>
10001294:	1c01      	adds	r1, r0, #0
10001296:	1c28      	adds	r0, r5, #0
10001298:	f001 ff8c 	bl	100031b4 <BCCUDIM01_StartDimming>

	//Configure Color Intensities + Walktime + Faderate + Dimming Level
	Lamphandle.LinearWalkPrescaler = flashBuffer[19];
1000129c:	491b      	ldr	r1, [pc, #108]	; (1000130c <main+0x24c>)
	Lamphandle.Intensity_Red = flashBuffer[1];
1000129e:	6860      	ldr	r0, [r4, #4]
	BCCUDIM01_AbortDimming(&BCCUDIM01_Handle0, GET_CHANNEL_DIM_MASK(BCCUDIM01_Handle0.DE_Num));
	BCCUDIM01_SetDimLvl(&BCCUDIM01_Handle0, flashBuffer[20]);
	BCCUDIM01_StartDimming(&BCCUDIM01_Handle0, GET_CHANNEL_DIM_MASK(BCCUDIM01_Handle0.DE_Num));

	//Configure Color Intensities + Walktime + Faderate + Dimming Level
	Lamphandle.LinearWalkPrescaler = flashBuffer[19];
100012a0:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
	Lamphandle.Intensity_Red = flashBuffer[1];
	Lamphandle.Intensity_Green = flashBuffer[2];
100012a2:	68a2      	ldr	r2, [r4, #8]
	Lamphandle.Intensity_Blue = flashBuffer[3];
100012a4:	68e5      	ldr	r5, [r4, #12]
	BCCUDIM01_SetDimLvl(&BCCUDIM01_Handle0, flashBuffer[20]);
	BCCUDIM01_StartDimming(&BCCUDIM01_Handle0, GET_CHANNEL_DIM_MASK(BCCUDIM01_Handle0.DE_Num));

	//Configure Color Intensities + Walktime + Faderate + Dimming Level
	Lamphandle.LinearWalkPrescaler = flashBuffer[19];
	Lamphandle.Intensity_Red = flashBuffer[1];
100012a6:	6008      	str	r0, [r1, #0]
	Lamphandle.Intensity_Green = flashBuffer[2];
	Lamphandle.Intensity_Blue = flashBuffer[3];
	COLORLAMP01_SetColor(&COLORLAMP01_ConfigHandle0, &Lamphandle);
100012a8:	4819      	ldr	r0, [pc, #100]	; (10001310 <main+0x250>)
	BCCUDIM01_AbortDimming(&BCCUDIM01_Handle0, GET_CHANNEL_DIM_MASK(BCCUDIM01_Handle0.DE_Num));
	BCCUDIM01_SetDimLvl(&BCCUDIM01_Handle0, flashBuffer[20]);
	BCCUDIM01_StartDimming(&BCCUDIM01_Handle0, GET_CHANNEL_DIM_MASK(BCCUDIM01_Handle0.DE_Num));

	//Configure Color Intensities + Walktime + Faderate + Dimming Level
	Lamphandle.LinearWalkPrescaler = flashBuffer[19];
100012aa:	618b      	str	r3, [r1, #24]
	Lamphandle.Intensity_Red = flashBuffer[1];
	Lamphandle.Intensity_Green = flashBuffer[2];
100012ac:	604a      	str	r2, [r1, #4]
	Lamphandle.Intensity_Blue = flashBuffer[3];
100012ae:	608d      	str	r5, [r1, #8]
	COLORLAMP01_SetColor(&COLORLAMP01_ConfigHandle0, &Lamphandle);
100012b0:	f001 fe2f 	bl	10002f12 <COLORLAMP01_SetColor>


	I2C003_ClearFlag(&I2C003_Handle0, I2C003_FLAG_NACK_RECEIVED);
100012b4:	4e17      	ldr	r6, [pc, #92]	; (10001314 <main+0x254>)
100012b6:	2106      	movs	r1, #6
100012b8:	1c30      	adds	r0, r6, #0
100012ba:	f001 fb3c 	bl	10002936 <I2C003_ClearFlag>

	// Configure Address 0x15E (10 bit addressing). Address stored in lower 16 bits of register.
	I2C003_Handle0.I2CRegs->PCR_IICMode &= 0xFFFF0000;
100012be:	6833      	ldr	r3, [r6, #0]
100012c0:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
100012c2:	0c08      	lsrs	r0, r1, #16
100012c4:	0402      	lsls	r2, r0, #16
100012c6:	63da      	str	r2, [r3, #60]	; 0x3c
	I2C003_Handle0.I2CRegs->PCR_IICMode |= flashBuffer[22];
100012c8:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
100012ca:	6da4      	ldr	r4, [r4, #88]	; 0x58
100012cc:	432c      	orrs	r4, r5
100012ce:	63dc      	str	r4, [r3, #60]	; 0x3c
100012d0:	e7fe      	b.n	100012d0 <main+0x210>
100012d2:	46c0      	nop			; (mov r8, r8)
100012d4:	200005a8 	.word	0x200005a8
100012d8:	10004f80 	.word	0x10004f80
100012dc:	10004f00 	.word	0x10004f00
100012e0:	20000630 	.word	0x20000630
100012e4:	00000fff 	.word	0x00000fff
100012e8:	0000f25e 	.word	0x0000f25e
100012ec:	20000540 	.word	0x20000540
100012f0:	10004198 	.word	0x10004198
100012f4:	10004130 	.word	0x10004130
100012f8:	100040c8 	.word	0x100040c8
100012fc:	100045ac 	.word	0x100045ac
10001300:	10004558 	.word	0x10004558
10001304:	10004504 	.word	0x10004504
10001308:	100044ec 	.word	0x100044ec
1000130c:	2000058c 	.word	0x2000058c
10001310:	100044a8 	.word	0x100044a8
10001314:	10004460 	.word	0x10004460

10001318 <DMX512RD01_CallBack>:
	}
	return 0;
}

void DMX512RD01_CallBack(void)
{
10001318:	b510      	push	{r4, lr}
	DMX512RD01_ConfigStartSlotNo(1);
1000131a:	2001      	movs	r0, #1
1000131c:	f001 fc4c 	bl	10002bb8 <DMX512RD01_ConfigStartSlotNo>

	if (DMXControl == 1 && DMX_8 == 1)
10001320:	4b1f      	ldr	r3, [pc, #124]	; (100013a0 <DMX512RD01_CallBack+0x88>)
10001322:	685a      	ldr	r2, [r3, #4]
10001324:	2a01      	cmp	r2, #1
10001326:	d13a      	bne.n	1000139e <DMX512RD01_CallBack+0x86>
10001328:	68d8      	ldr	r0, [r3, #12]
1000132a:	4b1e      	ldr	r3, [pc, #120]	; (100013a4 <DMX512RD01_CallBack+0x8c>)
1000132c:	2801      	cmp	r0, #1
1000132e:	d110      	bne.n	10001352 <DMX512RD01_CallBack+0x3a>
	{
		Lamphandle.Intensity_Red = DMX512RD01_buffer[dmx_RedH]<<4;				// 8-bit information in Slot 1
10001330:	8898      	ldrh	r0, [r3, #4]
10001332:	4a1d      	ldr	r2, [pc, #116]	; (100013a8 <DMX512RD01_CallBack+0x90>)
10001334:	0084      	lsls	r4, r0, #2
10001336:	58a0      	ldr	r0, [r4, r2]
10001338:	491c      	ldr	r1, [pc, #112]	; (100013ac <DMX512RD01_CallBack+0x94>)
1000133a:	0104      	lsls	r4, r0, #4
		Lamphandle.Intensity_Green = DMX512RD01_buffer[dmx_GreenH]<<4;			// 8-bit information in Slot 2
1000133c:	88d8      	ldrh	r0, [r3, #6]
{
	DMX512RD01_ConfigStartSlotNo(1);

	if (DMXControl == 1 && DMX_8 == 1)
	{
		Lamphandle.Intensity_Red = DMX512RD01_buffer[dmx_RedH]<<4;				// 8-bit information in Slot 1
1000133e:	600c      	str	r4, [r1, #0]
		Lamphandle.Intensity_Green = DMX512RD01_buffer[dmx_GreenH]<<4;			// 8-bit information in Slot 2
10001340:	0084      	lsls	r4, r0, #2
10001342:	58a0      	ldr	r0, [r4, r2]
		Lamphandle.Intensity_Blue = DMX512RD01_buffer[dmx_BlueH]<<4;			// 8-bit information in Slot 3
10001344:	891b      	ldrh	r3, [r3, #8]
	DMX512RD01_ConfigStartSlotNo(1);

	if (DMXControl == 1 && DMX_8 == 1)
	{
		Lamphandle.Intensity_Red = DMX512RD01_buffer[dmx_RedH]<<4;				// 8-bit information in Slot 1
		Lamphandle.Intensity_Green = DMX512RD01_buffer[dmx_GreenH]<<4;			// 8-bit information in Slot 2
10001346:	0104      	lsls	r4, r0, #4
		Lamphandle.Intensity_Blue = DMX512RD01_buffer[dmx_BlueH]<<4;			// 8-bit information in Slot 3
10001348:	0098      	lsls	r0, r3, #2
1000134a:	5882      	ldr	r2, [r0, r2]
	DMX512RD01_ConfigStartSlotNo(1);

	if (DMXControl == 1 && DMX_8 == 1)
	{
		Lamphandle.Intensity_Red = DMX512RD01_buffer[dmx_RedH]<<4;				// 8-bit information in Slot 1
		Lamphandle.Intensity_Green = DMX512RD01_buffer[dmx_GreenH]<<4;			// 8-bit information in Slot 2
1000134c:	604c      	str	r4, [r1, #4]
		Lamphandle.Intensity_Blue = DMX512RD01_buffer[dmx_BlueH]<<4;			// 8-bit information in Slot 3
1000134e:	0114      	lsls	r4, r2, #4
10001350:	e021      	b.n	10001396 <DMX512RD01_CallBack+0x7e>
		COLORLAMP01_SetColor(&COLORLAMP01_ConfigHandle0, &Lamphandle);	// set LED channel intensities
	}

	else if (DMXControl == 1 && DMX_16 == 1)
10001352:	6819      	ldr	r1, [r3, #0]
10001354:	2901      	cmp	r1, #1
10001356:	d122      	bne.n	1000139e <DMX512RD01_CallBack+0x86>
	{
		Lamphandle.Intensity_Red = (DMX512RD01_buffer[dmx_RedH]<<4) + (DMX512RD01_buffer[dmx_RedL]>>4);			// 8-bit information in Slot 1
10001358:	895c      	ldrh	r4, [r3, #10]
1000135a:	4a13      	ldr	r2, [pc, #76]	; (100013a8 <DMX512RD01_CallBack+0x90>)
1000135c:	00a0      	lsls	r0, r4, #2
1000135e:	5884      	ldr	r4, [r0, r2]
10001360:	8898      	ldrh	r0, [r3, #4]
10001362:	0924      	lsrs	r4, r4, #4
10001364:	0080      	lsls	r0, r0, #2
10001366:	5880      	ldr	r0, [r0, r2]
10001368:	4910      	ldr	r1, [pc, #64]	; (100013ac <DMX512RD01_CallBack+0x94>)
1000136a:	0100      	lsls	r0, r0, #4
1000136c:	1824      	adds	r4, r4, r0
		Lamphandle.Intensity_Green = (DMX512RD01_buffer[dmx_GreenH]<<4) + (DMX512RD01_buffer[dmx_GreenL]>>4);			// 8-bit information in Slot 2
1000136e:	8998      	ldrh	r0, [r3, #12]
		COLORLAMP01_SetColor(&COLORLAMP01_ConfigHandle0, &Lamphandle);	// set LED channel intensities
	}

	else if (DMXControl == 1 && DMX_16 == 1)
	{
		Lamphandle.Intensity_Red = (DMX512RD01_buffer[dmx_RedH]<<4) + (DMX512RD01_buffer[dmx_RedL]>>4);			// 8-bit information in Slot 1
10001370:	600c      	str	r4, [r1, #0]
		Lamphandle.Intensity_Green = (DMX512RD01_buffer[dmx_GreenH]<<4) + (DMX512RD01_buffer[dmx_GreenL]>>4);			// 8-bit information in Slot 2
10001372:	0084      	lsls	r4, r0, #2
10001374:	58a0      	ldr	r0, [r4, r2]
10001376:	0904      	lsrs	r4, r0, #4
10001378:	88d8      	ldrh	r0, [r3, #6]
1000137a:	0080      	lsls	r0, r0, #2
1000137c:	5880      	ldr	r0, [r0, r2]
1000137e:	0100      	lsls	r0, r0, #4
10001380:	1824      	adds	r4, r4, r0
		Lamphandle.Intensity_Blue = (DMX512RD01_buffer[dmx_BlueH]<<4) + (DMX512RD01_buffer[dmx_BlueL]>>4);			// 8-bit information in Slot 3
10001382:	89d8      	ldrh	r0, [r3, #14]
	}

	else if (DMXControl == 1 && DMX_16 == 1)
	{
		Lamphandle.Intensity_Red = (DMX512RD01_buffer[dmx_RedH]<<4) + (DMX512RD01_buffer[dmx_RedL]>>4);			// 8-bit information in Slot 1
		Lamphandle.Intensity_Green = (DMX512RD01_buffer[dmx_GreenH]<<4) + (DMX512RD01_buffer[dmx_GreenL]>>4);			// 8-bit information in Slot 2
10001384:	604c      	str	r4, [r1, #4]
		Lamphandle.Intensity_Blue = (DMX512RD01_buffer[dmx_BlueH]<<4) + (DMX512RD01_buffer[dmx_BlueL]>>4);			// 8-bit information in Slot 3
10001386:	0084      	lsls	r4, r0, #2
10001388:	58a0      	ldr	r0, [r4, r2]
1000138a:	891b      	ldrh	r3, [r3, #8]
1000138c:	0904      	lsrs	r4, r0, #4
1000138e:	0098      	lsls	r0, r3, #2
10001390:	5882      	ldr	r2, [r0, r2]
10001392:	0113      	lsls	r3, r2, #4
10001394:	18e4      	adds	r4, r4, r3

		COLORLAMP01_SetColor(&COLORLAMP01_ConfigHandle0, &Lamphandle);	// set LED channel intensities
10001396:	4806      	ldr	r0, [pc, #24]	; (100013b0 <DMX512RD01_CallBack+0x98>)

	else if (DMXControl == 1 && DMX_16 == 1)
	{
		Lamphandle.Intensity_Red = (DMX512RD01_buffer[dmx_RedH]<<4) + (DMX512RD01_buffer[dmx_RedL]>>4);			// 8-bit information in Slot 1
		Lamphandle.Intensity_Green = (DMX512RD01_buffer[dmx_GreenH]<<4) + (DMX512RD01_buffer[dmx_GreenL]>>4);			// 8-bit information in Slot 2
		Lamphandle.Intensity_Blue = (DMX512RD01_buffer[dmx_BlueH]<<4) + (DMX512RD01_buffer[dmx_BlueL]>>4);			// 8-bit information in Slot 3
10001398:	608c      	str	r4, [r1, #8]

		COLORLAMP01_SetColor(&COLORLAMP01_ConfigHandle0, &Lamphandle);	// set LED channel intensities
1000139a:	f001 fdba 	bl	10002f12 <COLORLAMP01_SetColor>
	}


	else
	{}
}
1000139e:	bd10      	pop	{r4, pc}
100013a0:	20000630 	.word	0x20000630
100013a4:	20000540 	.word	0x20000540
100013a8:	20000614 	.word	0x20000614
100013ac:	2000058c 	.word	0x2000058c
100013b0:	100044a8 	.word	0x100044a8

100013b4 <USIC0_1_IRQHandler>:
 **                   global variable DataReceived and DataTotal. The function **
 **                   checks the received data against the defined command     **
 **                   words                                                    **
 *******************************************************************************/
void FIFO_Receive_Int_Handler(void)
{
100013b4:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint8_t DataReceived = 0x00;
	I2C003_ClearFlag(&I2C003_Handle0, I2C003_FLAG_RIF);
100013b6:	4cc5      	ldr	r4, [pc, #788]	; (100016cc <USIC0_1_IRQHandler+0x318>)
 **                   global variable DataReceived and DataTotal. The function **
 **                   checks the received data against the defined command     **
 **                   words                                                    **
 *******************************************************************************/
void FIFO_Receive_Int_Handler(void)
{
100013b8:	b085      	sub	sp, #20
	uint8_t DataReceived = 0x00;
100013ba:	466e      	mov	r6, sp
100013bc:	2300      	movs	r3, #0
	I2C003_ClearFlag(&I2C003_Handle0, I2C003_FLAG_RIF);
100013be:	1c20      	adds	r0, r4, #0
 **                   checks the received data against the defined command     **
 **                   words                                                    **
 *******************************************************************************/
void FIFO_Receive_Int_Handler(void)
{
	uint8_t DataReceived = 0x00;
100013c0:	360f      	adds	r6, #15
	I2C003_ClearFlag(&I2C003_Handle0, I2C003_FLAG_RIF);
100013c2:	2104      	movs	r1, #4
 **                   checks the received data against the defined command     **
 **                   words                                                    **
 *******************************************************************************/
void FIFO_Receive_Int_Handler(void)
{
	uint8_t DataReceived = 0x00;
100013c4:	7033      	strb	r3, [r6, #0]
	I2C003_ClearFlag(&I2C003_Handle0, I2C003_FLAG_RIF);
100013c6:	f001 fab6 	bl	10002936 <I2C003_ClearFlag>
	I2C003_Handle0.I2CRegs->TRBSCR |= USIC_CH_TRBSCR_CSRBI_Msk;
100013ca:	6825      	ldr	r5, [r4, #0]
100013cc:	2701      	movs	r7, #1
100013ce:	1c28      	adds	r0, r5, #0
100013d0:	30fc      	adds	r0, #252	; 0xfc
100013d2:	69c2      	ldr	r2, [r0, #28]
	I2C003_ReadData(&I2C003_Handle0,&DataReceived);  // Read receive FIFO buffer, put the data in DataReceive1
100013d4:	1c31      	adds	r1, r6, #0
 *******************************************************************************/
void FIFO_Receive_Int_Handler(void)
{
	uint8_t DataReceived = 0x00;
	I2C003_ClearFlag(&I2C003_Handle0, I2C003_FLAG_RIF);
	I2C003_Handle0.I2CRegs->TRBSCR |= USIC_CH_TRBSCR_CSRBI_Msk;
100013d6:	433a      	orrs	r2, r7
100013d8:	61c2      	str	r2, [r0, #28]
	I2C003_ReadData(&I2C003_Handle0,&DataReceived);  // Read receive FIFO buffer, put the data in DataReceive1
100013da:	1c20      	adds	r0, r4, #0
100013dc:	f001 fa9b 	bl	10002916 <I2C003_ReadData>

	if (byteCount == 0) // Taking in Command
100013e0:	4cbb      	ldr	r4, [pc, #748]	; (100016d0 <USIC0_1_IRQHandler+0x31c>)
100013e2:	6823      	ldr	r3, [r4, #0]
100013e4:	2b00      	cmp	r3, #0
100013e6:	d122      	bne.n	1000142e <USIC0_1_IRQHandler+0x7a>
	{
		Command = (DataReceived & 0x00FF);
100013e8:	7832      	ldrb	r2, [r6, #0]
100013ea:	49ba      	ldr	r1, [pc, #744]	; (100016d4 <USIC0_1_IRQHandler+0x320>)
		DataUpper = 0x00;
100013ec:	4eba      	ldr	r6, [pc, #744]	; (100016d8 <USIC0_1_IRQHandler+0x324>)
		DataLower = 0x00;
100013ee:	48bb      	ldr	r0, [pc, #748]	; (100016dc <USIC0_1_IRQHandler+0x328>)
	I2C003_Handle0.I2CRegs->TRBSCR |= USIC_CH_TRBSCR_CSRBI_Msk;
	I2C003_ReadData(&I2C003_Handle0,&DataReceived);  // Read receive FIFO buffer, put the data in DataReceive1

	if (byteCount == 0) // Taking in Command
	{
		Command = (DataReceived & 0x00FF);
100013f0:	700a      	strb	r2, [r1, #0]
		DataUpper = 0x00;
100013f2:	7033      	strb	r3, [r6, #0]
		DataLower = 0x00;
100013f4:	7003      	strb	r3, [r0, #0]
		byteCount++;
100013f6:	6027      	str	r7, [r4, #0]

		if (Command == DMX0FF) // If DMXOFF sent, off the DMX control
100013f8:	2a30      	cmp	r2, #48	; 0x30
100013fa:	d105      	bne.n	10001408 <USIC0_1_IRQHandler+0x54>
		{
			DMXControl = 0;
100013fc:	4fb8      	ldr	r7, [pc, #736]	; (100016e0 <USIC0_1_IRQHandler+0x32c>)
			byteCount = 0;
			flashBuffer[7] = 0; // writing to buffer maintaining flash parameters
100013fe:	49b9      	ldr	r1, [pc, #740]	; (100016e4 <USIC0_1_IRQHandler+0x330>)
		DataLower = 0x00;
		byteCount++;

		if (Command == DMX0FF) // If DMXOFF sent, off the DMX control
		{
			DMXControl = 0;
10001400:	603b      	str	r3, [r7, #0]
			byteCount = 0;
10001402:	6023      	str	r3, [r4, #0]
			flashBuffer[7] = 0; // writing to buffer maintaining flash parameters
10001404:	61cb      	str	r3, [r1, #28]
10001406:	e039      	b.n	1000147c <USIC0_1_IRQHandler+0xc8>
		}

		else if (Command == DMXON)
10001408:	2a31      	cmp	r2, #49	; 0x31
1000140a:	d105      	bne.n	10001418 <USIC0_1_IRQHandler+0x64>
		{
			DMXControl = 1;
1000140c:	4ab4      	ldr	r2, [pc, #720]	; (100016e0 <USIC0_1_IRQHandler+0x32c>)
			byteCount = 0;
			flashBuffer[7] = 1;
1000140e:	48b5      	ldr	r0, [pc, #724]	; (100016e4 <USIC0_1_IRQHandler+0x330>)
			flashBuffer[7] = 0; // writing to buffer maintaining flash parameters
		}

		else if (Command == DMXON)
		{
			DMXControl = 1;
10001410:	6017      	str	r7, [r2, #0]
			byteCount = 0;
10001412:	6023      	str	r3, [r4, #0]
			flashBuffer[7] = 1;
10001414:	61c7      	str	r7, [r0, #28]
10001416:	e031      	b.n	1000147c <USIC0_1_IRQHandler+0xc8>
		}

		else if (Command == 0x80 || Command == 0x81 || Command == 0x82 || Command == 0x83 || Command == 0x84 || Command == 0x85 || Command == 0x86 || Command == 0x87 || Command == 0x88 || Command == 0x89 || Command == 0x8A || Command == 0x8B || Command == 0x8C || Command == 0x8D || Command == 0x8E || Command == 0x8F)
10001418:	1c11      	adds	r1, r2, #0
1000141a:	3980      	subs	r1, #128	; 0x80
1000141c:	b2ce      	uxtb	r6, r1
1000141e:	2e0f      	cmp	r6, #15
10001420:	d92b      	bls.n	1000147a <USIC0_1_IRQHandler+0xc6>
			// 0x77: Walktime
			// 0x78: Dimming
			// 0x79: Fade Rate
		}

		else if (Command == SAVEPARAMETERS)
10001422:	2aa0      	cmp	r2, #160	; 0xa0
10001424:	d12a      	bne.n	1000147c <USIC0_1_IRQHandler+0xc8>
		{
			byteCount = 0;
10001426:	6023      	str	r3, [r4, #0]
			writeToFlash = 1;
10001428:	4baf      	ldr	r3, [pc, #700]	; (100016e8 <USIC0_1_IRQHandler+0x334>)
1000142a:	601f      	str	r7, [r3, #0]
1000142c:	e026      	b.n	1000147c <USIC0_1_IRQHandler+0xc8>
		}

	}

	else if (byteCount == 1 || byteCount == 3 || byteCount == 5 || byteCount == 7 || byteCount == 9 || byteCount == 11) // every odd byte is lower 8 bits
1000142e:	2b01      	cmp	r3, #1
10001430:	d009      	beq.n	10001446 <USIC0_1_IRQHandler+0x92>
10001432:	2b03      	cmp	r3, #3
10001434:	d007      	beq.n	10001446 <USIC0_1_IRQHandler+0x92>
10001436:	2b05      	cmp	r3, #5
10001438:	d005      	beq.n	10001446 <USIC0_1_IRQHandler+0x92>
1000143a:	2b07      	cmp	r3, #7
1000143c:	d003      	beq.n	10001446 <USIC0_1_IRQHandler+0x92>
1000143e:	2b09      	cmp	r3, #9
10001440:	d001      	beq.n	10001446 <USIC0_1_IRQHandler+0x92>
10001442:	2b0b      	cmp	r3, #11
10001444:	d103      	bne.n	1000144e <USIC0_1_IRQHandler+0x9a>
	{
		DataUpper = (DataReceived & 0x00FF);
10001446:	7836      	ldrb	r6, [r6, #0]
10001448:	48a3      	ldr	r0, [pc, #652]	; (100016d8 <USIC0_1_IRQHandler+0x324>)
1000144a:	7006      	strb	r6, [r0, #0]
1000144c:	e014      	b.n	10001478 <USIC0_1_IRQHandler+0xc4>
		byteCount++;

	}
	else if (byteCount == 2 || byteCount == 4 || byteCount == 6 || byteCount == 8 || byteCount == 10 || byteCount == 12)
1000144e:	2b02      	cmp	r3, #2
10001450:	d009      	beq.n	10001466 <USIC0_1_IRQHandler+0xb2>
10001452:	2b04      	cmp	r3, #4
10001454:	d007      	beq.n	10001466 <USIC0_1_IRQHandler+0xb2>
10001456:	2b06      	cmp	r3, #6
10001458:	d005      	beq.n	10001466 <USIC0_1_IRQHandler+0xb2>
1000145a:	2b08      	cmp	r3, #8
1000145c:	d003      	beq.n	10001466 <USIC0_1_IRQHandler+0xb2>
1000145e:	2b0a      	cmp	r3, #10
10001460:	d001      	beq.n	10001466 <USIC0_1_IRQHandler+0xb2>
10001462:	2b0c      	cmp	r3, #12
10001464:	d10a      	bne.n	1000147c <USIC0_1_IRQHandler+0xc8>
	{
		DataLower = (DataReceived & 0x00FF);
		DataTotal = (uint16_t) (DataUpper << 8 ) | DataLower; // upper 8 bits, shift left by 8 bits
10001466:	489c      	ldr	r0, [pc, #624]	; (100016d8 <USIC0_1_IRQHandler+0x324>)
		byteCount++;

	}
	else if (byteCount == 2 || byteCount == 4 || byteCount == 6 || byteCount == 8 || byteCount == 10 || byteCount == 12)
	{
		DataLower = (DataReceived & 0x00FF);
10001468:	7836      	ldrb	r6, [r6, #0]
1000146a:	499c      	ldr	r1, [pc, #624]	; (100016dc <USIC0_1_IRQHandler+0x328>)
		DataTotal = (uint16_t) (DataUpper << 8 ) | DataLower; // upper 8 bits, shift left by 8 bits
1000146c:	7802      	ldrb	r2, [r0, #0]
		byteCount++;

	}
	else if (byteCount == 2 || byteCount == 4 || byteCount == 6 || byteCount == 8 || byteCount == 10 || byteCount == 12)
	{
		DataLower = (DataReceived & 0x00FF);
1000146e:	700e      	strb	r6, [r1, #0]
		DataTotal = (uint16_t) (DataUpper << 8 ) | DataLower; // upper 8 bits, shift left by 8 bits
10001470:	0217      	lsls	r7, r2, #8
10001472:	499e      	ldr	r1, [pc, #632]	; (100016ec <USIC0_1_IRQHandler+0x338>)
10001474:	433e      	orrs	r6, r7
10001476:	800e      	strh	r6, [r1, #0]
		byteCount ++;
10001478:	3301      	adds	r3, #1
1000147a:	6023      	str	r3, [r4, #0]

	}

	if (byteCount == 3) // Commands here come with 2 more bytes of data
1000147c:	6826      	ldr	r6, [r4, #0]
1000147e:	2e03      	cmp	r6, #3
10001480:	d000      	beq.n	10001484 <USIC0_1_IRQHandler+0xd0>
10001482:	e1e3      	b.n	1000184c <USIC0_1_IRQHandler+0x498>
	{
		if(Command == INTENSITY_RED) // Red Command: Change red color intensity of lamp
10001484:	4a93      	ldr	r2, [pc, #588]	; (100016d4 <USIC0_1_IRQHandler+0x320>)
10001486:	7810      	ldrb	r0, [r2, #0]
10001488:	2811      	cmp	r0, #17
1000148a:	d119      	bne.n	100014c0 <USIC0_1_IRQHandler+0x10c>
		{
			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle0, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle0.ChNum)); // end any previous walks. BCCU channel for red colour intensity
1000148c:	4d98      	ldr	r5, [pc, #608]	; (100016f0 <USIC0_1_IRQHandler+0x33c>)
1000148e:	2701      	movs	r7, #1
10001490:	68aa      	ldr	r2, [r5, #8]
10001492:	1c28      	adds	r0, r5, #0
10001494:	4097      	lsls	r7, r2
10001496:	1c39      	adds	r1, r7, #0
10001498:	f001 ff33 	bl	10003302 <BCCUCH01_AbortLinearWalk>
			DataTotal &= 0x0FFF;
1000149c:	4e93      	ldr	r6, [pc, #588]	; (100016ec <USIC0_1_IRQHandler+0x338>)
1000149e:	8831      	ldrh	r1, [r6, #0]
100014a0:	0508      	lsls	r0, r1, #20
100014a2:	0d01      	lsrs	r1, r0, #20
			BCCUCH01_SetIntensity(&BCCUCH01_Handle0, DataTotal);
100014a4:	1c28      	adds	r0, r5, #0
	if (byteCount == 3) // Commands here come with 2 more bytes of data
	{
		if(Command == INTENSITY_RED) // Red Command: Change red color intensity of lamp
		{
			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle0, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle0.ChNum)); // end any previous walks. BCCU channel for red colour intensity
			DataTotal &= 0x0FFF;
100014a6:	8031      	strh	r1, [r6, #0]
			BCCUCH01_SetIntensity(&BCCUCH01_Handle0, DataTotal);
100014a8:	f001 ff31 	bl	1000330e <BCCUCH01_SetIntensity>
			BCCUCH01_StartLinearWalk(&BCCUCH01_Handle0, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle0.ChNum)); // start changing target intensity
100014ac:	1c28      	adds	r0, r5, #0
100014ae:	1c39      	adds	r1, r7, #0
100014b0:	f001 ff22 	bl	100032f8 <BCCUCH01_StartLinearWalk>
			byteCount = 0;
100014b4:	2300      	movs	r3, #0
100014b6:	6023      	str	r3, [r4, #0]

			flashBuffer[1] = DataTotal; // store into flash buffer
100014b8:	4d8a      	ldr	r5, [pc, #552]	; (100016e4 <USIC0_1_IRQHandler+0x330>)
100014ba:	8834      	ldrh	r4, [r6, #0]
100014bc:	606c      	str	r4, [r5, #4]
100014be:	e299      	b.n	100019f4 <USIC0_1_IRQHandler+0x640>
		}

		else if (Command == INTENSITY_GREEN) // Green Command: Change green color intensity of lamp
100014c0:	2812      	cmp	r0, #18
100014c2:	d119      	bne.n	100014f8 <USIC0_1_IRQHandler+0x144>
		{
			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle1, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle1.ChNum)); //BCCU channel for green colour intensity
100014c4:	4d8b      	ldr	r5, [pc, #556]	; (100016f4 <USIC0_1_IRQHandler+0x340>)
100014c6:	2701      	movs	r7, #1
100014c8:	68aa      	ldr	r2, [r5, #8]
100014ca:	1c28      	adds	r0, r5, #0
100014cc:	4097      	lsls	r7, r2
100014ce:	1c39      	adds	r1, r7, #0
100014d0:	f001 ff17 	bl	10003302 <BCCUCH01_AbortLinearWalk>
			DataTotal &= 0x0FFF;
100014d4:	4e85      	ldr	r6, [pc, #532]	; (100016ec <USIC0_1_IRQHandler+0x338>)
100014d6:	8831      	ldrh	r1, [r6, #0]
100014d8:	0508      	lsls	r0, r1, #20
100014da:	0d01      	lsrs	r1, r0, #20
			BCCUCH01_SetIntensity(&BCCUCH01_Handle1, DataTotal);
100014dc:	1c28      	adds	r0, r5, #0
		}

		else if (Command == INTENSITY_GREEN) // Green Command: Change green color intensity of lamp
		{
			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle1, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle1.ChNum)); //BCCU channel for green colour intensity
			DataTotal &= 0x0FFF;
100014de:	8031      	strh	r1, [r6, #0]
			BCCUCH01_SetIntensity(&BCCUCH01_Handle1, DataTotal);
100014e0:	f001 ff15 	bl	1000330e <BCCUCH01_SetIntensity>
			BCCUCH01_StartLinearWalk(&BCCUCH01_Handle1, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle1.ChNum));
100014e4:	1c28      	adds	r0, r5, #0
100014e6:	1c39      	adds	r1, r7, #0
100014e8:	f001 ff06 	bl	100032f8 <BCCUCH01_StartLinearWalk>
			byteCount = 0;
100014ec:	2300      	movs	r3, #0
100014ee:	6023      	str	r3, [r4, #0]

			flashBuffer[2] = DataTotal;
100014f0:	4d7c      	ldr	r5, [pc, #496]	; (100016e4 <USIC0_1_IRQHandler+0x330>)
100014f2:	8834      	ldrh	r4, [r6, #0]
100014f4:	60ac      	str	r4, [r5, #8]
100014f6:	e27d      	b.n	100019f4 <USIC0_1_IRQHandler+0x640>
		}


		else if (Command == INTENSITY_BLUE) // Blue Command: Change blue color intensity of lamp
100014f8:	2813      	cmp	r0, #19
100014fa:	d117      	bne.n	1000152c <USIC0_1_IRQHandler+0x178>
		{
			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle2, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle2.ChNum)); // BCCU channel for blue colour intensity
100014fc:	4d7e      	ldr	r5, [pc, #504]	; (100016f8 <USIC0_1_IRQHandler+0x344>)
100014fe:	2701      	movs	r7, #1
10001500:	68aa      	ldr	r2, [r5, #8]
10001502:	1c28      	adds	r0, r5, #0
10001504:	4097      	lsls	r7, r2
10001506:	1c39      	adds	r1, r7, #0
10001508:	f001 fefb 	bl	10003302 <BCCUCH01_AbortLinearWalk>
			DataTotal &= 0x0FFF;
1000150c:	4e77      	ldr	r6, [pc, #476]	; (100016ec <USIC0_1_IRQHandler+0x338>)
1000150e:	8831      	ldrh	r1, [r6, #0]
10001510:	0508      	lsls	r0, r1, #20
10001512:	0d01      	lsrs	r1, r0, #20
			BCCUCH01_SetIntensity(&BCCUCH01_Handle2, DataTotal);
10001514:	1c28      	adds	r0, r5, #0


		else if (Command == INTENSITY_BLUE) // Blue Command: Change blue color intensity of lamp
		{
			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle2, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle2.ChNum)); // BCCU channel for blue colour intensity
			DataTotal &= 0x0FFF;
10001516:	8031      	strh	r1, [r6, #0]
			BCCUCH01_SetIntensity(&BCCUCH01_Handle2, DataTotal);
10001518:	f001 fef9 	bl	1000330e <BCCUCH01_SetIntensity>
			BCCUCH01_StartLinearWalk(&BCCUCH01_Handle2, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle2.ChNum));
1000151c:	1c28      	adds	r0, r5, #0
1000151e:	1c39      	adds	r1, r7, #0
10001520:	f001 feea 	bl	100032f8 <BCCUCH01_StartLinearWalk>
			byteCount = 0;
10001524:	2300      	movs	r3, #0
10001526:	6023      	str	r3, [r4, #0]

			flashBuffer[3] = DataTotal;
10001528:	8832      	ldrh	r2, [r6, #0]
1000152a:	e1d5      	b.n	100018d8 <USIC0_1_IRQHandler+0x524>
		}

		else if (Command == INTENSITY_RGB) // RGB Command: Change color intensity of red, green and blue channels
1000152c:	2814      	cmp	r0, #20
1000152e:	d11c      	bne.n	1000156a <USIC0_1_IRQHandler+0x1b6>
		{
			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle0, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle0.ChNum));
10001530:	486f      	ldr	r0, [pc, #444]	; (100016f0 <USIC0_1_IRQHandler+0x33c>)
10001532:	2601      	movs	r6, #1
10001534:	6883      	ldr	r3, [r0, #8]
10001536:	1c31      	adds	r1, r6, #0
10001538:	4099      	lsls	r1, r3
1000153a:	f001 fee2 	bl	10003302 <BCCUCH01_AbortLinearWalk>
			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle1, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle1.ChNum));
1000153e:	486d      	ldr	r0, [pc, #436]	; (100016f4 <USIC0_1_IRQHandler+0x340>)
10001540:	1c31      	adds	r1, r6, #0
10001542:	6887      	ldr	r7, [r0, #8]
10001544:	40b9      	lsls	r1, r7
10001546:	f001 fedc 	bl	10003302 <BCCUCH01_AbortLinearWalk>
			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle2, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle2.ChNum));
1000154a:	486b      	ldr	r0, [pc, #428]	; (100016f8 <USIC0_1_IRQHandler+0x344>)
1000154c:	1c31      	adds	r1, r6, #0
1000154e:	6882      	ldr	r2, [r0, #8]
10001550:	4091      	lsls	r1, r2
10001552:	f001 fed6 	bl	10003302 <BCCUCH01_AbortLinearWalk>
			DataTotal &= 0x0FFF;
10001556:	4965      	ldr	r1, [pc, #404]	; (100016ec <USIC0_1_IRQHandler+0x338>)
			Lamphandle.Intensity_Red = DataTotal;
10001558:	4b68      	ldr	r3, [pc, #416]	; (100016fc <USIC0_1_IRQHandler+0x348>)
		else if (Command == INTENSITY_RGB) // RGB Command: Change color intensity of red, green and blue channels
		{
			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle0, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle0.ChNum));
			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle1, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle1.ChNum));
			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle2, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle2.ChNum));
			DataTotal &= 0x0FFF;
1000155a:	8808      	ldrh	r0, [r1, #0]
			Lamphandle.Intensity_Red = DataTotal;

			flashBuffer[1] = DataTotal;
1000155c:	4f61      	ldr	r7, [pc, #388]	; (100016e4 <USIC0_1_IRQHandler+0x330>)
		else if (Command == INTENSITY_RGB) // RGB Command: Change color intensity of red, green and blue channels
		{
			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle0, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle0.ChNum));
			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle1, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle1.ChNum));
			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle2, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle2.ChNum));
			DataTotal &= 0x0FFF;
1000155e:	0504      	lsls	r4, r0, #20
10001560:	0d26      	lsrs	r6, r4, #20
10001562:	800e      	strh	r6, [r1, #0]
			Lamphandle.Intensity_Red = DataTotal;
10001564:	601e      	str	r6, [r3, #0]

			flashBuffer[1] = DataTotal;
10001566:	607e      	str	r6, [r7, #4]
10001568:	e244      	b.n	100019f4 <USIC0_1_IRQHandler+0x640>
		}

		else if (Command == CURRENT_RED) // Red Current Command: Change peak current reference of red channel
1000156a:	2821      	cmp	r0, #33	; 0x21
1000156c:	d11a      	bne.n	100015a4 <USIC0_1_IRQHandler+0x1f0>
		{
			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle3, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle3.ChNum)); // BCCU channel for red peak current
1000156e:	4e64      	ldr	r6, [pc, #400]	; (10001700 <USIC0_1_IRQHandler+0x34c>)
10001570:	2701      	movs	r7, #1
10001572:	68b3      	ldr	r3, [r6, #8]
10001574:	1c30      	adds	r0, r6, #0
10001576:	409f      	lsls	r7, r3
10001578:	1c39      	adds	r1, r7, #0
1000157a:	f001 fec2 	bl	10003302 <BCCUCH01_AbortLinearWalk>
			if (DataTotal > 0x80) // To ensure current does not exceed limit
1000157e:	4d5b      	ldr	r5, [pc, #364]	; (100016ec <USIC0_1_IRQHandler+0x338>)
10001580:	8829      	ldrh	r1, [r5, #0]
10001582:	2980      	cmp	r1, #128	; 0x80
10001584:	d901      	bls.n	1000158a <USIC0_1_IRQHandler+0x1d6>
				DataTotal = 0x80;
10001586:	2280      	movs	r2, #128	; 0x80
10001588:	802a      	strh	r2, [r5, #0]
			DataTotal &= 0x00FF;
1000158a:	7829      	ldrb	r1, [r5, #0]
			BCCUCH01_SetIntensity(&BCCUCH01_Handle3, DataTotal);
1000158c:	1c30      	adds	r0, r6, #0
		else if (Command == CURRENT_RED) // Red Current Command: Change peak current reference of red channel
		{
			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle3, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle3.ChNum)); // BCCU channel for red peak current
			if (DataTotal > 0x80) // To ensure current does not exceed limit
				DataTotal = 0x80;
			DataTotal &= 0x00FF;
1000158e:	8029      	strh	r1, [r5, #0]
			BCCUCH01_SetIntensity(&BCCUCH01_Handle3, DataTotal);
10001590:	f001 febd 	bl	1000330e <BCCUCH01_SetIntensity>
			BCCUCH01_StartLinearWalk(&BCCUCH01_Handle3, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle3.ChNum)); // Setting the new peak current reference
10001594:	1c30      	adds	r0, r6, #0
10001596:	1c39      	adds	r1, r7, #0
10001598:	f001 feae 	bl	100032f8 <BCCUCH01_StartLinearWalk>
			byteCount = 0;
1000159c:	2000      	movs	r0, #0
1000159e:	6020      	str	r0, [r4, #0]

			flashBuffer[4] = DataTotal;
100015a0:	8828      	ldrh	r0, [r5, #0]
100015a2:	e05c      	b.n	1000165e <USIC0_1_IRQHandler+0x2aa>

		}

		else if (Command == CURRENT_GREEN) // Green Current Command: Change peak current reference of green channel
100015a4:	2822      	cmp	r0, #34	; 0x22
100015a6:	d11a      	bne.n	100015de <USIC0_1_IRQHandler+0x22a>
		{
			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle4, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle4.ChNum)); // BCCU channel for red peak current
100015a8:	4e56      	ldr	r6, [pc, #344]	; (10001704 <USIC0_1_IRQHandler+0x350>)
100015aa:	2701      	movs	r7, #1
100015ac:	68b3      	ldr	r3, [r6, #8]
100015ae:	1c30      	adds	r0, r6, #0
100015b0:	409f      	lsls	r7, r3
100015b2:	1c39      	adds	r1, r7, #0
100015b4:	f001 fea5 	bl	10003302 <BCCUCH01_AbortLinearWalk>
			if (DataTotal > 0x80)
100015b8:	4d4c      	ldr	r5, [pc, #304]	; (100016ec <USIC0_1_IRQHandler+0x338>)
100015ba:	8829      	ldrh	r1, [r5, #0]
100015bc:	2980      	cmp	r1, #128	; 0x80
100015be:	d901      	bls.n	100015c4 <USIC0_1_IRQHandler+0x210>
				DataTotal = 0x80;
100015c0:	2280      	movs	r2, #128	; 0x80
100015c2:	802a      	strh	r2, [r5, #0]
			DataTotal &= 0x00FF;
100015c4:	7829      	ldrb	r1, [r5, #0]
			BCCUCH01_SetIntensity(&BCCUCH01_Handle4, DataTotal);
100015c6:	1c30      	adds	r0, r6, #0
		else if (Command == CURRENT_GREEN) // Green Current Command: Change peak current reference of green channel
		{
			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle4, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle4.ChNum)); // BCCU channel for red peak current
			if (DataTotal > 0x80)
				DataTotal = 0x80;
			DataTotal &= 0x00FF;
100015c8:	8029      	strh	r1, [r5, #0]
			BCCUCH01_SetIntensity(&BCCUCH01_Handle4, DataTotal);
100015ca:	f001 fea0 	bl	1000330e <BCCUCH01_SetIntensity>
			BCCUCH01_StartLinearWalk(&BCCUCH01_Handle4, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle4.ChNum));
100015ce:	1c30      	adds	r0, r6, #0
100015d0:	1c39      	adds	r1, r7, #0
100015d2:	f001 fe91 	bl	100032f8 <BCCUCH01_StartLinearWalk>
			byteCount = 0;
100015d6:	2000      	movs	r0, #0
100015d8:	6020      	str	r0, [r4, #0]

			flashBuffer[5] = DataTotal;
100015da:	882a      	ldrh	r2, [r5, #0]
100015dc:	e14f      	b.n	1000187e <USIC0_1_IRQHandler+0x4ca>
		}


		else if (Command == CURRENT_BLUE) // Blue Current Command: Change peak current reference of blue channel
100015de:	2823      	cmp	r0, #35	; 0x23
100015e0:	d11a      	bne.n	10001618 <USIC0_1_IRQHandler+0x264>
		{

			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle5, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle5.ChNum)); // BCCU channel for blue peak current
100015e2:	4e49      	ldr	r6, [pc, #292]	; (10001708 <USIC0_1_IRQHandler+0x354>)
100015e4:	2701      	movs	r7, #1
100015e6:	68b3      	ldr	r3, [r6, #8]
100015e8:	1c30      	adds	r0, r6, #0
100015ea:	409f      	lsls	r7, r3
100015ec:	1c39      	adds	r1, r7, #0
100015ee:	f001 fe88 	bl	10003302 <BCCUCH01_AbortLinearWalk>
			if (DataTotal > 0x80)
100015f2:	4d3e      	ldr	r5, [pc, #248]	; (100016ec <USIC0_1_IRQHandler+0x338>)
100015f4:	8829      	ldrh	r1, [r5, #0]
100015f6:	2980      	cmp	r1, #128	; 0x80
100015f8:	d901      	bls.n	100015fe <USIC0_1_IRQHandler+0x24a>
				DataTotal = 0x80;
100015fa:	2280      	movs	r2, #128	; 0x80
100015fc:	802a      	strh	r2, [r5, #0]
			DataTotal &= 0x00FF;
100015fe:	7829      	ldrb	r1, [r5, #0]
			BCCUCH01_SetIntensity(&BCCUCH01_Handle5, DataTotal);
10001600:	1c30      	adds	r0, r6, #0
		{

			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle5, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle5.ChNum)); // BCCU channel for blue peak current
			if (DataTotal > 0x80)
				DataTotal = 0x80;
			DataTotal &= 0x00FF;
10001602:	8029      	strh	r1, [r5, #0]
			BCCUCH01_SetIntensity(&BCCUCH01_Handle5, DataTotal);
10001604:	f001 fe83 	bl	1000330e <BCCUCH01_SetIntensity>
			BCCUCH01_StartLinearWalk(&BCCUCH01_Handle5, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle5.ChNum));
10001608:	1c30      	adds	r0, r6, #0
1000160a:	1c39      	adds	r1, r7, #0
1000160c:	f001 fe74 	bl	100032f8 <BCCUCH01_StartLinearWalk>
			byteCount = 0;
10001610:	2000      	movs	r0, #0
10001612:	6020      	str	r0, [r4, #0]

			flashBuffer[6] = DataTotal;
10001614:	8829      	ldrh	r1, [r5, #0]
10001616:	e17f      	b.n	10001918 <USIC0_1_IRQHandler+0x564>
		}


		else if (Command == CURRENT_RGB) // RGB Current Command: Change peak current reference of red green and blue channels
10001618:	2824      	cmp	r0, #36	; 0x24
1000161a:	d123      	bne.n	10001664 <USIC0_1_IRQHandler+0x2b0>
		{
			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle3, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle3.ChNum));
1000161c:	4e38      	ldr	r6, [pc, #224]	; (10001700 <USIC0_1_IRQHandler+0x34c>)
1000161e:	2701      	movs	r7, #1
10001620:	68b3      	ldr	r3, [r6, #8]
10001622:	1c39      	adds	r1, r7, #0
10001624:	4099      	lsls	r1, r3
10001626:	1c30      	adds	r0, r6, #0
10001628:	f001 fe6b 	bl	10003302 <BCCUCH01_AbortLinearWalk>
			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle4, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle4.ChNum));
1000162c:	4835      	ldr	r0, [pc, #212]	; (10001704 <USIC0_1_IRQHandler+0x350>)
1000162e:	6881      	ldr	r1, [r0, #8]
10001630:	1c0a      	adds	r2, r1, #0
10001632:	1c39      	adds	r1, r7, #0
10001634:	4091      	lsls	r1, r2
10001636:	f001 fe64 	bl	10003302 <BCCUCH01_AbortLinearWalk>
			BCCUCH01_AbortLinearWalk(&BCCUCH01_Handle5, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle5.ChNum));
1000163a:	4833      	ldr	r0, [pc, #204]	; (10001708 <USIC0_1_IRQHandler+0x354>)
1000163c:	1c39      	adds	r1, r7, #0
1000163e:	6885      	ldr	r5, [r0, #8]
10001640:	40a9      	lsls	r1, r5
10001642:	f001 fe5e 	bl	10003302 <BCCUCH01_AbortLinearWalk>
			if (DataTotal > 0x64)
10001646:	4c29      	ldr	r4, [pc, #164]	; (100016ec <USIC0_1_IRQHandler+0x338>)
10001648:	1c30      	adds	r0, r6, #0
1000164a:	8827      	ldrh	r7, [r4, #0]
1000164c:	2f64      	cmp	r7, #100	; 0x64
1000164e:	d901      	bls.n	10001654 <USIC0_1_IRQHandler+0x2a0>
				DataTotal = 0x64;
10001650:	2664      	movs	r6, #100	; 0x64
10001652:	8026      	strh	r6, [r4, #0]
			DataTotal &= 0x00FF;
10001654:	7821      	ldrb	r1, [r4, #0]
10001656:	8021      	strh	r1, [r4, #0]
			BCCUCH01_SetIntensity(&BCCUCH01_Handle3, DataTotal);
10001658:	f001 fe59 	bl	1000330e <BCCUCH01_SetIntensity>
			flashBuffer[4] = DataTotal;
1000165c:	8820      	ldrh	r0, [r4, #0]
1000165e:	4c21      	ldr	r4, [pc, #132]	; (100016e4 <USIC0_1_IRQHandler+0x330>)
10001660:	6120      	str	r0, [r4, #16]
10001662:	e1c7      	b.n	100019f4 <USIC0_1_IRQHandler+0x640>
		}

		else if (Command == CHANGEADDRESS) // Change Address of Slave
10001664:	2870      	cmp	r0, #112	; 0x70
10001666:	d113      	bne.n	10001690 <USIC0_1_IRQHandler+0x2dc>
		{
			I2C003_Handle0.I2CRegs->PCR_IICMode &= 0xFFFF0000; // Clear the address register
10001668:	6be8      	ldr	r0, [r5, #60]	; 0x3c
			changeAddress = (DataUpper << 8) | DataLower; // Put Address into one variable
1000166a:	4f1b      	ldr	r7, [pc, #108]	; (100016d8 <USIC0_1_IRQHandler+0x324>)
			flashBuffer[4] = DataTotal;
		}

		else if (Command == CHANGEADDRESS) // Change Address of Slave
		{
			I2C003_Handle0.I2CRegs->PCR_IICMode &= 0xFFFF0000; // Clear the address register
1000166c:	0c01      	lsrs	r1, r0, #16
			changeAddress = (DataUpper << 8) | DataLower; // Put Address into one variable
1000166e:	481b      	ldr	r0, [pc, #108]	; (100016dc <USIC0_1_IRQHandler+0x328>)
			flashBuffer[4] = DataTotal;
		}

		else if (Command == CHANGEADDRESS) // Change Address of Slave
		{
			I2C003_Handle0.I2CRegs->PCR_IICMode &= 0xFFFF0000; // Clear the address register
10001670:	040a      	lsls	r2, r1, #16
			changeAddress = (DataUpper << 8) | DataLower; // Put Address into one variable
10001672:	783e      	ldrb	r6, [r7, #0]
			flashBuffer[4] = DataTotal;
		}

		else if (Command == CHANGEADDRESS) // Change Address of Slave
		{
			I2C003_Handle0.I2CRegs->PCR_IICMode &= 0xFFFF0000; // Clear the address register
10001674:	63ea      	str	r2, [r5, #60]	; 0x3c
			changeAddress = (DataUpper << 8) | DataLower; // Put Address into one variable
10001676:	7801      	ldrb	r1, [r0, #0]
			changeAddress &= 0x0000FFFF;
			I2C003_Handle0.I2CRegs->PCR_IICMode |= changeAddress; // write into register
10001678:	6bef      	ldr	r7, [r5, #60]	; 0x3c
		}

		else if (Command == CHANGEADDRESS) // Change Address of Slave
		{
			I2C003_Handle0.I2CRegs->PCR_IICMode &= 0xFFFF0000; // Clear the address register
			changeAddress = (DataUpper << 8) | DataLower; // Put Address into one variable
1000167a:	0233      	lsls	r3, r6, #8
			changeAddress &= 0x0000FFFF;
1000167c:	430b      	orrs	r3, r1
			I2C003_Handle0.I2CRegs->PCR_IICMode |= changeAddress; // write into register
1000167e:	431f      	orrs	r7, r3
10001680:	63ef      	str	r7, [r5, #60]	; 0x3c
			byteCount = 0;
10001682:	2500      	movs	r5, #0

		else if (Command == CHANGEADDRESS) // Change Address of Slave
		{
			I2C003_Handle0.I2CRegs->PCR_IICMode &= 0xFFFF0000; // Clear the address register
			changeAddress = (DataUpper << 8) | DataLower; // Put Address into one variable
			changeAddress &= 0x0000FFFF;
10001684:	4a21      	ldr	r2, [pc, #132]	; (1000170c <USIC0_1_IRQHandler+0x358>)
			I2C003_Handle0.I2CRegs->PCR_IICMode |= changeAddress; // write into register
			byteCount = 0;
10001686:	6025      	str	r5, [r4, #0]

			flashBuffer[22] = changeAddress;
10001688:	4c16      	ldr	r4, [pc, #88]	; (100016e4 <USIC0_1_IRQHandler+0x330>)

		else if (Command == CHANGEADDRESS) // Change Address of Slave
		{
			I2C003_Handle0.I2CRegs->PCR_IICMode &= 0xFFFF0000; // Clear the address register
			changeAddress = (DataUpper << 8) | DataLower; // Put Address into one variable
			changeAddress &= 0x0000FFFF;
1000168a:	6013      	str	r3, [r2, #0]
			I2C003_Handle0.I2CRegs->PCR_IICMode |= changeAddress; // write into register
			byteCount = 0;

			flashBuffer[22] = changeAddress;
1000168c:	65a3      	str	r3, [r4, #88]	; 0x58
1000168e:	e1b1      	b.n	100019f4 <USIC0_1_IRQHandler+0x640>
		}

		else if (Command == OFFTIME_RED) // Change off-time of Red channel
10001690:	2841      	cmp	r0, #65	; 0x41
10001692:	d10c      	bne.n	100016ae <USIC0_1_IRQHandler+0x2fa>
		{
			DataTotal &= 0x00FF;
10001694:	4f15      	ldr	r7, [pc, #84]	; (100016ec <USIC0_1_IRQHandler+0x338>)
			PWMSP003_UpdateCompare(&PWMSP003_Handle0, DataTotal, FALSE); // change compare value of pwm of red channel
10001696:	481e      	ldr	r0, [pc, #120]	; (10001710 <USIC0_1_IRQHandler+0x35c>)
			flashBuffer[22] = changeAddress;
		}

		else if (Command == OFFTIME_RED) // Change off-time of Red channel
		{
			DataTotal &= 0x00FF;
10001698:	7839      	ldrb	r1, [r7, #0]
			PWMSP003_UpdateCompare(&PWMSP003_Handle0, DataTotal, FALSE); // change compare value of pwm of red channel
1000169a:	2200      	movs	r2, #0
			byteCount = 0;
1000169c:	2600      	movs	r6, #0
			flashBuffer[22] = changeAddress;
		}

		else if (Command == OFFTIME_RED) // Change off-time of Red channel
		{
			DataTotal &= 0x00FF;
1000169e:	8039      	strh	r1, [r7, #0]
			PWMSP003_UpdateCompare(&PWMSP003_Handle0, DataTotal, FALSE); // change compare value of pwm of red channel
100016a0:	f000 fe90 	bl	100023c4 <PWMSP003_UpdateCompare>
			byteCount = 0;
100016a4:	6026      	str	r6, [r4, #0]

			flashBuffer[16] = DataTotal;
100016a6:	4b0f      	ldr	r3, [pc, #60]	; (100016e4 <USIC0_1_IRQHandler+0x330>)
100016a8:	883c      	ldrh	r4, [r7, #0]
100016aa:	641c      	str	r4, [r3, #64]	; 0x40
100016ac:	e1a2      	b.n	100019f4 <USIC0_1_IRQHandler+0x640>
		}

		else if (Command == OFFTIME_GREEN) // Change off-time of Green channel
100016ae:	2842      	cmp	r0, #66	; 0x42
100016b0:	d132      	bne.n	10001718 <USIC0_1_IRQHandler+0x364>
		{

			DataTotal &= 0x00FF;
100016b2:	4d0e      	ldr	r5, [pc, #56]	; (100016ec <USIC0_1_IRQHandler+0x338>)
			PWMSP003_UpdateCompare(&PWMSP003_Handle1, DataTotal, FALSE); // change compare value of pwm of green channel
100016b4:	2200      	movs	r2, #0
		}

		else if (Command == OFFTIME_GREEN) // Change off-time of Green channel
		{

			DataTotal &= 0x00FF;
100016b6:	7829      	ldrb	r1, [r5, #0]
			PWMSP003_UpdateCompare(&PWMSP003_Handle1, DataTotal, FALSE); // change compare value of pwm of green channel
100016b8:	4816      	ldr	r0, [pc, #88]	; (10001714 <USIC0_1_IRQHandler+0x360>)
		}

		else if (Command == OFFTIME_GREEN) // Change off-time of Green channel
		{

			DataTotal &= 0x00FF;
100016ba:	8029      	strh	r1, [r5, #0]
			PWMSP003_UpdateCompare(&PWMSP003_Handle1, DataTotal, FALSE); // change compare value of pwm of green channel
100016bc:	f000 fe82 	bl	100023c4 <PWMSP003_UpdateCompare>
			byteCount = 0;

			flashBuffer[17] = DataTotal;
100016c0:	8829      	ldrh	r1, [r5, #0]
100016c2:	4a08      	ldr	r2, [pc, #32]	; (100016e4 <USIC0_1_IRQHandler+0x330>)
		else if (Command == OFFTIME_GREEN) // Change off-time of Green channel
		{

			DataTotal &= 0x00FF;
			PWMSP003_UpdateCompare(&PWMSP003_Handle1, DataTotal, FALSE); // change compare value of pwm of green channel
			byteCount = 0;
100016c4:	2000      	movs	r0, #0
100016c6:	6020      	str	r0, [r4, #0]

			flashBuffer[17] = DataTotal;
100016c8:	6451      	str	r1, [r2, #68]	; 0x44
100016ca:	e193      	b.n	100019f4 <USIC0_1_IRQHandler+0x640>
100016cc:	10004460 	.word	0x10004460
100016d0:	20000554 	.word	0x20000554
100016d4:	20000578 	.word	0x20000578
100016d8:	20000577 	.word	0x20000577
100016dc:	20000576 	.word	0x20000576
100016e0:	20000634 	.word	0x20000634
100016e4:	200005a8 	.word	0x200005a8
100016e8:	20000550 	.word	0x20000550
100016ec:	20000574 	.word	0x20000574
100016f0:	100046a8 	.word	0x100046a8
100016f4:	10004654 	.word	0x10004654
100016f8:	10004600 	.word	0x10004600
100016fc:	2000058c 	.word	0x2000058c
10001700:	100045ac 	.word	0x100045ac
10001704:	10004558 	.word	0x10004558
10001708:	10004504 	.word	0x10004504
1000170c:	20000568 	.word	0x20000568
10001710:	10004198 	.word	0x10004198
10001714:	10004130 	.word	0x10004130
		}

		else if (Command == OFFTIME_BLUE) // Change offtime of Blue channel
10001718:	2843      	cmp	r0, #67	; 0x43
1000171a:	d10c      	bne.n	10001736 <USIC0_1_IRQHandler+0x382>
		{

			DataTotal &= 0x00FF;
1000171c:	4db6      	ldr	r5, [pc, #728]	; (100019f8 <USIC0_1_IRQHandler+0x644>)
			PWMSP003_UpdateCompare(&PWMSP003_Handle2, DataTotal, FALSE); // change compare value of pwm of blue channel
1000171e:	48b7      	ldr	r0, [pc, #732]	; (100019fc <USIC0_1_IRQHandler+0x648>)
		}

		else if (Command == OFFTIME_BLUE) // Change offtime of Blue channel
		{

			DataTotal &= 0x00FF;
10001720:	7829      	ldrb	r1, [r5, #0]
			PWMSP003_UpdateCompare(&PWMSP003_Handle2, DataTotal, FALSE); // change compare value of pwm of blue channel
10001722:	2200      	movs	r2, #0
		}

		else if (Command == OFFTIME_BLUE) // Change offtime of Blue channel
		{

			DataTotal &= 0x00FF;
10001724:	8029      	strh	r1, [r5, #0]
			PWMSP003_UpdateCompare(&PWMSP003_Handle2, DataTotal, FALSE); // change compare value of pwm of blue channel
10001726:	f000 fe4d 	bl	100023c4 <PWMSP003_UpdateCompare>
			byteCount = 0;

			flashBuffer[18] = DataTotal;
1000172a:	882e      	ldrh	r6, [r5, #0]
1000172c:	4bb4      	ldr	r3, [pc, #720]	; (10001a00 <USIC0_1_IRQHandler+0x64c>)
		else if (Command == OFFTIME_BLUE) // Change offtime of Blue channel
		{

			DataTotal &= 0x00FF;
			PWMSP003_UpdateCompare(&PWMSP003_Handle2, DataTotal, FALSE); // change compare value of pwm of blue channel
			byteCount = 0;
1000172e:	2700      	movs	r7, #0
10001730:	6027      	str	r7, [r4, #0]

			flashBuffer[18] = DataTotal;
10001732:	649e      	str	r6, [r3, #72]	; 0x48
10001734:	e15e      	b.n	100019f4 <USIC0_1_IRQHandler+0x640>

		}

		else if (Command == WALKTIME) // Change Walk Time
10001736:	2850      	cmp	r0, #80	; 0x50
10001738:	d11b      	bne.n	10001772 <USIC0_1_IRQHandler+0x3be>
		{
			DataTotal &= 0x03FF; // Mask data. Walktime is 10 bit, not 12 bit information
1000173a:	4daf      	ldr	r5, [pc, #700]	; (100019f8 <USIC0_1_IRQHandler+0x644>)
1000173c:	882f      	ldrh	r7, [r5, #0]
1000173e:	05be      	lsls	r6, r7, #22
10001740:	0db3      	lsrs	r3, r6, #22
			if (DataTotal < 0xF)
10001742:	2b0e      	cmp	r3, #14
10001744:	d800      	bhi.n	10001748 <USIC0_1_IRQHandler+0x394>
				DataTotal = 0xF;
10001746:	230f      	movs	r3, #15
10001748:	802b      	strh	r3, [r5, #0]
			BCCUCH01_SetLinearWalkPrescaler(&BCCUCH01_Handle0, DataTotal); // Red channel
1000174a:	8829      	ldrh	r1, [r5, #0]
1000174c:	48ad      	ldr	r0, [pc, #692]	; (10001a04 <USIC0_1_IRQHandler+0x650>)
1000174e:	f001 fde5 	bl	1000331c <BCCUCH01_SetLinearWalkPrescaler>
			BCCUCH01_SetLinearWalkPrescaler(&BCCUCH01_Handle1, DataTotal); // Green channel
10001752:	8829      	ldrh	r1, [r5, #0]
10001754:	48ac      	ldr	r0, [pc, #688]	; (10001a08 <USIC0_1_IRQHandler+0x654>)
10001756:	f001 fde1 	bl	1000331c <BCCUCH01_SetLinearWalkPrescaler>
			BCCUCH01_SetLinearWalkPrescaler(&BCCUCH01_Handle2, DataTotal); // Blue channel
1000175a:	8829      	ldrh	r1, [r5, #0]
1000175c:	48ab      	ldr	r0, [pc, #684]	; (10001a0c <USIC0_1_IRQHandler+0x658>)
1000175e:	f001 fddd 	bl	1000331c <BCCUCH01_SetLinearWalkPrescaler>
			Lamphandle.LinearWalkPrescaler = DataTotal; // change linear walk in lamphandle enum
			byteCount = 0;
10001762:	2200      	movs	r2, #0
			if (DataTotal < 0xF)
				DataTotal = 0xF;
			BCCUCH01_SetLinearWalkPrescaler(&BCCUCH01_Handle0, DataTotal); // Red channel
			BCCUCH01_SetLinearWalkPrescaler(&BCCUCH01_Handle1, DataTotal); // Green channel
			BCCUCH01_SetLinearWalkPrescaler(&BCCUCH01_Handle2, DataTotal); // Blue channel
			Lamphandle.LinearWalkPrescaler = DataTotal; // change linear walk in lamphandle enum
10001764:	8828      	ldrh	r0, [r5, #0]
10001766:	49aa      	ldr	r1, [pc, #680]	; (10001a10 <USIC0_1_IRQHandler+0x65c>)
			byteCount = 0;
10001768:	6022      	str	r2, [r4, #0]

			flashBuffer[19] = DataTotal;
1000176a:	4ca5      	ldr	r4, [pc, #660]	; (10001a00 <USIC0_1_IRQHandler+0x64c>)
			if (DataTotal < 0xF)
				DataTotal = 0xF;
			BCCUCH01_SetLinearWalkPrescaler(&BCCUCH01_Handle0, DataTotal); // Red channel
			BCCUCH01_SetLinearWalkPrescaler(&BCCUCH01_Handle1, DataTotal); // Green channel
			BCCUCH01_SetLinearWalkPrescaler(&BCCUCH01_Handle2, DataTotal); // Blue channel
			Lamphandle.LinearWalkPrescaler = DataTotal; // change linear walk in lamphandle enum
1000176c:	6188      	str	r0, [r1, #24]
			byteCount = 0;

			flashBuffer[19] = DataTotal;
1000176e:	64e0      	str	r0, [r4, #76]	; 0x4c
10001770:	e140      	b.n	100019f4 <USIC0_1_IRQHandler+0x640>
		}

		else if (Command == DIMMINGLEVEL) // Change dimming Level
10001772:	2860      	cmp	r0, #96	; 0x60
10001774:	d11d      	bne.n	100017b2 <USIC0_1_IRQHandler+0x3fe>
		{
			BCCUDIM01_AbortDimming(&BCCUDIM01_Handle0, GET_CHANNEL_DIM_MASK(BCCUDIM01_Handle0.DE_Num)); // Abort previous dimming
10001776:	4da7      	ldr	r5, [pc, #668]	; (10001a14 <USIC0_1_IRQHandler+0x660>)
10001778:	7a2f      	ldrb	r7, [r5, #8]
1000177a:	1c38      	adds	r0, r7, #0
1000177c:	f001 fcb0 	bl	100030e0 <GET_CHANNEL_DIM_MASK>
10001780:	1c01      	adds	r1, r0, #0
10001782:	1c28      	adds	r0, r5, #0
10001784:	f001 fd1b 	bl	100031be <BCCUDIM01_AbortDimming>
			DataTotal &= 0x0FFF; // Mask data. Dimming is only 12 bit information, not 16 bits
10001788:	4e9b      	ldr	r6, [pc, #620]	; (100019f8 <USIC0_1_IRQHandler+0x644>)
1000178a:	8833      	ldrh	r3, [r6, #0]
1000178c:	0518      	lsls	r0, r3, #20
1000178e:	0d01      	lsrs	r1, r0, #20
			BCCUDIM01_SetDimLvl(&BCCUDIM01_Handle0, DataTotal); // dimming engine 2
10001790:	1c28      	adds	r0, r5, #0
		}

		else if (Command == DIMMINGLEVEL) // Change dimming Level
		{
			BCCUDIM01_AbortDimming(&BCCUDIM01_Handle0, GET_CHANNEL_DIM_MASK(BCCUDIM01_Handle0.DE_Num)); // Abort previous dimming
			DataTotal &= 0x0FFF; // Mask data. Dimming is only 12 bit information, not 16 bits
10001792:	8031      	strh	r1, [r6, #0]
			BCCUDIM01_SetDimLvl(&BCCUDIM01_Handle0, DataTotal); // dimming engine 2
10001794:	f001 fd19 	bl	100031ca <BCCUDIM01_SetDimLvl>
			BCCUDIM01_StartDimming(&BCCUDIM01_Handle0, GET_CHANNEL_DIM_MASK(BCCUDIM01_Handle0.DE_Num));
10001798:	1c38      	adds	r0, r7, #0
1000179a:	f001 fca1 	bl	100030e0 <GET_CHANNEL_DIM_MASK>
1000179e:	1c01      	adds	r1, r0, #0
100017a0:	1c28      	adds	r0, r5, #0
100017a2:	f001 fd07 	bl	100031b4 <BCCUDIM01_StartDimming>
			byteCount = 0;
100017a6:	2100      	movs	r1, #0
100017a8:	6021      	str	r1, [r4, #0]

			flashBuffer[20] = DataTotal;
100017aa:	8832      	ldrh	r2, [r6, #0]
100017ac:	4c94      	ldr	r4, [pc, #592]	; (10001a00 <USIC0_1_IRQHandler+0x64c>)
100017ae:	6522      	str	r2, [r4, #80]	; 0x50
100017b0:	e120      	b.n	100019f4 <USIC0_1_IRQHandler+0x640>
		}

		else if (Command == FADERATE) // Fade Rate
100017b2:	2861      	cmp	r0, #97	; 0x61
100017b4:	d115      	bne.n	100017e2 <USIC0_1_IRQHandler+0x42e>
		{
			BCCUDIM01_AbortDimming(&BCCUDIM01_Handle0, GET_CHANNEL_DIM_MASK(BCCUDIM01_Handle0.DE_Num));
100017b6:	4f97      	ldr	r7, [pc, #604]	; (10001a14 <USIC0_1_IRQHandler+0x660>)
			DataTotal &= 0x03FF; // 10bit number
			BCCUDIM01_SetDimDiv(&BCCUDIM01_Handle0, DataTotal); // dimming engine 2
			byteCount = 0;
100017b8:	2600      	movs	r6, #0
			flashBuffer[20] = DataTotal;
		}

		else if (Command == FADERATE) // Fade Rate
		{
			BCCUDIM01_AbortDimming(&BCCUDIM01_Handle0, GET_CHANNEL_DIM_MASK(BCCUDIM01_Handle0.DE_Num));
100017ba:	7a38      	ldrb	r0, [r7, #8]
100017bc:	f001 fc90 	bl	100030e0 <GET_CHANNEL_DIM_MASK>
100017c0:	1c01      	adds	r1, r0, #0
100017c2:	1c38      	adds	r0, r7, #0
100017c4:	f001 fcfb 	bl	100031be <BCCUDIM01_AbortDimming>
			DataTotal &= 0x03FF; // 10bit number
100017c8:	4d8b      	ldr	r5, [pc, #556]	; (100019f8 <USIC0_1_IRQHandler+0x644>)
100017ca:	8828      	ldrh	r0, [r5, #0]
100017cc:	0581      	lsls	r1, r0, #22
100017ce:	0d89      	lsrs	r1, r1, #22
			BCCUDIM01_SetDimDiv(&BCCUDIM01_Handle0, DataTotal); // dimming engine 2
100017d0:	1c38      	adds	r0, r7, #0
		}

		else if (Command == FADERATE) // Fade Rate
		{
			BCCUDIM01_AbortDimming(&BCCUDIM01_Handle0, GET_CHANNEL_DIM_MASK(BCCUDIM01_Handle0.DE_Num));
			DataTotal &= 0x03FF; // 10bit number
100017d2:	8029      	strh	r1, [r5, #0]
			BCCUDIM01_SetDimDiv(&BCCUDIM01_Handle0, DataTotal); // dimming engine 2
100017d4:	f001 fd07 	bl	100031e6 <BCCUDIM01_SetDimDiv>
			byteCount = 0;
100017d8:	6026      	str	r6, [r4, #0]

			flashBuffer[21] = DataTotal;
100017da:	882a      	ldrh	r2, [r5, #0]
100017dc:	4c88      	ldr	r4, [pc, #544]	; (10001a00 <USIC0_1_IRQHandler+0x64c>)
100017de:	6562      	str	r2, [r4, #84]	; 0x54
100017e0:	e108      	b.n	100019f4 <USIC0_1_IRQHandler+0x640>
		}

		else if (Command == DIRECTACCESS_READ || Command == DIRECTACCESS_MOVE || Command == DIRECTACCESS_AND || Command == DIRECTACCESS_OR)
100017e2:	1c05      	adds	r5, r0, #0
100017e4:	3570      	adds	r5, #112	; 0x70
100017e6:	b2e9      	uxtb	r1, r5
100017e8:	2903      	cmp	r1, #3
100017ea:	d803      	bhi.n	100017f4 <USIC0_1_IRQHandler+0x440>
		{
			// Direct Access commands. The first 4 bytes being sent are the register address. Lower 16 bits of address.
			registerAddress = 0;
			registerAddress = DataTotal;
100017ec:	4b82      	ldr	r3, [pc, #520]	; (100019f8 <USIC0_1_IRQHandler+0x644>)
100017ee:	4d8a      	ldr	r5, [pc, #552]	; (10001a18 <USIC0_1_IRQHandler+0x664>)
100017f0:	881a      	ldrh	r2, [r3, #0]
100017f2:	e052      	b.n	1000189a <USIC0_1_IRQHandler+0x4e6>
		}

		else if (Command == DMXSLOT) // Starting slot number of DMX
100017f4:	2832      	cmp	r0, #50	; 0x32
100017f6:	d108      	bne.n	1000180a <USIC0_1_IRQHandler+0x456>
		{
			startingSlot = DataTotal;
100017f8:	497f      	ldr	r1, [pc, #508]	; (100019f8 <USIC0_1_IRQHandler+0x644>)
			byteCount = 0;
100017fa:	2200      	movs	r2, #0
			registerAddress = DataTotal;
		}

		else if (Command == DMXSLOT) // Starting slot number of DMX
		{
			startingSlot = DataTotal;
100017fc:	880f      	ldrh	r7, [r1, #0]
100017fe:	4e87      	ldr	r6, [pc, #540]	; (10001a1c <USIC0_1_IRQHandler+0x668>)
			byteCount = 0;
10001800:	6022      	str	r2, [r4, #0]

			flashBuffer[8] = DataTotal;
10001802:	4c7f      	ldr	r4, [pc, #508]	; (10001a00 <USIC0_1_IRQHandler+0x64c>)
			registerAddress = DataTotal;
		}

		else if (Command == DMXSLOT) // Starting slot number of DMX
		{
			startingSlot = DataTotal;
10001804:	8037      	strh	r7, [r6, #0]
			byteCount = 0;

			flashBuffer[8] = DataTotal;
10001806:	6227      	str	r7, [r4, #32]
10001808:	e0f4      	b.n	100019f4 <USIC0_1_IRQHandler+0x640>
		}

		else if (Command == DMX8BIT) // Configuration for 8 bit DMX
1000180a:	2833      	cmp	r0, #51	; 0x33
1000180c:	d10c      	bne.n	10001828 <USIC0_1_IRQHandler+0x474>
		{
			DMX_8 = 1; // Set status of 8 bit DMX
			DMX_16 = 0; // Clear 16 bit

			dmx_RedH = DataTotal; // First 16 bits contains information for Red Slot
1000180e:	487a      	ldr	r0, [pc, #488]	; (100019f8 <USIC0_1_IRQHandler+0x644>)
			flashBuffer[8] = DataTotal;
		}

		else if (Command == DMX8BIT) // Configuration for 8 bit DMX
		{
			DMX_8 = 1; // Set status of 8 bit DMX
10001810:	4e83      	ldr	r6, [pc, #524]	; (10001a20 <USIC0_1_IRQHandler+0x66c>)
			DMX_16 = 0; // Clear 16 bit
10001812:	4b84      	ldr	r3, [pc, #528]	; (10001a24 <USIC0_1_IRQHandler+0x670>)

			dmx_RedH = DataTotal; // First 16 bits contains information for Red Slot
10001814:	8800      	ldrh	r0, [r0, #0]
10001816:	4d84      	ldr	r5, [pc, #528]	; (10001a28 <USIC0_1_IRQHandler+0x674>)
			flashBuffer[8] = DataTotal;
		}

		else if (Command == DMX8BIT) // Configuration for 8 bit DMX
		{
			DMX_8 = 1; // Set status of 8 bit DMX
10001818:	2701      	movs	r7, #1
			DMX_16 = 0; // Clear 16 bit
1000181a:	2200      	movs	r2, #0
			flashBuffer[8] = DataTotal;
		}

		else if (Command == DMX8BIT) // Configuration for 8 bit DMX
		{
			DMX_8 = 1; // Set status of 8 bit DMX
1000181c:	6037      	str	r7, [r6, #0]
			DMX_16 = 0; // Clear 16 bit
1000181e:	601a      	str	r2, [r3, #0]

			dmx_RedH = DataTotal; // First 16 bits contains information for Red Slot
10001820:	8028      	strh	r0, [r5, #0]
			flashBuffer[9] = 0x8;
10001822:	4c77      	ldr	r4, [pc, #476]	; (10001a00 <USIC0_1_IRQHandler+0x64c>)
10001824:	2108      	movs	r1, #8
10001826:	e00e      	b.n	10001846 <USIC0_1_IRQHandler+0x492>
			flashBuffer[10] = DataTotal;
		}


		else if (Command == DMX16BIT) // Configuration for 16 bit DMX
10001828:	2834      	cmp	r0, #52	; 0x34
1000182a:	d000      	beq.n	1000182e <USIC0_1_IRQHandler+0x47a>
1000182c:	e0e2      	b.n	100019f4 <USIC0_1_IRQHandler+0x640>
		{
			DMX_8 = 0; // Clear status of 8 bit DMX
			DMX_16 = 1; // Set status of 16 bit DMX


			dmx_RedH = DataTotal;
1000182e:	4a72      	ldr	r2, [pc, #456]	; (100019f8 <USIC0_1_IRQHandler+0x644>)
		}


		else if (Command == DMX16BIT) // Configuration for 16 bit DMX
		{
			DMX_8 = 0; // Clear status of 8 bit DMX
10001830:	4f7b      	ldr	r7, [pc, #492]	; (10001a20 <USIC0_1_IRQHandler+0x66c>)
10001832:	2400      	movs	r4, #0
			DMX_16 = 1; // Set status of 16 bit DMX
10001834:	4b7b      	ldr	r3, [pc, #492]	; (10001a24 <USIC0_1_IRQHandler+0x670>)


			dmx_RedH = DataTotal;
10001836:	8810      	ldrh	r0, [r2, #0]
10001838:	4d7b      	ldr	r5, [pc, #492]	; (10001a28 <USIC0_1_IRQHandler+0x674>)
		}


		else if (Command == DMX16BIT) // Configuration for 16 bit DMX
		{
			DMX_8 = 0; // Clear status of 8 bit DMX
1000183a:	603c      	str	r4, [r7, #0]
			DMX_16 = 1; // Set status of 16 bit DMX
1000183c:	2601      	movs	r6, #1


			dmx_RedH = DataTotal;
			flashBuffer[9] = 0x16;
1000183e:	4c70      	ldr	r4, [pc, #448]	; (10001a00 <USIC0_1_IRQHandler+0x64c>)


		else if (Command == DMX16BIT) // Configuration for 16 bit DMX
		{
			DMX_8 = 0; // Clear status of 8 bit DMX
			DMX_16 = 1; // Set status of 16 bit DMX
10001840:	601e      	str	r6, [r3, #0]


			dmx_RedH = DataTotal;
10001842:	8028      	strh	r0, [r5, #0]
			flashBuffer[9] = 0x16;
10001844:	2116      	movs	r1, #22
10001846:	6261      	str	r1, [r4, #36]	; 0x24
			flashBuffer[10] = DataTotal;
10001848:	62a0      	str	r0, [r4, #40]	; 0x28
1000184a:	e0d3      	b.n	100019f4 <USIC0_1_IRQHandler+0x640>

	}



	else if (byteCount == 5) // Another 2 bytes of data received
1000184c:	2e05      	cmp	r6, #5
1000184e:	d132      	bne.n	100018b6 <USIC0_1_IRQHandler+0x502>
	{

		if (Command == INTENSITY_RGB) // Green color intensity data
10001850:	4c76      	ldr	r4, [pc, #472]	; (10001a2c <USIC0_1_IRQHandler+0x678>)
10001852:	7820      	ldrb	r0, [r4, #0]
10001854:	2814      	cmp	r0, #20
10001856:	d109      	bne.n	1000186c <USIC0_1_IRQHandler+0x4b8>
		{
			DataTotal &= 0x0FFF;
10001858:	4c67      	ldr	r4, [pc, #412]	; (100019f8 <USIC0_1_IRQHandler+0x644>)
			Lamphandle.Intensity_Green = DataTotal;
1000185a:	4e6d      	ldr	r6, [pc, #436]	; (10001a10 <USIC0_1_IRQHandler+0x65c>)
	else if (byteCount == 5) // Another 2 bytes of data received
	{

		if (Command == INTENSITY_RGB) // Green color intensity data
		{
			DataTotal &= 0x0FFF;
1000185c:	8820      	ldrh	r0, [r4, #0]
			Lamphandle.Intensity_Green = DataTotal;
			flashBuffer[2] = DataTotal;
1000185e:	4b68      	ldr	r3, [pc, #416]	; (10001a00 <USIC0_1_IRQHandler+0x64c>)
	else if (byteCount == 5) // Another 2 bytes of data received
	{

		if (Command == INTENSITY_RGB) // Green color intensity data
		{
			DataTotal &= 0x0FFF;
10001860:	0501      	lsls	r1, r0, #20
10001862:	0d0f      	lsrs	r7, r1, #20
10001864:	8027      	strh	r7, [r4, #0]
			Lamphandle.Intensity_Green = DataTotal;
10001866:	6077      	str	r7, [r6, #4]
			flashBuffer[2] = DataTotal;
10001868:	609f      	str	r7, [r3, #8]
1000186a:	e0c3      	b.n	100019f4 <USIC0_1_IRQHandler+0x640>
		}

		else if (Command == CURRENT_RGB) // green peak current reference data
1000186c:	2824      	cmp	r0, #36	; 0x24
1000186e:	d109      	bne.n	10001884 <USIC0_1_IRQHandler+0x4d0>
		{
			DataTotal &= 0x00FF;
10001870:	4d61      	ldr	r5, [pc, #388]	; (100019f8 <USIC0_1_IRQHandler+0x644>)
			BCCUCH01_SetIntensity(&BCCUCH01_Handle4, DataTotal);
10001872:	486f      	ldr	r0, [pc, #444]	; (10001a30 <USIC0_1_IRQHandler+0x67c>)
			flashBuffer[2] = DataTotal;
		}

		else if (Command == CURRENT_RGB) // green peak current reference data
		{
			DataTotal &= 0x00FF;
10001874:	7829      	ldrb	r1, [r5, #0]
10001876:	8029      	strh	r1, [r5, #0]
			BCCUCH01_SetIntensity(&BCCUCH01_Handle4, DataTotal);
10001878:	f001 fd49 	bl	1000330e <BCCUCH01_SetIntensity>
			flashBuffer[5] = DataTotal;
1000187c:	882a      	ldrh	r2, [r5, #0]
1000187e:	4c60      	ldr	r4, [pc, #384]	; (10001a00 <USIC0_1_IRQHandler+0x64c>)
10001880:	6162      	str	r2, [r4, #20]
10001882:	e0b7      	b.n	100019f4 <USIC0_1_IRQHandler+0x640>
		}

		else if (Command == DIRECTACCESS_READ || Command == DIRECTACCESS_MOVE || Command == DIRECTACCESS_AND || Command == DIRECTACCESS_OR) // if commands are these, the 4 bytes of data received is the register address
10001884:	1c01      	adds	r1, r0, #0
10001886:	3170      	adds	r1, #112	; 0x70
10001888:	b2cf      	uxtb	r7, r1
1000188a:	2f03      	cmp	r7, #3
1000188c:	d807      	bhi.n	1000189e <USIC0_1_IRQHandler+0x4ea>
		{
			registerAddress = registerAddress << 16;
			registerAddress |= DataTotal; // get registerAddress;
1000188e:	4d62      	ldr	r5, [pc, #392]	; (10001a18 <USIC0_1_IRQHandler+0x664>)
10001890:	4e59      	ldr	r6, [pc, #356]	; (100019f8 <USIC0_1_IRQHandler+0x644>)
			flashBuffer[5] = DataTotal;
		}

		else if (Command == DIRECTACCESS_READ || Command == DIRECTACCESS_MOVE || Command == DIRECTACCESS_AND || Command == DIRECTACCESS_OR) // if commands are these, the 4 bytes of data received is the register address
		{
			registerAddress = registerAddress << 16;
10001892:	682b      	ldr	r3, [r5, #0]
			registerAddress |= DataTotal; // get registerAddress;
10001894:	8834      	ldrh	r4, [r6, #0]
			flashBuffer[5] = DataTotal;
		}

		else if (Command == DIRECTACCESS_READ || Command == DIRECTACCESS_MOVE || Command == DIRECTACCESS_AND || Command == DIRECTACCESS_OR) // if commands are these, the 4 bytes of data received is the register address
		{
			registerAddress = registerAddress << 16;
10001896:	041a      	lsls	r2, r3, #16
			registerAddress |= DataTotal; // get registerAddress;
10001898:	4322      	orrs	r2, r4
1000189a:	602a      	str	r2, [r5, #0]
1000189c:	e0aa      	b.n	100019f4 <USIC0_1_IRQHandler+0x640>
		}

		else if (Command == DMX8BIT)
1000189e:	2833      	cmp	r0, #51	; 0x33
100018a0:	d053      	beq.n	1000194a <USIC0_1_IRQHandler+0x596>
		{
			dmx_GreenH = DataTotal; // if 8 bit DMX, dmx slot containing green colour intensity data
			flashBuffer[12] = DataTotal;
		}

		else if (Command == DMX16BIT)
100018a2:	2834      	cmp	r0, #52	; 0x34
100018a4:	d000      	beq.n	100018a8 <USIC0_1_IRQHandler+0x4f4>
100018a6:	e0a5      	b.n	100019f4 <USIC0_1_IRQHandler+0x640>
		{

			dmx_RedL = DataTotal; // if 16 bit DMX, dmx slot containing lower red colour intensity data
100018a8:	4d53      	ldr	r5, [pc, #332]	; (100019f8 <USIC0_1_IRQHandler+0x644>)
100018aa:	4b62      	ldr	r3, [pc, #392]	; (10001a34 <USIC0_1_IRQHandler+0x680>)
100018ac:	882e      	ldrh	r6, [r5, #0]

			flashBuffer[11] = dmx_RedL;
100018ae:	4a54      	ldr	r2, [pc, #336]	; (10001a00 <USIC0_1_IRQHandler+0x64c>)
		}

		else if (Command == DMX16BIT)
		{

			dmx_RedL = DataTotal; // if 16 bit DMX, dmx slot containing lower red colour intensity data
100018b0:	801e      	strh	r6, [r3, #0]

			flashBuffer[11] = dmx_RedL;
100018b2:	62d6      	str	r6, [r2, #44]	; 0x2c
100018b4:	e09e      	b.n	100019f4 <USIC0_1_IRQHandler+0x640>

		}

	}

	else if (byteCount == 7) // Another 2 bytes of data received
100018b6:	2e07      	cmp	r6, #7
100018b8:	d14e      	bne.n	10001958 <USIC0_1_IRQHandler+0x5a4>
	{


		if (Command == INTENSITY_RGB) // colour intensity of blue channel
100018ba:	4a5c      	ldr	r2, [pc, #368]	; (10001a2c <USIC0_1_IRQHandler+0x678>)
100018bc:	7815      	ldrb	r5, [r2, #0]
100018be:	2d14      	cmp	r5, #20
100018c0:	d10d      	bne.n	100018de <USIC0_1_IRQHandler+0x52a>
		{
			DataTotal &= 0x0FFF;
100018c2:	4f4d      	ldr	r7, [pc, #308]	; (100019f8 <USIC0_1_IRQHandler+0x644>)
			Lamphandle.Intensity_Blue = DataTotal;
100018c4:	4952      	ldr	r1, [pc, #328]	; (10001a10 <USIC0_1_IRQHandler+0x65c>)
	{


		if (Command == INTENSITY_RGB) // colour intensity of blue channel
		{
			DataTotal &= 0x0FFF;
100018c6:	883d      	ldrh	r5, [r7, #0]
			Lamphandle.Intensity_Blue = DataTotal;
			COLORLAMP01_SetColor(&COLORLAMP01_ConfigHandle0, &Lamphandle);
100018c8:	485b      	ldr	r0, [pc, #364]	; (10001a38 <USIC0_1_IRQHandler+0x684>)
	{


		if (Command == INTENSITY_RGB) // colour intensity of blue channel
		{
			DataTotal &= 0x0FFF;
100018ca:	052e      	lsls	r6, r5, #20
100018cc:	0d33      	lsrs	r3, r6, #20
100018ce:	803b      	strh	r3, [r7, #0]
			Lamphandle.Intensity_Blue = DataTotal;
100018d0:	608b      	str	r3, [r1, #8]
			COLORLAMP01_SetColor(&COLORLAMP01_ConfigHandle0, &Lamphandle);
100018d2:	f001 fb1e 	bl	10002f12 <COLORLAMP01_SetColor>
			flashBuffer[3] = DataTotal;
100018d6:	883a      	ldrh	r2, [r7, #0]
100018d8:	4c49      	ldr	r4, [pc, #292]	; (10001a00 <USIC0_1_IRQHandler+0x64c>)
100018da:	60e2      	str	r2, [r4, #12]
100018dc:	e08a      	b.n	100019f4 <USIC0_1_IRQHandler+0x640>
		}

		else if (Command == CURRENT_RGB) // peak current reference of blue channel
100018de:	2d24      	cmp	r5, #36	; 0x24
100018e0:	d11d      	bne.n	1000191e <USIC0_1_IRQHandler+0x56a>
		{
			DataTotal &= 0x00FF;
100018e2:	4f45      	ldr	r7, [pc, #276]	; (100019f8 <USIC0_1_IRQHandler+0x644>)
			BCCUCH01_SetIntensity(&BCCUCH01_Handle5, DataTotal);
100018e4:	4d55      	ldr	r5, [pc, #340]	; (10001a3c <USIC0_1_IRQHandler+0x688>)
			flashBuffer[3] = DataTotal;
		}

		else if (Command == CURRENT_RGB) // peak current reference of blue channel
		{
			DataTotal &= 0x00FF;
100018e6:	7839      	ldrb	r1, [r7, #0]
			BCCUCH01_SetIntensity(&BCCUCH01_Handle5, DataTotal);
100018e8:	1c28      	adds	r0, r5, #0
			flashBuffer[3] = DataTotal;
		}

		else if (Command == CURRENT_RGB) // peak current reference of blue channel
		{
			DataTotal &= 0x00FF;
100018ea:	8039      	strh	r1, [r7, #0]
			BCCUCH01_SetIntensity(&BCCUCH01_Handle5, DataTotal);
100018ec:	f001 fd0f 	bl	1000330e <BCCUCH01_SetIntensity>
			BCCUCH01_StartLinearWalk(&BCCUCH01_Handle3, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle3.ChNum));
100018f0:	4853      	ldr	r0, [pc, #332]	; (10001a40 <USIC0_1_IRQHandler+0x68c>)
100018f2:	2601      	movs	r6, #1
100018f4:	6883      	ldr	r3, [r0, #8]
100018f6:	1c31      	adds	r1, r6, #0
100018f8:	4099      	lsls	r1, r3
100018fa:	f001 fcfd 	bl	100032f8 <BCCUCH01_StartLinearWalk>
			BCCUCH01_StartLinearWalk(&BCCUCH01_Handle4, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle4.ChNum));
100018fe:	484c      	ldr	r0, [pc, #304]	; (10001a30 <USIC0_1_IRQHandler+0x67c>)
10001900:	1c31      	adds	r1, r6, #0
10001902:	6884      	ldr	r4, [r0, #8]
10001904:	40a1      	lsls	r1, r4
10001906:	f001 fcf7 	bl	100032f8 <BCCUCH01_StartLinearWalk>
			BCCUCH01_StartLinearWalk(&BCCUCH01_Handle5, GET_MASK_FOR_1CHANNEL(BCCUCH01_Handle5.ChNum));
1000190a:	68a8      	ldr	r0, [r5, #8]
1000190c:	1c31      	adds	r1, r6, #0
1000190e:	4081      	lsls	r1, r0
10001910:	1c28      	adds	r0, r5, #0
10001912:	f001 fcf1 	bl	100032f8 <BCCUCH01_StartLinearWalk>
			flashBuffer[6] = DataTotal;
10001916:	8839      	ldrh	r1, [r7, #0]
10001918:	4c39      	ldr	r4, [pc, #228]	; (10001a00 <USIC0_1_IRQHandler+0x64c>)
1000191a:	61a1      	str	r1, [r4, #24]
1000191c:	e06a      	b.n	100019f4 <USIC0_1_IRQHandler+0x640>
		}

		else if (Command == DIRECTACCESS_MOVE || Command == DIRECTACCESS_AND  || Command == DIRECTACCESS_OR)
1000191e:	1c2f      	adds	r7, r5, #0
10001920:	376f      	adds	r7, #111	; 0x6f
10001922:	b2fb      	uxtb	r3, r7
10001924:	2b02      	cmp	r3, #2
10001926:	d803      	bhi.n	10001930 <USIC0_1_IRQHandler+0x57c>
		{
			DataDirect = 0;
			DataDirect = DataTotal;
10001928:	4c33      	ldr	r4, [pc, #204]	; (100019f8 <USIC0_1_IRQHandler+0x644>)
1000192a:	4d46      	ldr	r5, [pc, #280]	; (10001a44 <USIC0_1_IRQHandler+0x690>)
1000192c:	8822      	ldrh	r2, [r4, #0]
1000192e:	e7b4      	b.n	1000189a <USIC0_1_IRQHandler+0x4e6>
		}

		else if (Command == DMX8BIT) // if dmx 8 bit, dmx slot of blue data
10001930:	2d33      	cmp	r5, #51	; 0x33
10001932:	d108      	bne.n	10001946 <USIC0_1_IRQHandler+0x592>
		{
			dmx_BlueH = DataTotal;
10001934:	4930      	ldr	r1, [pc, #192]	; (100019f8 <USIC0_1_IRQHandler+0x644>)
10001936:	4e44      	ldr	r6, [pc, #272]	; (10001a48 <USIC0_1_IRQHandler+0x694>)
10001938:	8808      	ldrh	r0, [r1, #0]
			flashBuffer[14] = DataTotal;
1000193a:	4a31      	ldr	r2, [pc, #196]	; (10001a00 <USIC0_1_IRQHandler+0x64c>)
			byteCount = 0;
1000193c:	2500      	movs	r5, #0
			DataDirect = DataTotal;
		}

		else if (Command == DMX8BIT) // if dmx 8 bit, dmx slot of blue data
		{
			dmx_BlueH = DataTotal;
1000193e:	8030      	strh	r0, [r6, #0]
			flashBuffer[14] = DataTotal;
10001940:	6390      	str	r0, [r2, #56]	; 0x38
			byteCount = 0;
10001942:	6025      	str	r5, [r4, #0]
10001944:	e056      	b.n	100019f4 <USIC0_1_IRQHandler+0x640>
		}

		else if (Command == DMX16BIT) // if dmx 16 bit, dmx slot containing higher green colour intensity data
10001946:	2d34      	cmp	r5, #52	; 0x34
10001948:	d154      	bne.n	100019f4 <USIC0_1_IRQHandler+0x640>
		{
			dmx_GreenH = DataTotal;
1000194a:	4c2b      	ldr	r4, [pc, #172]	; (100019f8 <USIC0_1_IRQHandler+0x644>)
1000194c:	493f      	ldr	r1, [pc, #252]	; (10001a4c <USIC0_1_IRQHandler+0x698>)
1000194e:	8820      	ldrh	r0, [r4, #0]
			flashBuffer[12] = DataTotal;
10001950:	4f2b      	ldr	r7, [pc, #172]	; (10001a00 <USIC0_1_IRQHandler+0x64c>)
			byteCount = 0;
		}

		else if (Command == DMX16BIT) // if dmx 16 bit, dmx slot containing higher green colour intensity data
		{
			dmx_GreenH = DataTotal;
10001952:	8008      	strh	r0, [r1, #0]
			flashBuffer[12] = DataTotal;
10001954:	6338      	str	r0, [r7, #48]	; 0x30
10001956:	e04d      	b.n	100019f4 <USIC0_1_IRQHandler+0x640>


		//byteCount = 0;
	}

	else if (byteCount == 9)
10001958:	2e09      	cmp	r6, #9
1000195a:	d132      	bne.n	100019c2 <USIC0_1_IRQHandler+0x60e>
	{

		if (Command == DIRECTACCESS_MOVE) // direct access commands: this byte will complete the 32 bits of data to be written to the register
1000195c:	4a33      	ldr	r2, [pc, #204]	; (10001a2c <USIC0_1_IRQHandler+0x678>)
1000195e:	7817      	ldrb	r7, [r2, #0]
10001960:	2f91      	cmp	r7, #145	; 0x91
10001962:	d10a      	bne.n	1000197a <USIC0_1_IRQHandler+0x5c6>
		{

			DataDirect = DataDirect << 16;
10001964:	4f37      	ldr	r7, [pc, #220]	; (10001a44 <USIC0_1_IRQHandler+0x690>)
			DataDirect |= DataTotal;
10001966:	4a24      	ldr	r2, [pc, #144]	; (100019f8 <USIC0_1_IRQHandler+0x644>)
	{

		if (Command == DIRECTACCESS_MOVE) // direct access commands: this byte will complete the 32 bits of data to be written to the register
		{

			DataDirect = DataDirect << 16;
10001968:	683b      	ldr	r3, [r7, #0]
			DataDirect |= DataTotal;
			uint32_t *access;
			access = registerAddress;
			*access = DataDirect;
1000196a:	482b      	ldr	r0, [pc, #172]	; (10001a18 <USIC0_1_IRQHandler+0x664>)

		if (Command == DIRECTACCESS_MOVE) // direct access commands: this byte will complete the 32 bits of data to be written to the register
		{

			DataDirect = DataDirect << 16;
			DataDirect |= DataTotal;
1000196c:	8815      	ldrh	r5, [r2, #0]
	{

		if (Command == DIRECTACCESS_MOVE) // direct access commands: this byte will complete the 32 bits of data to be written to the register
		{

			DataDirect = DataDirect << 16;
1000196e:	0419      	lsls	r1, r3, #16
			DataDirect |= DataTotal;
			uint32_t *access;
			access = registerAddress;
			*access = DataDirect;
10001970:	6806      	ldr	r6, [r0, #0]

		if (Command == DIRECTACCESS_MOVE) // direct access commands: this byte will complete the 32 bits of data to be written to the register
		{

			DataDirect = DataDirect << 16;
			DataDirect |= DataTotal;
10001972:	4329      	orrs	r1, r5
10001974:	6039      	str	r1, [r7, #0]
			uint32_t *access;
			access = registerAddress;
			*access = DataDirect;
10001976:	6031      	str	r1, [r6, #0]
10001978:	e03c      	b.n	100019f4 <USIC0_1_IRQHandler+0x640>

		}

		else if (Command == DIRECTACCESS_AND)
1000197a:	2f92      	cmp	r7, #146	; 0x92
1000197c:	d10b      	bne.n	10001996 <USIC0_1_IRQHandler+0x5e2>
		{
			DataDirect = DataDirect << 16;
1000197e:	4931      	ldr	r1, [pc, #196]	; (10001a44 <USIC0_1_IRQHandler+0x690>)
			DataDirect |= DataTotal;
10001980:	4b1d      	ldr	r3, [pc, #116]	; (100019f8 <USIC0_1_IRQHandler+0x644>)

		}

		else if (Command == DIRECTACCESS_AND)
		{
			DataDirect = DataDirect << 16;
10001982:	6808      	ldr	r0, [r1, #0]
			DataDirect |= DataTotal;
10001984:	881f      	ldrh	r7, [r3, #0]
			uint32_t *access;
			access = registerAddress;
10001986:	4e24      	ldr	r6, [pc, #144]	; (10001a18 <USIC0_1_IRQHandler+0x664>)

		}

		else if (Command == DIRECTACCESS_AND)
		{
			DataDirect = DataDirect << 16;
10001988:	0402      	lsls	r2, r0, #16
			DataDirect |= DataTotal;
1000198a:	433a      	orrs	r2, r7
			uint32_t *access;
			access = registerAddress;
1000198c:	6835      	ldr	r5, [r6, #0]
		}

		else if (Command == DIRECTACCESS_AND)
		{
			DataDirect = DataDirect << 16;
			DataDirect |= DataTotal;
1000198e:	600a      	str	r2, [r1, #0]
			uint32_t *access;
			access = registerAddress;
			*access &= DataDirect;
10001990:	682c      	ldr	r4, [r5, #0]
10001992:	4022      	ands	r2, r4
10001994:	e781      	b.n	1000189a <USIC0_1_IRQHandler+0x4e6>
		}

		else if (Command == DIRECTACCESS_OR)
10001996:	2f93      	cmp	r7, #147	; 0x93
10001998:	d10a      	bne.n	100019b0 <USIC0_1_IRQHandler+0x5fc>
		{
			DataDirect = DataDirect << 16;
1000199a:	492a      	ldr	r1, [pc, #168]	; (10001a44 <USIC0_1_IRQHandler+0x690>)
			DataDirect |= DataTotal;
1000199c:	4b16      	ldr	r3, [pc, #88]	; (100019f8 <USIC0_1_IRQHandler+0x644>)
			*access &= DataDirect;
		}

		else if (Command == DIRECTACCESS_OR)
		{
			DataDirect = DataDirect << 16;
1000199e:	6808      	ldr	r0, [r1, #0]
			DataDirect |= DataTotal;
100019a0:	881f      	ldrh	r7, [r3, #0]
			uint32_t *access;
			access = registerAddress;
100019a2:	4e1d      	ldr	r6, [pc, #116]	; (10001a18 <USIC0_1_IRQHandler+0x664>)
			*access &= DataDirect;
		}

		else if (Command == DIRECTACCESS_OR)
		{
			DataDirect = DataDirect << 16;
100019a4:	0402      	lsls	r2, r0, #16
			DataDirect |= DataTotal;
100019a6:	433a      	orrs	r2, r7
			uint32_t *access;
			access = registerAddress;
100019a8:	6835      	ldr	r5, [r6, #0]
		}

		else if (Command == DIRECTACCESS_OR)
		{
			DataDirect = DataDirect << 16;
			DataDirect |= DataTotal;
100019aa:	600a      	str	r2, [r1, #0]
			uint32_t *access;
			access = registerAddress;
			*access |= DataDirect;
100019ac:	682c      	ldr	r4, [r5, #0]
100019ae:	e773      	b.n	10001898 <USIC0_1_IRQHandler+0x4e4>
		}

		else if (Command == DMX16BIT) // if dmx 16 bit, dmx slot containing lower 8 bits of green colour intensity
100019b0:	2f34      	cmp	r7, #52	; 0x34
100019b2:	d11f      	bne.n	100019f4 <USIC0_1_IRQHandler+0x640>
		{

			dmx_GreenL = DataTotal;
100019b4:	4910      	ldr	r1, [pc, #64]	; (100019f8 <USIC0_1_IRQHandler+0x644>)
100019b6:	4d26      	ldr	r5, [pc, #152]	; (10001a50 <USIC0_1_IRQHandler+0x69c>)
100019b8:	880e      	ldrh	r6, [r1, #0]
			flashBuffer[13] = DataTotal;
100019ba:	4c11      	ldr	r4, [pc, #68]	; (10001a00 <USIC0_1_IRQHandler+0x64c>)
		}

		else if (Command == DMX16BIT) // if dmx 16 bit, dmx slot containing lower 8 bits of green colour intensity
		{

			dmx_GreenL = DataTotal;
100019bc:	802e      	strh	r6, [r5, #0]
			flashBuffer[13] = DataTotal;
100019be:	6366      	str	r6, [r4, #52]	; 0x34
100019c0:	e018      	b.n	100019f4 <USIC0_1_IRQHandler+0x640>
		}


	}

	else if (byteCount == 11)
100019c2:	2e0b      	cmp	r6, #11
100019c4:	d10a      	bne.n	100019dc <USIC0_1_IRQHandler+0x628>
	{

		if (Command == DMX16BIT) // dmx slot containing higher 8 bits of blue colour intensity
100019c6:	4919      	ldr	r1, [pc, #100]	; (10001a2c <USIC0_1_IRQHandler+0x678>)
100019c8:	780e      	ldrb	r6, [r1, #0]
100019ca:	2e34      	cmp	r6, #52	; 0x34
100019cc:	d112      	bne.n	100019f4 <USIC0_1_IRQHandler+0x640>
		{

			dmx_BlueH = DataTotal;
100019ce:	4d0a      	ldr	r5, [pc, #40]	; (100019f8 <USIC0_1_IRQHandler+0x644>)
100019d0:	4b1d      	ldr	r3, [pc, #116]	; (10001a48 <USIC0_1_IRQHandler+0x694>)
100019d2:	882c      	ldrh	r4, [r5, #0]
			flashBuffer[14] = DataTotal;
100019d4:	480a      	ldr	r0, [pc, #40]	; (10001a00 <USIC0_1_IRQHandler+0x64c>)
	{

		if (Command == DMX16BIT) // dmx slot containing higher 8 bits of blue colour intensity
		{

			dmx_BlueH = DataTotal;
100019d6:	801c      	strh	r4, [r3, #0]
			flashBuffer[14] = DataTotal;
100019d8:	6384      	str	r4, [r0, #56]	; 0x38
100019da:	e00b      	b.n	100019f4 <USIC0_1_IRQHandler+0x640>
		}
	}

	else if (byteCount == 13)
100019dc:	2e0d      	cmp	r6, #13
100019de:	d109      	bne.n	100019f4 <USIC0_1_IRQHandler+0x640>
	{

		if (Command == DMX16BIT)
100019e0:	4d12      	ldr	r5, [pc, #72]	; (10001a2c <USIC0_1_IRQHandler+0x678>)
100019e2:	782c      	ldrb	r4, [r5, #0]
100019e4:	2c34      	cmp	r4, #52	; 0x34
100019e6:	d105      	bne.n	100019f4 <USIC0_1_IRQHandler+0x640>
		{
// dmx slot containing lower 8 bits of blue colour intensity
			dmx_BlueL = DataTotal;
100019e8:	4b03      	ldr	r3, [pc, #12]	; (100019f8 <USIC0_1_IRQHandler+0x644>)
100019ea:	4a1a      	ldr	r2, [pc, #104]	; (10001a54 <USIC0_1_IRQHandler+0x6a0>)
100019ec:	8818      	ldrh	r0, [r3, #0]
			flashBuffer[15] = DataTotal;
100019ee:	4f04      	ldr	r7, [pc, #16]	; (10001a00 <USIC0_1_IRQHandler+0x64c>)
	{

		if (Command == DMX16BIT)
		{
// dmx slot containing lower 8 bits of blue colour intensity
			dmx_BlueL = DataTotal;
100019f0:	8010      	strh	r0, [r2, #0]
			flashBuffer[15] = DataTotal;
100019f2:	63f8      	str	r0, [r7, #60]	; 0x3c
		}
	}



}
100019f4:	b005      	add	sp, #20
100019f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
100019f8:	20000574 	.word	0x20000574
100019fc:	100040c8 	.word	0x100040c8
10001a00:	200005a8 	.word	0x200005a8
10001a04:	100046a8 	.word	0x100046a8
10001a08:	10004654 	.word	0x10004654
10001a0c:	10004600 	.word	0x10004600
10001a10:	2000058c 	.word	0x2000058c
10001a14:	100044ec 	.word	0x100044ec
10001a18:	20000570 	.word	0x20000570
10001a1c:	20000638 	.word	0x20000638
10001a20:	2000063c 	.word	0x2000063c
10001a24:	20000540 	.word	0x20000540
10001a28:	20000544 	.word	0x20000544
10001a2c:	20000578 	.word	0x20000578
10001a30:	10004558 	.word	0x10004558
10001a34:	2000054a 	.word	0x2000054a
10001a38:	100044a8 	.word	0x100044a8
10001a3c:	10004504 	.word	0x10004504
10001a40:	100045ac 	.word	0x100045ac
10001a44:	2000056c 	.word	0x2000056c
10001a48:	20000548 	.word	0x20000548
10001a4c:	20000546 	.word	0x20000546
10001a50:	2000054c 	.word	0x2000054c
10001a54:	2000054e 	.word	0x2000054e

10001a58 <USIC0_2_IRQHandler>:
 ** Description     : This function is the interrupt service routine when the  **
 **                   shield receives a request for data and when a start      **
 **                   condition is received.                                   **
 *******************************************************************************/
void I2C_START(void)
{
10001a58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

	byteCount = 0;
	uint8_t send = 0x00;
	I2C003_Handle0.I2CRegs->TRBSCR |= 0x8000;
10001a5a:	4ebc      	ldr	r6, [pc, #752]	; (10001d4c <USIC0_2_IRQHandler+0x2f4>)
 **                   condition is received.                                   **
 *******************************************************************************/
void I2C_START(void)
{

	byteCount = 0;
10001a5c:	49bc      	ldr	r1, [pc, #752]	; (10001d50 <USIC0_2_IRQHandler+0x2f8>)
	uint8_t send = 0x00;
	I2C003_Handle0.I2CRegs->TRBSCR |= 0x8000;
10001a5e:	6835      	ldr	r5, [r6, #0]
10001a60:	2080      	movs	r0, #128	; 0x80
10001a62:	1c2a      	adds	r2, r5, #0
10001a64:	32fc      	adds	r2, #252	; 0xfc
10001a66:	69d4      	ldr	r4, [r2, #28]
10001a68:	0207      	lsls	r7, r0, #8
 **                   condition is received.                                   **
 *******************************************************************************/
void I2C_START(void)
{

	byteCount = 0;
10001a6a:	2300      	movs	r3, #0
	uint8_t send = 0x00;
	I2C003_Handle0.I2CRegs->TRBSCR |= 0x8000;
10001a6c:	433c      	orrs	r4, r7
 **                   condition is received.                                   **
 *******************************************************************************/
void I2C_START(void)
{

	byteCount = 0;
10001a6e:	600b      	str	r3, [r1, #0]
	uint8_t send = 0x00;
	I2C003_Handle0.I2CRegs->TRBSCR |= 0x8000;
	I2C003_Handle0.I2CRegs->FMR = 0x00000002U  << USIC_CH_FMR_MTDV_Pos;	// clear TDV and TE
10001a70:	2102      	movs	r1, #2
void I2C_START(void)
{

	byteCount = 0;
	uint8_t send = 0x00;
	I2C003_Handle0.I2CRegs->TRBSCR |= 0x8000;
10001a72:	61d4      	str	r4, [r2, #28]
	I2C003_Handle0.I2CRegs->FMR = 0x00000002U  << USIC_CH_FMR_MTDV_Pos;	// clear TDV and TE
10001a74:	66a9      	str	r1, [r5, #104]	; 0x68
	I2C003_Handle0.I2CRegs->TRBSCR = USIC_CH_TRBSCR_FLUSHTB_Msk;			// flush FIFO transmit buffer
10001a76:	61d7      	str	r7, [r2, #28]
	I2C003_Handle0.I2CRegs->PSCR |= USIC_CH_PSCR_CST5_Msk;
10001a78:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
10001a7a:	2220      	movs	r2, #32
10001a7c:	4313      	orrs	r3, r2
10001a7e:	64eb      	str	r3, [r5, #76]	; 0x4c
	I2C003_Handle0.I2CRegs->PSCR |= USIC_CH_PSCR_CST2_Msk;
10001a80:	6cec      	ldr	r4, [r5, #76]	; 0x4c
10001a82:	2004      	movs	r0, #4
10001a84:	4304      	orrs	r4, r0
10001a86:	64ec      	str	r4, [r5, #76]	; 0x4c

	temp = I2C003_Handle0.I2CRegs->PSR_IICMode;
10001a88:	6cad      	ldr	r5, [r5, #72]	; 0x48
	temp &= 0x00000080;
10001a8a:	4fb2      	ldr	r7, [pc, #712]	; (10001d54 <USIC0_2_IRQHandler+0x2fc>)
10001a8c:	2180      	movs	r1, #128	; 0x80
10001a8e:	4029      	ands	r1, r5
10001a90:	6039      	str	r1, [r7, #0]
10001a92:	1c34      	adds	r4, r6, #0
10001a94:	1c3d      	adds	r5, r7, #0
	if (temp == 0x00000080) // slave read request event occured
10001a96:	2980      	cmp	r1, #128	; 0x80
10001a98:	d000      	beq.n	10001a9c <USIC0_2_IRQHandler+0x44>
10001a9a:	e152      	b.n	10001d42 <USIC0_2_IRQHandler+0x2ea>
	{

		if (Command == READ_INTENSITY_RED) // request for red colour intensity
10001a9c:	4bae      	ldr	r3, [pc, #696]	; (10001d58 <USIC0_2_IRQHandler+0x300>)
10001a9e:	7818      	ldrb	r0, [r3, #0]
10001aa0:	2881      	cmp	r0, #129	; 0x81
10001aa2:	d104      	bne.n	10001aae <USIC0_2_IRQHandler+0x56>
		{
			data2.TDF_Type = I2C003_TDF_STXDATA; // transfer data code
10001aa4:	4cad      	ldr	r4, [pc, #692]	; (10001d5c <USIC0_2_IRQHandler+0x304>)
10001aa6:	2301      	movs	r3, #1
10001aa8:	7063      	strb	r3, [r4, #1]
			temp = BCCUCH01_GetIntensity(&BCCUCH01_Handle0); // BCCU Channel for red channel colour intensity
10001aaa:	48ad      	ldr	r0, [pc, #692]	; (10001d60 <USIC0_2_IRQHandler+0x308>)
10001aac:	e005      	b.n	10001aba <USIC0_2_IRQHandler+0x62>
			send = temp >> 8; // send upper 8 bits of data
			data2.Payload = send;
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_INTENSITY_GREEN) // request for green colour intensity
10001aae:	2882      	cmp	r0, #130	; 0x82
10001ab0:	d113      	bne.n	10001ada <USIC0_2_IRQHandler+0x82>
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
10001ab2:	4caa      	ldr	r4, [pc, #680]	; (10001d5c <USIC0_2_IRQHandler+0x304>)
10001ab4:	2101      	movs	r1, #1
			temp = BCCUCH01_GetIntensity(&BCCUCH01_Handle1); // BCCU Channel for green channel colour intensity
10001ab6:	48ab      	ldr	r0, [pc, #684]	; (10001d64 <USIC0_2_IRQHandler+0x30c>)
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_INTENSITY_GREEN) // request for green colour intensity
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
10001ab8:	7061      	strb	r1, [r4, #1]
			temp = BCCUCH01_GetIntensity(&BCCUCH01_Handle1); // BCCU Channel for green channel colour intensity
10001aba:	f001 fc2b 	bl	10003314 <BCCUCH01_GetIntensity>
			temp &= 0x00000FFF;
10001abe:	0500      	lsls	r0, r0, #20
10001ac0:	0d02      	lsrs	r2, r0, #20
10001ac2:	603a      	str	r2, [r7, #0]

			send = temp;
			data2.Payload = send;
10001ac4:	7022      	strb	r2, [r4, #0]
			I2C003_WriteData(&I2C003_Handle0,&data2);
10001ac6:	1c21      	adds	r1, r4, #0
10001ac8:	1c30      	adds	r0, r6, #0
10001aca:	f000 ff01 	bl	100028d0 <I2C003_WriteData>

			send = temp >> 8;
10001ace:	683f      	ldr	r7, [r7, #0]
			data2.Payload = send;
			I2C003_WriteData(&I2C003_Handle0,&data2);
10001ad0:	1c30      	adds	r0, r6, #0

			send = temp;
			data2.Payload = send;
			I2C003_WriteData(&I2C003_Handle0,&data2);

			send = temp >> 8;
10001ad2:	0a3d      	lsrs	r5, r7, #8
			data2.Payload = send;
10001ad4:	7025      	strb	r5, [r4, #0]
			I2C003_WriteData(&I2C003_Handle0,&data2);
10001ad6:	1c21      	adds	r1, r4, #0
10001ad8:	e131      	b.n	10001d3e <USIC0_2_IRQHandler+0x2e6>
		}

		else if (Command == READ_INTENSITY_BLUE) // request for blue colour intensity
10001ada:	2883      	cmp	r0, #131	; 0x83
10001adc:	d104      	bne.n	10001ae8 <USIC0_2_IRQHandler+0x90>
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
10001ade:	4c9f      	ldr	r4, [pc, #636]	; (10001d5c <USIC0_2_IRQHandler+0x304>)
10001ae0:	2501      	movs	r5, #1
10001ae2:	7065      	strb	r5, [r4, #1]
			temp = BCCUCH01_GetIntensity(&BCCUCH01_Handle2); // BCCU Channel for blue channel colour intensity
10001ae4:	48a0      	ldr	r0, [pc, #640]	; (10001d68 <USIC0_2_IRQHandler+0x310>)
10001ae6:	e7e8      	b.n	10001aba <USIC0_2_IRQHandler+0x62>
			data2.Payload = send;
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}


		else if (Command == READ_CURRENT_RED) // request for peak current reference of red channel
10001ae8:	2884      	cmp	r0, #132	; 0x84
10001aea:	d104      	bne.n	10001af6 <USIC0_2_IRQHandler+0x9e>
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
10001aec:	4c9b      	ldr	r4, [pc, #620]	; (10001d5c <USIC0_2_IRQHandler+0x304>)
10001aee:	2201      	movs	r2, #1
10001af0:	7062      	strb	r2, [r4, #1]
			temp = BCCUCH01_GetIntensity(&BCCUCH01_Handle3); // BCCU channel for red channel
10001af2:	489e      	ldr	r0, [pc, #632]	; (10001d6c <USIC0_2_IRQHandler+0x314>)
10001af4:	e7e1      	b.n	10001aba <USIC0_2_IRQHandler+0x62>
			send = temp >> 8;
			data2.Payload = send;
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_CURRENT_GREEN) // request for peak current reference of green channel
10001af6:	2885      	cmp	r0, #133	; 0x85
10001af8:	d104      	bne.n	10001b04 <USIC0_2_IRQHandler+0xac>
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
10001afa:	4c98      	ldr	r4, [pc, #608]	; (10001d5c <USIC0_2_IRQHandler+0x304>)
10001afc:	2001      	movs	r0, #1
10001afe:	7060      	strb	r0, [r4, #1]
			temp = BCCUCH01_GetIntensity(&BCCUCH01_Handle4); // BCCU Channel for green channel
10001b00:	489b      	ldr	r0, [pc, #620]	; (10001d70 <USIC0_2_IRQHandler+0x318>)
10001b02:	e7da      	b.n	10001aba <USIC0_2_IRQHandler+0x62>
			send = temp >> 8;
			data2.Payload = send;
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_CURRENT_BLUE) // request for peak current reference of blue channel
10001b04:	2886      	cmp	r0, #134	; 0x86
10001b06:	d104      	bne.n	10001b12 <USIC0_2_IRQHandler+0xba>
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
10001b08:	4c94      	ldr	r4, [pc, #592]	; (10001d5c <USIC0_2_IRQHandler+0x304>)
10001b0a:	2301      	movs	r3, #1
10001b0c:	7063      	strb	r3, [r4, #1]
			temp = BCCUCH01_GetIntensity(&BCCUCH01_Handle5); // BCCU Channel for blue channel
10001b0e:	4899      	ldr	r0, [pc, #612]	; (10001d74 <USIC0_2_IRQHandler+0x31c>)
10001b10:	e7d3      	b.n	10001aba <USIC0_2_IRQHandler+0x62>
			send = temp >> 8;
			data2.Payload = send;
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_WALKTIME) // request for walk-time
10001b12:	288a      	cmp	r0, #138	; 0x8a
10001b14:	d109      	bne.n	10001b2a <USIC0_2_IRQHandler+0xd2>
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
			temp = Lamphandle.LinearWalkPrescaler; // variable containing walk-time
10001b16:	4898      	ldr	r0, [pc, #608]	; (10001d78 <USIC0_2_IRQHandler+0x320>)
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_WALKTIME) // request for walk-time
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
10001b18:	4c90      	ldr	r4, [pc, #576]	; (10001d5c <USIC0_2_IRQHandler+0x304>)
			temp = Lamphandle.LinearWalkPrescaler; // variable containing walk-time
			temp &= 0x00003FF;
10001b1a:	6982      	ldr	r2, [r0, #24]
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_WALKTIME) // request for walk-time
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
10001b1c:	2301      	movs	r3, #1
			temp = Lamphandle.LinearWalkPrescaler; // variable containing walk-time
			temp &= 0x00003FF;
10001b1e:	0595      	lsls	r5, r2, #22
10001b20:	0da9      	lsrs	r1, r5, #22
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_WALKTIME) // request for walk-time
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
10001b22:	7063      	strb	r3, [r4, #1]
			temp = Lamphandle.LinearWalkPrescaler; // variable containing walk-time
			temp &= 0x00003FF;
10001b24:	6039      	str	r1, [r7, #0]
			//send = temp >> 8;
			send = temp;
			data2.Payload = send;
10001b26:	7021      	strb	r1, [r4, #0]
10001b28:	e7cd      	b.n	10001ac6 <USIC0_2_IRQHandler+0x6e>
			send = temp >> 8;
			data2.Payload = send;
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_DIMMINGLEVEL) // request for dimming level
10001b2a:	288b      	cmp	r0, #139	; 0x8b
10001b2c:	d106      	bne.n	10001b3c <USIC0_2_IRQHandler+0xe4>
		{

			data2.TDF_Type = I2C003_TDF_STXDATA;
10001b2e:	4c8b      	ldr	r4, [pc, #556]	; (10001d5c <USIC0_2_IRQHandler+0x304>)
10001b30:	2101      	movs	r1, #1
			temp = BCCUDIM01_GetDimLvl(&BCCUDIM01_Handle0); // BCCU Channel for dimming engine
10001b32:	4892      	ldr	r0, [pc, #584]	; (10001d7c <USIC0_2_IRQHandler+0x324>)
		}

		else if (Command == READ_DIMMINGLEVEL) // request for dimming level
		{

			data2.TDF_Type = I2C003_TDF_STXDATA;
10001b34:	7061      	strb	r1, [r4, #1]
			temp = BCCUDIM01_GetDimLvl(&BCCUDIM01_Handle0); // BCCU Channel for dimming engine
10001b36:	f001 fb51 	bl	100031dc <BCCUDIM01_GetDimLvl>
10001b3a:	e7c0      	b.n	10001abe <USIC0_2_IRQHandler+0x66>
			send = temp >> 8;
			data2.Payload = send;
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_FADERATE) // request for fade rate
10001b3c:	288c      	cmp	r0, #140	; 0x8c
10001b3e:	d10a      	bne.n	10001b56 <USIC0_2_IRQHandler+0xfe>
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
10001b40:	4f86      	ldr	r7, [pc, #536]	; (10001d5c <USIC0_2_IRQHandler+0x304>)
10001b42:	2301      	movs	r3, #1
			temp = BCCUDIM01_GetDimDiv(&BCCUDIM01_Handle0); // dimming engine
10001b44:	488d      	ldr	r0, [pc, #564]	; (10001d7c <USIC0_2_IRQHandler+0x324>)
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_FADERATE) // request for fade rate
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
10001b46:	707b      	strb	r3, [r7, #1]
			temp = BCCUDIM01_GetDimDiv(&BCCUDIM01_Handle0); // dimming engine
10001b48:	f001 fb56 	bl	100031f8 <BCCUDIM01_GetDimDiv>
			temp &= 0x00003FF;
10001b4c:	0580      	lsls	r0, r0, #22
10001b4e:	0d82      	lsrs	r2, r0, #22
10001b50:	602a      	str	r2, [r5, #0]

			send = temp;
			data2.Payload = send;
10001b52:	703a      	strb	r2, [r7, #0]
10001b54:	e00b      	b.n	10001b6e <USIC0_2_IRQHandler+0x116>
			send = temp >> 8;
			data2.Payload = send;
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_OFFTIME_RED) // request for off-time of red channel
10001b56:	2887      	cmp	r0, #135	; 0x87
10001b58:	d110      	bne.n	10001b7c <USIC0_2_IRQHandler+0x124>
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
10001b5a:	4f80      	ldr	r7, [pc, #512]	; (10001d5c <USIC0_2_IRQHandler+0x304>)
10001b5c:	2001      	movs	r0, #1
			temp = PWMSP003_Handle0.CC4yRegsPtr->CRS; // compare value of red channel PWM
10001b5e:	4e88      	ldr	r6, [pc, #544]	; (10001d80 <USIC0_2_IRQHandler+0x328>)
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_OFFTIME_RED) // request for off-time of red channel
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
10001b60:	7078      	strb	r0, [r7, #1]
			temp = PWMSP003_Handle0.CC4yRegsPtr->CRS; // compare value of red channel PWM
10001b62:	69f2      	ldr	r2, [r6, #28]
10001b64:	6bd1      	ldr	r1, [r2, #60]	; 0x3c
			temp &= 0x00003FF;
10001b66:	058e      	lsls	r6, r1, #22
10001b68:	0db2      	lsrs	r2, r6, #22
10001b6a:	602a      	str	r2, [r5, #0]

			send = temp;
			data2.Payload = send;
10001b6c:	703a      	strb	r2, [r7, #0]
			I2C003_WriteData(&I2C003_Handle0,&data2);
10001b6e:	1c20      	adds	r0, r4, #0
10001b70:	1c39      	adds	r1, r7, #0
10001b72:	f000 fead 	bl	100028d0 <I2C003_WriteData>

			send = temp >> 8;
10001b76:	682d      	ldr	r5, [r5, #0]
10001b78:	0a2d      	lsrs	r5, r5, #8
10001b7a:	e097      	b.n	10001cac <USIC0_2_IRQHandler+0x254>
			data2.Payload = send;
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_OFFTIME_GREEN) // request for off-time of green channel
10001b7c:	2888      	cmp	r0, #136	; 0x88
10001b7e:	d104      	bne.n	10001b8a <USIC0_2_IRQHandler+0x132>
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
10001b80:	4f76      	ldr	r7, [pc, #472]	; (10001d5c <USIC0_2_IRQHandler+0x304>)
10001b82:	2301      	movs	r3, #1
10001b84:	707b      	strb	r3, [r7, #1]
			temp = PWMSP003_Handle1.CC4yRegsPtr->CRS; // compare value of green channel
10001b86:	4e7f      	ldr	r6, [pc, #508]	; (10001d84 <USIC0_2_IRQHandler+0x32c>)
10001b88:	e7eb      	b.n	10001b62 <USIC0_2_IRQHandler+0x10a>

			send = temp >> 8;
			data2.Payload = send;
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}
		else if (Command == READ_OFFTIME_BLUE) // request for off-time of blue channel
10001b8a:	2889      	cmp	r0, #137	; 0x89
10001b8c:	d104      	bne.n	10001b98 <USIC0_2_IRQHandler+0x140>
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
10001b8e:	4f73      	ldr	r7, [pc, #460]	; (10001d5c <USIC0_2_IRQHandler+0x304>)
10001b90:	2101      	movs	r1, #1
10001b92:	7079      	strb	r1, [r7, #1]
			temp = PWMSP003_Handle2.CC4yRegsPtr->CRS; // compare value of blue channel pwm
10001b94:	4e7c      	ldr	r6, [pc, #496]	; (10001d88 <USIC0_2_IRQHandler+0x330>)
10001b96:	e7e4      	b.n	10001b62 <USIC0_2_IRQHandler+0x10a>
			send = temp >> 8;
			data2.Payload = send;
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_DMX) // read dmx enable control
10001b98:	288d      	cmp	r0, #141	; 0x8d
10001b9a:	d105      	bne.n	10001ba8 <USIC0_2_IRQHandler+0x150>
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
10001b9c:	4f6f      	ldr	r7, [pc, #444]	; (10001d5c <USIC0_2_IRQHandler+0x304>)
			temp = DMXControl;
10001b9e:	4a7b      	ldr	r2, [pc, #492]	; (10001d8c <USIC0_2_IRQHandler+0x334>)
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_DMX) // read dmx enable control
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
10001ba0:	2001      	movs	r0, #1
10001ba2:	7078      	strb	r0, [r7, #1]
			temp = DMXControl;
10001ba4:	6812      	ldr	r2, [r2, #0]
10001ba6:	e7e0      	b.n	10001b6a <USIC0_2_IRQHandler+0x112>
			send = temp >> 8;
			data2.Payload = send;
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_DMXSLOT) // request for first dmx relevant slot
10001ba8:	288e      	cmp	r0, #142	; 0x8e
10001baa:	d104      	bne.n	10001bb6 <USIC0_2_IRQHandler+0x15e>
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
10001bac:	4f6b      	ldr	r7, [pc, #428]	; (10001d5c <USIC0_2_IRQHandler+0x304>)
10001bae:	2301      	movs	r3, #1
10001bb0:	707b      	strb	r3, [r7, #1]
			temp = startingSlot; // first relevant slot
10001bb2:	4a77      	ldr	r2, [pc, #476]	; (10001d90 <USIC0_2_IRQHandler+0x338>)
10001bb4:	e048      	b.n	10001c48 <USIC0_2_IRQHandler+0x1f0>
			send = temp >> 8;
			data2.Payload = send;
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_DMXBIT) // request 8 or 16 bit dmx
10001bb6:	288f      	cmp	r0, #143	; 0x8f
10001bb8:	d10e      	bne.n	10001bd8 <USIC0_2_IRQHandler+0x180>
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
			if (DMX_8 == 1) // 8 bit
10001bba:	4b76      	ldr	r3, [pc, #472]	; (10001d94 <USIC0_2_IRQHandler+0x33c>)
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_DMXBIT) // request 8 or 16 bit dmx
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
10001bbc:	4f67      	ldr	r7, [pc, #412]	; (10001d5c <USIC0_2_IRQHandler+0x304>)
			if (DMX_8 == 1) // 8 bit
10001bbe:	6818      	ldr	r0, [r3, #0]
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_DMXBIT) // request 8 or 16 bit dmx
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
10001bc0:	2601      	movs	r6, #1
10001bc2:	707e      	strb	r6, [r7, #1]
			if (DMX_8 == 1) // 8 bit
10001bc4:	2801      	cmp	r0, #1
10001bc6:	d101      	bne.n	10001bcc <USIC0_2_IRQHandler+0x174>
				temp = 8;
10001bc8:	2608      	movs	r6, #8
10001bca:	e033      	b.n	10001c34 <USIC0_2_IRQHandler+0x1dc>
			else if (DMX_16 == 1) // 16 bit
10001bcc:	4a72      	ldr	r2, [pc, #456]	; (10001d98 <USIC0_2_IRQHandler+0x340>)
10001bce:	6811      	ldr	r1, [r2, #0]
10001bd0:	2901      	cmp	r1, #1
10001bd2:	d130      	bne.n	10001c36 <USIC0_2_IRQHandler+0x1de>
				temp = 16;
10001bd4:	2610      	movs	r6, #16
10001bd6:	e02d      	b.n	10001c34 <USIC0_2_IRQHandler+0x1dc>
			send = temp >> 8;
			data2.Payload = send;
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_DMXREDH) // request for higher 8 bits of red colour intensity from dmx
10001bd8:	2894      	cmp	r0, #148	; 0x94
10001bda:	d104      	bne.n	10001be6 <USIC0_2_IRQHandler+0x18e>
		{
			data2.TDF_Type = I2C003_TDF_STXDATA; // TDF_Ack0
10001bdc:	4f5f      	ldr	r7, [pc, #380]	; (10001d5c <USIC0_2_IRQHandler+0x304>)
10001bde:	2101      	movs	r1, #1
10001be0:	7079      	strb	r1, [r7, #1]

			temp = dmx_RedH;
10001be2:	4a6e      	ldr	r2, [pc, #440]	; (10001d9c <USIC0_2_IRQHandler+0x344>)
10001be4:	e030      	b.n	10001c48 <USIC0_2_IRQHandler+0x1f0>
			send = temp >> 8;
			data2.Payload = send;
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_DMXREDL) // request for lower 8 bits of red colour intensity from dmx. invalid if 8 bit dmx only.
10001be6:	2895      	cmp	r0, #149	; 0x95
10001be8:	d10c      	bne.n	10001c04 <USIC0_2_IRQHandler+0x1ac>
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;

			if (DMX_8 == 1)
10001bea:	4a6a      	ldr	r2, [pc, #424]	; (10001d94 <USIC0_2_IRQHandler+0x33c>)
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_DMXREDL) // request for lower 8 bits of red colour intensity from dmx. invalid if 8 bit dmx only.
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
10001bec:	4f5b      	ldr	r7, [pc, #364]	; (10001d5c <USIC0_2_IRQHandler+0x304>)

			if (DMX_8 == 1)
10001bee:	6811      	ldr	r1, [r2, #0]
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_DMXREDL) // request for lower 8 bits of red colour intensity from dmx. invalid if 8 bit dmx only.
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
10001bf0:	2001      	movs	r0, #1
10001bf2:	7078      	strb	r0, [r7, #1]

			if (DMX_8 == 1)
10001bf4:	2901      	cmp	r1, #1
10001bf6:	d032      	beq.n	10001c5e <USIC0_2_IRQHandler+0x206>
				temp = 0x00;
			else if (DMX_16 == 1)
10001bf8:	4e67      	ldr	r6, [pc, #412]	; (10001d98 <USIC0_2_IRQHandler+0x340>)
10001bfa:	6833      	ldr	r3, [r6, #0]
10001bfc:	2b01      	cmp	r3, #1
10001bfe:	d137      	bne.n	10001c70 <USIC0_2_IRQHandler+0x218>
				temp = dmx_RedL;
10001c00:	4b67      	ldr	r3, [pc, #412]	; (10001da0 <USIC0_2_IRQHandler+0x348>)
10001c02:	e033      	b.n	10001c6c <USIC0_2_IRQHandler+0x214>
			send = temp >> 8;
			data2.Payload = send;
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_DMXGREENH) // request for higher 8 bits of green colour intensity from dmx.
10001c04:	2896      	cmp	r0, #150	; 0x96
10001c06:	d104      	bne.n	10001c12 <USIC0_2_IRQHandler+0x1ba>
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
10001c08:	4f54      	ldr	r7, [pc, #336]	; (10001d5c <USIC0_2_IRQHandler+0x304>)
10001c0a:	2301      	movs	r3, #1
10001c0c:	707b      	strb	r3, [r7, #1]

			temp = dmx_GreenH;
10001c0e:	4a65      	ldr	r2, [pc, #404]	; (10001da4 <USIC0_2_IRQHandler+0x34c>)
10001c10:	e01a      	b.n	10001c48 <USIC0_2_IRQHandler+0x1f0>
			send = temp >> 8;
			data2.Payload = send;
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_DMXGREENL) // request for lower 8 bits of green colour intensity from dmx. if 8 bit, invalid.
10001c12:	2897      	cmp	r0, #151	; 0x97
10001c14:	d112      	bne.n	10001c3c <USIC0_2_IRQHandler+0x1e4>
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;

			if (DMX_8 == 1)
10001c16:	4e5f      	ldr	r6, [pc, #380]	; (10001d94 <USIC0_2_IRQHandler+0x33c>)
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_DMXGREENL) // request for lower 8 bits of green colour intensity from dmx. if 8 bit, invalid.
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
10001c18:	4f50      	ldr	r7, [pc, #320]	; (10001d5c <USIC0_2_IRQHandler+0x304>)

			if (DMX_8 == 1)
10001c1a:	6833      	ldr	r3, [r6, #0]
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_DMXGREENL) // request for lower 8 bits of green colour intensity from dmx. if 8 bit, invalid.
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
10001c1c:	2101      	movs	r1, #1
10001c1e:	7079      	strb	r1, [r7, #1]

			if (DMX_8 == 1)
10001c20:	2b01      	cmp	r3, #1
10001c22:	d101      	bne.n	10001c28 <USIC0_2_IRQHandler+0x1d0>
				temp = 0x00;
10001c24:	2600      	movs	r6, #0
10001c26:	e005      	b.n	10001c34 <USIC0_2_IRQHandler+0x1dc>
			else if (DMX_16 == 1)
10001c28:	485b      	ldr	r0, [pc, #364]	; (10001d98 <USIC0_2_IRQHandler+0x340>)
10001c2a:	6802      	ldr	r2, [r0, #0]
10001c2c:	2a01      	cmp	r2, #1
10001c2e:	d102      	bne.n	10001c36 <USIC0_2_IRQHandler+0x1de>
				temp = dmx_GreenL;
10001c30:	495d      	ldr	r1, [pc, #372]	; (10001da8 <USIC0_2_IRQHandler+0x350>)
10001c32:	880e      	ldrh	r6, [r1, #0]
10001c34:	602e      	str	r6, [r5, #0]

			send = temp;
			data2.Payload = send;
10001c36:	682e      	ldr	r6, [r5, #0]
10001c38:	703e      	strb	r6, [r7, #0]
10001c3a:	e798      	b.n	10001b6e <USIC0_2_IRQHandler+0x116>
			send = temp >> 8;
			data2.Payload = send;
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_DMXBLUEH) // request for higher 8 bits of blue colour intensity.
10001c3c:	2898      	cmp	r0, #152	; 0x98
10001c3e:	d105      	bne.n	10001c4c <USIC0_2_IRQHandler+0x1f4>
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
10001c40:	4f46      	ldr	r7, [pc, #280]	; (10001d5c <USIC0_2_IRQHandler+0x304>)
10001c42:	2001      	movs	r0, #1

			temp = dmx_BlueH;
10001c44:	4a59      	ldr	r2, [pc, #356]	; (10001dac <USIC0_2_IRQHandler+0x354>)
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_DMXBLUEH) // request for higher 8 bits of blue colour intensity.
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
10001c46:	7078      	strb	r0, [r7, #1]

			temp = dmx_BlueH;
10001c48:	8812      	ldrh	r2, [r2, #0]
10001c4a:	e78e      	b.n	10001b6a <USIC0_2_IRQHandler+0x112>
			send = temp >> 8;
			data2.Payload = send;
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_DMXBLUEL) //request for lower 8 bits of blue colour intensity
10001c4c:	2899      	cmp	r0, #153	; 0x99
10001c4e:	d111      	bne.n	10001c74 <USIC0_2_IRQHandler+0x21c>
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;

			if (DMX_8 == 1)
10001c50:	4850      	ldr	r0, [pc, #320]	; (10001d94 <USIC0_2_IRQHandler+0x33c>)
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_DMXBLUEL) //request for lower 8 bits of blue colour intensity
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
10001c52:	4f42      	ldr	r7, [pc, #264]	; (10001d5c <USIC0_2_IRQHandler+0x304>)

			if (DMX_8 == 1)
10001c54:	6802      	ldr	r2, [r0, #0]
			I2C003_WriteData(&I2C003_Handle0,&data2);
		}

		else if (Command == READ_DMXBLUEL) //request for lower 8 bits of blue colour intensity
		{
			data2.TDF_Type = I2C003_TDF_STXDATA;
10001c56:	2301      	movs	r3, #1
10001c58:	707b      	strb	r3, [r7, #1]

			if (DMX_8 == 1)
10001c5a:	2a01      	cmp	r2, #1
10001c5c:	d101      	bne.n	10001c62 <USIC0_2_IRQHandler+0x20a>
				temp = 0x00;
10001c5e:	2000      	movs	r0, #0
10001c60:	e005      	b.n	10001c6e <USIC0_2_IRQHandler+0x216>
			else if (DMX_16 == 1)
10001c62:	494d      	ldr	r1, [pc, #308]	; (10001d98 <USIC0_2_IRQHandler+0x340>)
10001c64:	680e      	ldr	r6, [r1, #0]
10001c66:	2e01      	cmp	r6, #1
10001c68:	d102      	bne.n	10001c70 <USIC0_2_IRQHandler+0x218>
				temp = dmx_BlueL;
10001c6a:	4b51      	ldr	r3, [pc, #324]	; (10001db0 <USIC0_2_IRQHandler+0x358>)
10001c6c:	8818      	ldrh	r0, [r3, #0]
10001c6e:	6028      	str	r0, [r5, #0]

			send = temp;
			data2.Payload = send;
10001c70:	682a      	ldr	r2, [r5, #0]
10001c72:	e77b      	b.n	10001b6c <USIC0_2_IRQHandler+0x114>





		else if (Command == DIRECTACCESS_READ) // request for data in a register
10001c74:	2890      	cmp	r0, #144	; 0x90
10001c76:	d11d      	bne.n	10001cb4 <USIC0_2_IRQHandler+0x25c>
		{
			uint32_t *access;
			access = registerAddress;
			temp = *access;
10001c78:	494e      	ldr	r1, [pc, #312]	; (10001db4 <USIC0_2_IRQHandler+0x35c>)


			data2.TDF_Type = I2C003_TDF_STXDATA;
10001c7a:	2001      	movs	r0, #1

		else if (Command == DIRECTACCESS_READ) // request for data in a register
		{
			uint32_t *access;
			access = registerAddress;
			temp = *access;
10001c7c:	680e      	ldr	r6, [r1, #0]
10001c7e:	6833      	ldr	r3, [r6, #0]
10001c80:	603b      	str	r3, [r7, #0]


			data2.TDF_Type = I2C003_TDF_STXDATA;
10001c82:	4f36      	ldr	r7, [pc, #216]	; (10001d5c <USIC0_2_IRQHandler+0x304>)
10001c84:	7078      	strb	r0, [r7, #1]

			send = (uint8_t) (temp);
			data2.Payload = send;
			I2C003_WriteData(&I2C003_Handle0,&data2);
10001c86:	1c39      	adds	r1, r7, #0
10001c88:	1c20      	adds	r0, r4, #0


			data2.TDF_Type = I2C003_TDF_STXDATA;

			send = (uint8_t) (temp);
			data2.Payload = send;
10001c8a:	703b      	strb	r3, [r7, #0]
			I2C003_WriteData(&I2C003_Handle0,&data2);
10001c8c:	f000 fe20 	bl	100028d0 <I2C003_WriteData>

			send = temp >> 8;
10001c90:	682a      	ldr	r2, [r5, #0]
			data2.Payload = send;
			I2C003_WriteData(&I2C003_Handle0,&data2);
10001c92:	1c20      	adds	r0, r4, #0

			send = (uint8_t) (temp);
			data2.Payload = send;
			I2C003_WriteData(&I2C003_Handle0,&data2);

			send = temp >> 8;
10001c94:	0a11      	lsrs	r1, r2, #8
			data2.Payload = send;
10001c96:	7039      	strb	r1, [r7, #0]
			I2C003_WriteData(&I2C003_Handle0,&data2);
10001c98:	1c39      	adds	r1, r7, #0
10001c9a:	f000 fe19 	bl	100028d0 <I2C003_WriteData>

			send = temp >> 16;
10001c9e:	886e      	ldrh	r6, [r5, #2]
			data2.Payload = send;
			I2C003_WriteData(&I2C003_Handle0,&data2);
10001ca0:	1c20      	adds	r0, r4, #0
10001ca2:	1c39      	adds	r1, r7, #0
			send = temp >> 8;
			data2.Payload = send;
			I2C003_WriteData(&I2C003_Handle0,&data2);

			send = temp >> 16;
			data2.Payload = send;
10001ca4:	703e      	strb	r6, [r7, #0]
			I2C003_WriteData(&I2C003_Handle0,&data2);
10001ca6:	f000 fe13 	bl	100028d0 <I2C003_WriteData>

			send = temp >> 24;
10001caa:	78ed      	ldrb	r5, [r5, #3]
			data2.Payload = send;
10001cac:	703d      	strb	r5, [r7, #0]
			I2C003_WriteData(&I2C003_Handle0,&data2);
10001cae:	1c20      	adds	r0, r4, #0
10001cb0:	1c39      	adds	r1, r7, #0
10001cb2:	e044      	b.n	10001d3e <USIC0_2_IRQHandler+0x2e6>


		}

		else if (writeToFlash == 1) // request to save prameters to flash
10001cb4:	4e40      	ldr	r6, [pc, #256]	; (10001db8 <USIC0_2_IRQHandler+0x360>)
10001cb6:	6837      	ldr	r7, [r6, #0]
10001cb8:	2f01      	cmp	r7, #1
10001cba:	d132      	bne.n	10001d22 <USIC0_2_IRQHandler+0x2ca>
		{
			flashBuffer[0] ++;
10001cbc:	4e3f      	ldr	r6, [pc, #252]	; (10001dbc <USIC0_2_IRQHandler+0x364>)
10001cbe:	6830      	ldr	r0, [r6, #0]
10001cc0:	3001      	adds	r0, #1
10001cc2:	6030      	str	r0, [r6, #0]

			status_t status;
			FLASH003_ClearStatus();
10001cc4:	f000 fe60 	bl	10002988 <FLASH003_ClearStatus>
			if ( ! (flashBuffer[0] % 2 )) // if odd number in first element in buffer, store in first half of flash page starting from 0x10004F00
10001cc8:	6832      	ldr	r2, [r6, #0]
10001cca:	4d3d      	ldr	r5, [pc, #244]	; (10001dc0 <USIC0_2_IRQHandler+0x368>)
10001ccc:	423a      	tst	r2, r7
10001cce:	d107      	bne.n	10001ce0 <USIC0_2_IRQHandler+0x288>
			{
				flashAddress = 0x10004F00;
10001cd0:	493c      	ldr	r1, [pc, #240]	; (10001dc4 <USIC0_2_IRQHandler+0x36c>)
10001cd2:	6029      	str	r1, [r5, #0]
				while ( FLASH003_ErasePage((unsigned long )flashAddress) != FLASH003_COMPLETE ); // erase page
10001cd4:	6828      	ldr	r0, [r5, #0]
10001cd6:	f000 fec7 	bl	10002a68 <FLASH003_ErasePage>
10001cda:	2800      	cmp	r0, #0
10001cdc:	d1fa      	bne.n	10001cd4 <USIC0_2_IRQHandler+0x27c>
10001cde:	e001      	b.n	10001ce4 <USIC0_2_IRQHandler+0x28c>
			}

			else if (flashBuffer[0] %2) // if even number, store in second half of page. Address is 0x10004F80. Second half of page already erased before.
				flashAddress = 0x10004F80;
10001ce0:	4f39      	ldr	r7, [pc, #228]	; (10001dc8 <USIC0_2_IRQHandler+0x370>)
10001ce2:	602f      	str	r7, [r5, #0]


			FLASH003_WriteMultipleBlocks(flashAddress, flashBuffer, 6U); // write to flash
10001ce4:	1c31      	adds	r1, r6, #0
10001ce6:	6828      	ldr	r0, [r5, #0]
10001ce8:	2206      	movs	r2, #6
10001cea:	f000 fe83 	bl	100029f4 <FLASH003_WriteMultipleBlocks>
			FLASH003_ReadBytes(flashAddress, flashBuffer, 92); // update array containing variables
10001cee:	225c      	movs	r2, #92	; 0x5c
10001cf0:	1c31      	adds	r1, r6, #0
10001cf2:	6828      	ldr	r0, [r5, #0]
10001cf4:	f000 fee0 	bl	10002ab8 <FLASH003_ReadBytes>

			data2.TDF_Type = I2C003_TDF_STXDATA;
10001cf8:	4d18      	ldr	r5, [pc, #96]	; (10001d5c <USIC0_2_IRQHandler+0x304>)

			send = 0x11;
			data2.Payload = send;
10001cfa:	2311      	movs	r3, #17


			FLASH003_WriteMultipleBlocks(flashAddress, flashBuffer, 6U); // write to flash
			FLASH003_ReadBytes(flashAddress, flashBuffer, 92); // update array containing variables

			data2.TDF_Type = I2C003_TDF_STXDATA;
10001cfc:	2601      	movs	r6, #1

			send = 0x11;
			data2.Payload = send;
			I2C003_WriteData(&I2C003_Handle0,&data2); // send data back to master to indicate write operation finished
10001cfe:	1c20      	adds	r0, r4, #0
10001d00:	1c29      	adds	r1, r5, #0
			FLASH003_ReadBytes(flashAddress, flashBuffer, 92); // update array containing variables

			data2.TDF_Type = I2C003_TDF_STXDATA;

			send = 0x11;
			data2.Payload = send;
10001d02:	702b      	strb	r3, [r5, #0]


			FLASH003_WriteMultipleBlocks(flashAddress, flashBuffer, 6U); // write to flash
			FLASH003_ReadBytes(flashAddress, flashBuffer, 92); // update array containing variables

			data2.TDF_Type = I2C003_TDF_STXDATA;
10001d04:	706e      	strb	r6, [r5, #1]

			send = 0x11;
			data2.Payload = send;
			I2C003_WriteData(&I2C003_Handle0,&data2); // send data back to master to indicate write operation finished
10001d06:	f000 fde3 	bl	100028d0 <I2C003_WriteData>

			send = 0x12;
			data2.Payload = send;
10001d0a:	2012      	movs	r0, #18
10001d0c:	7028      	strb	r0, [r5, #0]
			I2C003_WriteData(&I2C003_Handle0,&data2);
10001d0e:	1c29      	adds	r1, r5, #0
10001d10:	1c20      	adds	r0, r4, #0
10001d12:	f000 fddd 	bl	100028d0 <I2C003_WriteData>

			writeToFlash = 0;
10001d16:	4a28      	ldr	r2, [pc, #160]	; (10001db8 <USIC0_2_IRQHandler+0x360>)
			configStatus = 1;
10001d18:	4f2c      	ldr	r7, [pc, #176]	; (10001dcc <USIC0_2_IRQHandler+0x374>)

			send = 0x12;
			data2.Payload = send;
			I2C003_WriteData(&I2C003_Handle0,&data2);

			writeToFlash = 0;
10001d1a:	2400      	movs	r4, #0
10001d1c:	6014      	str	r4, [r2, #0]
			configStatus = 1;
10001d1e:	603e      	str	r6, [r7, #0]
10001d20:	e00f      	b.n	10001d42 <USIC0_2_IRQHandler+0x2ea>
		}

		else if (Command == READ_CONFIG) // request for configuration status
10001d22:	2880      	cmp	r0, #128	; 0x80
10001d24:	d10d      	bne.n	10001d42 <USIC0_2_IRQHandler+0x2ea>
		{

			data2.TDF_Type = I2C003_TDF_STXDATA;

			send = (uint8_t) (configStatus);
10001d26:	4929      	ldr	r1, [pc, #164]	; (10001dcc <USIC0_2_IRQHandler+0x374>)
		}

		else if (Command == READ_CONFIG) // request for configuration status
		{

			data2.TDF_Type = I2C003_TDF_STXDATA;
10001d28:	4d0c      	ldr	r5, [pc, #48]	; (10001d5c <USIC0_2_IRQHandler+0x304>)

			send = (uint8_t) (configStatus);
10001d2a:	680b      	ldr	r3, [r1, #0]
		}

		else if (Command == READ_CONFIG) // request for configuration status
		{

			data2.TDF_Type = I2C003_TDF_STXDATA;
10001d2c:	2201      	movs	r2, #1

			send = (uint8_t) (configStatus);
			data2.Payload = send;
			I2C003_WriteData(&I2C003_Handle0,&data2);
10001d2e:	1c29      	adds	r1, r5, #0
10001d30:	1c20      	adds	r0, r4, #0
		}

		else if (Command == READ_CONFIG) // request for configuration status
		{

			data2.TDF_Type = I2C003_TDF_STXDATA;
10001d32:	706a      	strb	r2, [r5, #1]

			send = (uint8_t) (configStatus);
			data2.Payload = send;
10001d34:	702b      	strb	r3, [r5, #0]
			I2C003_WriteData(&I2C003_Handle0,&data2);
10001d36:	f000 fdcb 	bl	100028d0 <I2C003_WriteData>

			I2C003_WriteData(&I2C003_Handle0,&data2);
10001d3a:	1c20      	adds	r0, r4, #0
10001d3c:	1c29      	adds	r1, r5, #0
10001d3e:	f000 fdc7 	bl	100028d0 <I2C003_WriteData>

		}


	}
	byteCount = 0;
10001d42:	4c03      	ldr	r4, [pc, #12]	; (10001d50 <USIC0_2_IRQHandler+0x2f8>)
10001d44:	2600      	movs	r6, #0
10001d46:	6026      	str	r6, [r4, #0]

}
10001d48:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
10001d4a:	46c0      	nop			; (mov r8, r8)
10001d4c:	10004460 	.word	0x10004460
10001d50:	20000554 	.word	0x20000554
10001d54:	20000560 	.word	0x20000560
10001d58:	20000578 	.word	0x20000578
10001d5c:	20000606 	.word	0x20000606
10001d60:	100046a8 	.word	0x100046a8
10001d64:	10004654 	.word	0x10004654
10001d68:	10004600 	.word	0x10004600
10001d6c:	100045ac 	.word	0x100045ac
10001d70:	10004558 	.word	0x10004558
10001d74:	10004504 	.word	0x10004504
10001d78:	2000058c 	.word	0x2000058c
10001d7c:	100044ec 	.word	0x100044ec
10001d80:	10004198 	.word	0x10004198
10001d84:	10004130 	.word	0x10004130
10001d88:	100040c8 	.word	0x100040c8
10001d8c:	20000634 	.word	0x20000634
10001d90:	20000638 	.word	0x20000638
10001d94:	2000063c 	.word	0x2000063c
10001d98:	20000540 	.word	0x20000540
10001d9c:	20000544 	.word	0x20000544
10001da0:	2000054a 	.word	0x2000054a
10001da4:	20000546 	.word	0x20000546
10001da8:	2000054c 	.word	0x2000054c
10001dac:	20000548 	.word	0x20000548
10001db0:	2000054e 	.word	0x2000054e
10001db4:	20000570 	.word	0x20000570
10001db8:	20000550 	.word	0x20000550
10001dbc:	200005a8 	.word	0x200005a8
10001dc0:	20000640 	.word	0x20000640
10001dc4:	10004f00 	.word	0x10004f00
10001dc8:	10004f80 	.word	0x10004f80
10001dcc:	20000630 	.word	0x20000630

10001dd0 <NMI_Handler>:
/* Default exception Handlers - Users may override this default functionality by
   defining handlers of the same name in their C code */
    .thumb 
    .text

    Insert_ExceptionHandler NMI_Handler
10001dd0:	e7fe      	b.n	10001dd0 <NMI_Handler>

10001dd2 <HardFault_Handler>:
/* ======================================================================== */
    Insert_ExceptionHandler HardFault_Handler
10001dd2:	e7fe      	b.n	10001dd2 <HardFault_Handler>

10001dd4 <SVC_Handler>:
/* ======================================================================== */
    Insert_ExceptionHandler SVC_Handler
10001dd4:	e7fe      	b.n	10001dd4 <SVC_Handler>

10001dd6 <PendSV_Handler>:
/* ======================================================================== */
    Insert_ExceptionHandler PendSV_Handler
10001dd6:	e7fe      	b.n	10001dd6 <PendSV_Handler>

10001dd8 <SysTick_Handler>:
/* ======================================================================== */
    Insert_ExceptionHandler SysTick_Handler
10001dd8:	e7fe      	b.n	10001dd8 <SysTick_Handler>

10001dda <SCU_0_IRQHandler>:
/* ============= END OF EXCEPTION HANDLER DEFINITION ======================== */

/* ============= START OF INTERRUPT HANDLER DEFINITION ====================== */

/* IRQ Handlers */
    Insert_ExceptionHandler SCU_0_IRQHandler
10001dda:	e7fe      	b.n	10001dda <SCU_0_IRQHandler>

10001ddc <SCU_1_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler SCU_1_IRQHandler
10001ddc:	e7fe      	b.n	10001ddc <SCU_1_IRQHandler>

10001dde <SCU_2_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler SCU_2_IRQHandler
10001dde:	e7fe      	b.n	10001dde <SCU_2_IRQHandler>

10001de0 <ERU0_0_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler ERU0_0_IRQHandler
10001de0:	e7fe      	b.n	10001de0 <ERU0_0_IRQHandler>

10001de2 <ERU0_1_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler ERU0_1_IRQHandler
10001de2:	e7fe      	b.n	10001de2 <ERU0_1_IRQHandler>

10001de4 <ERU0_2_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler ERU0_2_IRQHandler
10001de4:	e7fe      	b.n	10001de4 <ERU0_2_IRQHandler>

10001de6 <ERU0_3_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler ERU0_3_IRQHandler
10001de6:	e7fe      	b.n	10001de6 <ERU0_3_IRQHandler>

10001de8 <VADC0_C0_0_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler VADC0_C0_0_IRQHandler
10001de8:	e7fe      	b.n	10001de8 <VADC0_C0_0_IRQHandler>

10001dea <VADC0_C0_1_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler VADC0_C0_1_IRQHandler
10001dea:	e7fe      	b.n	10001dea <VADC0_C0_1_IRQHandler>

10001dec <VADC0_G0_0_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler VADC0_G0_0_IRQHandler
10001dec:	e7fe      	b.n	10001dec <VADC0_G0_0_IRQHandler>

10001dee <VADC0_G0_1_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler VADC0_G0_1_IRQHandler
10001dee:	e7fe      	b.n	10001dee <VADC0_G0_1_IRQHandler>

10001df0 <VADC0_G1_0_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler VADC0_G1_0_IRQHandler
10001df0:	e7fe      	b.n	10001df0 <VADC0_G1_0_IRQHandler>

10001df2 <VADC0_G1_1_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler VADC0_G1_1_IRQHandler
10001df2:	e7fe      	b.n	10001df2 <VADC0_G1_1_IRQHandler>

10001df4 <CCU40_0_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler CCU40_0_IRQHandler
10001df4:	e7fe      	b.n	10001df4 <CCU40_0_IRQHandler>

10001df6 <CCU40_1_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler CCU40_1_IRQHandler
10001df6:	e7fe      	b.n	10001df6 <CCU40_1_IRQHandler>

10001df8 <CCU40_2_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler CCU40_2_IRQHandler
10001df8:	e7fe      	b.n	10001df8 <CCU40_2_IRQHandler>

10001dfa <CCU40_3_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler CCU40_3_IRQHandler
10001dfa:	e7fe      	b.n	10001dfa <CCU40_3_IRQHandler>
/* ======================================================================== */
    Insert_ExceptionHandler USIC0_0_IRQHandler
10001dfc:	e7fe      	b.n	10001dfc <CCU40_3_IRQHandler+0x2>
/* ======================================================================== */
    Insert_ExceptionHandler USIC0_1_IRQHandler
10001dfe:	e7fe      	b.n	10001dfe <CCU40_3_IRQHandler+0x4>
/* ======================================================================== */
    Insert_ExceptionHandler USIC0_2_IRQHandler
10001e00:	e7fe      	b.n	10001e00 <CCU40_3_IRQHandler+0x6>

10001e02 <USIC0_3_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler USIC0_3_IRQHandler
10001e02:	e7fe      	b.n	10001e02 <USIC0_3_IRQHandler>

10001e04 <USIC0_4_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler USIC0_4_IRQHandler
10001e04:	e7fe      	b.n	10001e04 <USIC0_4_IRQHandler>

10001e06 <USIC0_5_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler USIC0_5_IRQHandler
10001e06:	e7fe      	b.n	10001e06 <USIC0_5_IRQHandler>

10001e08 <LEDTS0_0_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler LEDTS0_0_IRQHandler
10001e08:	e7fe      	b.n	10001e08 <LEDTS0_0_IRQHandler>

10001e0a <LEDTS1_0_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler LEDTS1_0_IRQHandler
10001e0a:	e7fe      	b.n	10001e0a <LEDTS1_0_IRQHandler>

10001e0c <BCCU0_0_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler BCCU0_0_IRQHandler
10001e0c:	e7fe      	b.n	10001e0c <BCCU0_0_IRQHandler>
	...

10001e10 <SystemCoreClockUpdate>:
  */
void SystemCoreClockUpdate(void)
{
  uint32_t IDIV, FDIV;

  IDIV = ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_IDIV_Msk) >> SCU_CLK_CLKCR_IDIV_Pos;
10001e10:	4a09      	ldr	r2, [pc, #36]	; (10001e38 <SystemCoreClockUpdate+0x28>)
  * @note   -  
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
10001e12:	b510      	push	{r4, lr}
  uint32_t IDIV, FDIV;

  IDIV = ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_IDIV_Msk) >> SCU_CLK_CLKCR_IDIV_Pos;
10001e14:	6813      	ldr	r3, [r2, #0]
10001e16:	4c09      	ldr	r4, [pc, #36]	; (10001e3c <SystemCoreClockUpdate+0x2c>)
10001e18:	0418      	lsls	r0, r3, #16
10001e1a:	0e03      	lsrs	r3, r0, #24
  FDIV = ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_FDIV_Msk) >> SCU_CLK_CLKCR_FDIV_Pos;
10001e1c:	6811      	ldr	r1, [r2, #0]
  
  if(IDIV)
10001e1e:	d008      	beq.n	10001e32 <SystemCoreClockUpdate+0x22>
  {
    /* Fractional divider is enabled and used */
    SystemCoreClock = ((MCLK_MHZ << 7) / ((IDIV << 8) + FDIV)) << 1;
10001e20:	0218      	lsls	r0, r3, #8
void SystemCoreClockUpdate(void)
{
  uint32_t IDIV, FDIV;

  IDIV = ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_IDIV_Msk) >> SCU_CLK_CLKCR_IDIV_Pos;
  FDIV = ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_FDIV_Msk) >> SCU_CLK_CLKCR_FDIV_Pos;
10001e22:	b2cb      	uxtb	r3, r1
  
  if(IDIV)
  {
    /* Fractional divider is enabled and used */
    SystemCoreClock = ((MCLK_MHZ << 7) / ((IDIV << 8) + FDIV)) << 1;
10001e24:	18c1      	adds	r1, r0, r3
10001e26:	4806      	ldr	r0, [pc, #24]	; (10001e40 <SystemCoreClockUpdate+0x30>)
10001e28:	f001 fb16 	bl	10003458 <__aeabi_uidiv>
10001e2c:	0041      	lsls	r1, r0, #1
10001e2e:	6021      	str	r1, [r4, #0]
10001e30:	e001      	b.n	10001e36 <SystemCoreClockUpdate+0x26>
  }
  else
  {
    /* Fractional divider bypassed. Simply divide DCO_DCLK by 2 */
    SystemCoreClock = MCLK_MHZ;
10001e32:	4a04      	ldr	r2, [pc, #16]	; (10001e44 <SystemCoreClockUpdate+0x34>)
10001e34:	6022      	str	r2, [r4, #0]
  }
}
10001e36:	bd10      	pop	{r4, pc}
10001e38:	40010300 	.word	0x40010300
10001e3c:	20000610 	.word	0x20000610
10001e40:	f4240000 	.word	0xf4240000
10001e44:	01e84800 	.word	0x01e84800

10001e48 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{    
10001e48:	b508      	push	{r3, lr}
   * while((SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk));
   * SCU_GENERAL->PASSWD = 0x000000C3UL; // enable bit protection
   * SystemCoreClockUpdate();
   *
   */
  SystemCoreClockUpdate();
10001e4a:	f7ff ffe1 	bl	10001e10 <SystemCoreClockUpdate>
}
10001e4e:	bd08      	pop	{r3, pc}

10001e50 <PWMSP003_lSetCompareEdgeAlign>:
{
  uint32_t Temp1;
  uint32_t Temp2;
  PWMSP003_HandleType* HandlePtr = (PWMSP003_HandleType*)Handle;

  HandlePtr->CC4yRegsPtr->CRS = (Compare & 0xFFFFU);
10001e50:	69c3      	ldr	r3, [r0, #28]
10001e52:	b289      	uxth	r1, r1
10001e54:	63d9      	str	r1, [r3, #60]	; 0x3c

  /* Request shadow transfer */
  Temp2 = (PWMSP003_NO_OF_SLICES * (uint32_t)HandlePtr->Slice);
  Temp1 = (uint32_t)CCU4_GCSS_S0SE_Pos + Temp2;
  HandlePtr->CC4yKernRegsPtr->GCSS |= ((uint32_t)0x01 << Temp1);
10001e56:	6983      	ldr	r3, [r0, #24]
  PWMSP003_HandleType* HandlePtr = (PWMSP003_HandleType*)Handle;

  HandlePtr->CC4yRegsPtr->CRS = (Compare & 0xFFFFU);

  /* Request shadow transfer */
  Temp2 = (PWMSP003_NO_OF_SLICES * (uint32_t)HandlePtr->Slice);
10001e58:	3058      	adds	r0, #88	; 0x58
10001e5a:	7802      	ldrb	r2, [r0, #0]
  Temp1 = (uint32_t)CCU4_GCSS_S0SE_Pos + Temp2;
  HandlePtr->CC4yKernRegsPtr->GCSS |= ((uint32_t)0x01 << Temp1);
10001e5c:	2001      	movs	r0, #1
  PWMSP003_HandleType* HandlePtr = (PWMSP003_HandleType*)Handle;

  HandlePtr->CC4yRegsPtr->CRS = (Compare & 0xFFFFU);

  /* Request shadow transfer */
  Temp2 = (PWMSP003_NO_OF_SLICES * (uint32_t)HandlePtr->Slice);
10001e5e:	0092      	lsls	r2, r2, #2
  Temp1 = (uint32_t)CCU4_GCSS_S0SE_Pos + Temp2;
  HandlePtr->CC4yKernRegsPtr->GCSS |= ((uint32_t)0x01 << Temp1);
10001e60:	6919      	ldr	r1, [r3, #16]
10001e62:	4090      	lsls	r0, r2
10001e64:	1c02      	adds	r2, r0, #0
10001e66:	430a      	orrs	r2, r1
10001e68:	611a      	str	r2, [r3, #16]
}
10001e6a:	4770      	bx	lr

10001e6c <PWMSP003_lSetDutyEdgeAlign>:
/**
 * This function is used to change the duty cycle of the PWM waveform
 * in edge-aligned mode
 */
void PWMSP003_lSetDutyEdgeAlign( void* Handle, float Duty)
{
10001e6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  fDuty = Duty;



  fDuty = (float)((float)100.00 - (float)fDuty)/(float)100.00;
  fPRS = (float)((uint32_t)HandlePtr->CC4yRegsPtr->PRS + 1U);
10001e6e:	69c5      	ldr	r5, [r0, #28]
/**
 * This function is used to change the duty cycle of the PWM waveform
 * in edge-aligned mode
 */
void PWMSP003_lSetDutyEdgeAlign( void* Handle, float Duty)
{
10001e70:	1c04      	adds	r4, r0, #0
  fDuty = Duty;



  fDuty = (float)((float)100.00 - (float)fDuty)/(float)100.00;
  fPRS = (float)((uint32_t)HandlePtr->CC4yRegsPtr->PRS + 1U);
10001e72:	6b68      	ldr	r0, [r5, #52]	; 0x34
/**
 * This function is used to change the duty cycle of the PWM waveform
 * in edge-aligned mode
 */
void PWMSP003_lSetDutyEdgeAlign( void* Handle, float Duty)
{
10001e74:	1c0f      	adds	r7, r1, #0
  fDuty = Duty;



  fDuty = (float)((float)100.00 - (float)fDuty)/(float)100.00;
  fPRS = (float)((uint32_t)HandlePtr->CC4yRegsPtr->PRS + 1U);
10001e76:	3001      	adds	r0, #1
10001e78:	f002 f8ac 	bl	10003fd4 <__aeabi_ui2f>
  PWMSP003_HandleType* HandlePtr = (PWMSP003_HandleType*)Handle;
  fDuty = Duty;



  fDuty = (float)((float)100.00 - (float)fDuty)/(float)100.00;
10001e7c:	1c39      	adds	r1, r7, #0
  fPRS = (float)((uint32_t)HandlePtr->CC4yRegsPtr->PRS + 1U);
10001e7e:	1c06      	adds	r6, r0, #0
  PWMSP003_HandleType* HandlePtr = (PWMSP003_HandleType*)Handle;
  fDuty = Duty;



  fDuty = (float)((float)100.00 - (float)fDuty)/(float)100.00;
10001e80:	480c      	ldr	r0, [pc, #48]	; (10001eb4 <PWMSP003_lSetDutyEdgeAlign+0x48>)
10001e82:	f001 fead 	bl	10003be0 <__aeabi_fsub>
10001e86:	490b      	ldr	r1, [pc, #44]	; (10001eb4 <PWMSP003_lSetDutyEdgeAlign+0x48>)
10001e88:	f001 fb88 	bl	1000359c <__aeabi_fdiv>
10001e8c:	1c01      	adds	r1, r0, #0
  fPRS = (float)((uint32_t)HandlePtr->CC4yRegsPtr->PRS + 1U);
  CompareVal = (uint32_t)( fPRS * fDuty);
10001e8e:	1c30      	adds	r0, r6, #0
10001e90:	f001 fd76 	bl	10003980 <__aeabi_fmul>
10001e94:	f001 fb6a 	bl	1000356c <__aeabi_f2uiz>
  HandlePtr->CC4yRegsPtr->CRS = CompareVal  & 0xFFFFU;
10001e98:	b280      	uxth	r0, r0
10001e9a:	63e8      	str	r0, [r5, #60]	; 0x3c

  /*Shadow transfer */
  Temp1 =  ((uint32_t)CCU4_GCSS_S0SE_Pos +\
                ((uint32_t)PWMSP003_NO_OF_SLICES *(uint32_t)HandlePtr->Slice));
  HandlePtr->CC4yKernRegsPtr->GCSS |=\
10001e9c:	69a3      	ldr	r3, [r4, #24]
  CompareVal = (uint32_t)( fPRS * fDuty);
  HandlePtr->CC4yRegsPtr->CRS = CompareVal  & 0xFFFFU;

  /*Shadow transfer */
  Temp1 =  ((uint32_t)CCU4_GCSS_S0SE_Pos +\
                ((uint32_t)PWMSP003_NO_OF_SLICES *(uint32_t)HandlePtr->Slice));
10001e9e:	3458      	adds	r4, #88	; 0x58
10001ea0:	7822      	ldrb	r2, [r4, #0]
  HandlePtr->CC4yKernRegsPtr->GCSS |=\
                                 (uint32_t)((uint32_t)0x01 << (uint32_t)Temp1);
10001ea2:	2701      	movs	r7, #1
  fPRS = (float)((uint32_t)HandlePtr->CC4yRegsPtr->PRS + 1U);
  CompareVal = (uint32_t)( fPRS * fDuty);
  HandlePtr->CC4yRegsPtr->CRS = CompareVal  & 0xFFFFU;

  /*Shadow transfer */
  Temp1 =  ((uint32_t)CCU4_GCSS_S0SE_Pos +\
10001ea4:	0094      	lsls	r4, r2, #2
                ((uint32_t)PWMSP003_NO_OF_SLICES *(uint32_t)HandlePtr->Slice));
  HandlePtr->CC4yKernRegsPtr->GCSS |=\
10001ea6:	6919      	ldr	r1, [r3, #16]
                                 (uint32_t)((uint32_t)0x01 << (uint32_t)Temp1);
10001ea8:	40a7      	lsls	r7, r4
10001eaa:	1c3d      	adds	r5, r7, #0
  HandlePtr->CC4yRegsPtr->CRS = CompareVal  & 0xFFFFU;

  /*Shadow transfer */
  Temp1 =  ((uint32_t)CCU4_GCSS_S0SE_Pos +\
                ((uint32_t)PWMSP003_NO_OF_SLICES *(uint32_t)HandlePtr->Slice));
  HandlePtr->CC4yKernRegsPtr->GCSS |=\
10001eac:	430d      	orrs	r5, r1
10001eae:	611d      	str	r5, [r3, #16]
                                 (uint32_t)((uint32_t)0x01 << (uint32_t)Temp1);

}
10001eb0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
10001eb2:	46c0      	nop			; (mov r8, r8)
10001eb4:	42c80000 	.word	0x42c80000

10001eb8 <PWMSP003_lInit>:

/**
 * This function initializes an instance of the app
 */
status_t PWMSP003_lInit(const PWMSP003_HandleType* HandlePtr)
{
10001eb8:	b5f0      	push	{r4, r5, r6, r7, lr}
10001eba:	1c02      	adds	r2, r0, #0
  PWMSP003_EdgeTriggerType EdgeSelection = PWMSP003_NO_TRIGGER;
  PWMSP003_ActiveLevelType LevelSelection = PWMSP003_ACTIVE_ON_HIGH;

  do
  {
    if (HandlePtr->DynamicDataType->StateType != PWMSP003_UNINITIALIZED)
10001ebc:	6dc0      	ldr	r0, [r0, #92]	; 0x5c

/**
 * This function initializes an instance of the app
 */
status_t PWMSP003_lInit(const PWMSP003_HandleType* HandlePtr)
{
10001ebe:	b085      	sub	sp, #20
  PWMSP003_EdgeTriggerType EdgeSelection = PWMSP003_NO_TRIGGER;
  PWMSP003_ActiveLevelType LevelSelection = PWMSP003_ACTIVE_ON_HIGH;

  do
  {
    if (HandlePtr->DynamicDataType->StateType != PWMSP003_UNINITIALIZED)
10001ec0:	9003      	str	r0, [sp, #12]
10001ec2:	7803      	ldrb	r3, [r0, #0]
/**
 * This function initializes an instance of the app
 */
status_t PWMSP003_lInit(const PWMSP003_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)PWMSP003_OPER_NOT_ALLOWED_ERROR;
10001ec4:	2001      	movs	r0, #1
  PWMSP003_EdgeTriggerType EdgeSelection = PWMSP003_NO_TRIGGER;
  PWMSP003_ActiveLevelType LevelSelection = PWMSP003_ACTIVE_ON_HIGH;

  do
  {
    if (HandlePtr->DynamicDataType->StateType != PWMSP003_UNINITIALIZED)
10001ec6:	2b00      	cmp	r3, #0
10001ec8:	d000      	beq.n	10001ecc <PWMSP003_lInit+0x14>
10001eca:	e214      	b.n	100022f6 <PWMSP003_lInit+0x43e>
    {
      break;
    }
    HandlePtr->CC4yRegsPtr->TCCLR = PWMSP003_SLICE_CLEAR;
10001ecc:	69d3      	ldr	r3, [r2, #28]
10001ece:	2107      	movs	r1, #7
10001ed0:	6119      	str	r1, [r3, #16]

    if(HandlePtr->kEvent0Function != PWMSP003_NO_FUNCTION)
10001ed2:	1d54      	adds	r4, r2, #5
10001ed4:	7fe5      	ldrb	r5, [r4, #31]
10001ed6:	b269      	sxtb	r1, r5
10001ed8:	1c4c      	adds	r4, r1, #1
10001eda:	d04f      	beq.n	10001f7c <PWMSP003_lInit+0xc4>
    {
      if(HandlePtr->kEvent0Function == PWMSP003_EXTERNAL_START)
10001edc:	2d00      	cmp	r5, #0
10001ede:	d104      	bne.n	10001eea <PWMSP003_lInit+0x32>
      {
        EdgeSelection = HandlePtr->kStartEdge;
10001ee0:	1c10      	adds	r0, r2, #0
10001ee2:	3043      	adds	r0, #67	; 0x43
10001ee4:	7800      	ldrb	r0, [r0, #0]
status_t PWMSP003_lInit(const PWMSP003_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)PWMSP003_OPER_NOT_ALLOWED_ERROR;
  uint32_t Temp;
  PWMSP003_EdgeTriggerType EdgeSelection = PWMSP003_NO_TRIGGER;
  PWMSP003_ActiveLevelType LevelSelection = PWMSP003_ACTIVE_ON_HIGH;
10001ee6:	1c2c      	adds	r4, r5, #0
10001ee8:	e01f      	b.n	10001f2a <PWMSP003_lInit+0x72>
    {
      if(HandlePtr->kEvent0Function == PWMSP003_EXTERNAL_START)
      {
        EdgeSelection = HandlePtr->kStartEdge;
      }
      else if(HandlePtr->kEvent0Function == PWMSP003_EXTERNAL_STOP)
10001eea:	2902      	cmp	r1, #2
10001eec:	d102      	bne.n	10001ef4 <PWMSP003_lInit+0x3c>
      {
        EdgeSelection = HandlePtr->kStopEdge;
10001eee:	1c16      	adds	r6, r2, #0
10001ef0:	3644      	adds	r6, #68	; 0x44
10001ef2:	e008      	b.n	10001f06 <PWMSP003_lInit+0x4e>
      }
      else if(HandlePtr->kEvent0Function == PWMSP003_EXTERNAL_LOAD)
10001ef4:	290c      	cmp	r1, #12
10001ef6:	d102      	bne.n	10001efe <PWMSP003_lInit+0x46>
      {
        EdgeSelection = HandlePtr->kLoadEventEdge;
10001ef8:	1c16      	adds	r6, r2, #0
10001efa:	3640      	adds	r6, #64	; 0x40
10001efc:	e003      	b.n	10001f06 <PWMSP003_lInit+0x4e>
      }
      else if(HandlePtr->kEvent0Function == PWMSP003_EXTERNAL_COUNT)
10001efe:	290e      	cmp	r1, #14
10001f00:	d103      	bne.n	10001f0a <PWMSP003_lInit+0x52>
      {
        EdgeSelection = HandlePtr->kCountEventEdge;
10001f02:	1c16      	adds	r6, r2, #0
10001f04:	363f      	adds	r6, #63	; 0x3f
10001f06:	7830      	ldrb	r0, [r6, #0]
10001f08:	e009      	b.n	10001f1e <PWMSP003_lInit+0x66>
      else
      {
        EdgeSelection = PWMSP003_RISING_EDGE;
      }

      if(HandlePtr->kEvent0Function == PWMSP003_EXTERNAL_COUNT_DIRECTION)
10001f0a:	290a      	cmp	r1, #10
10001f0c:	d102      	bne.n	10001f14 <PWMSP003_lInit+0x5c>
      {
        LevelSelection = HandlePtr->kCntDirActiveLevel;
10001f0e:	1c17      	adds	r7, r2, #0
10001f10:	3736      	adds	r7, #54	; 0x36
10001f12:	e009      	b.n	10001f28 <PWMSP003_lInit+0x70>
      }
      else if(HandlePtr->kEvent0Function == PWMSP003_EXTERNAL_MODULATION)
10001f14:	2912      	cmp	r1, #18
10001f16:	d102      	bne.n	10001f1e <PWMSP003_lInit+0x66>
      {
        LevelSelection = HandlePtr->kModulationActiveLevel;
10001f18:	1c17      	adds	r7, r2, #0
10001f1a:	3733      	adds	r7, #51	; 0x33
10001f1c:	e004      	b.n	10001f28 <PWMSP003_lInit+0x70>
status_t PWMSP003_lInit(const PWMSP003_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)PWMSP003_OPER_NOT_ALLOWED_ERROR;
  uint32_t Temp;
  PWMSP003_EdgeTriggerType EdgeSelection = PWMSP003_NO_TRIGGER;
  PWMSP003_ActiveLevelType LevelSelection = PWMSP003_ACTIVE_ON_HIGH;
10001f1e:	2400      	movs	r4, #0
      }
      else if(HandlePtr->kEvent0Function == PWMSP003_EXTERNAL_MODULATION)
      {
        LevelSelection = HandlePtr->kModulationActiveLevel;
      }
      else if(HandlePtr->kEvent0Function == PWMSP003_EXTERNAL_GATING)
10001f20:	2908      	cmp	r1, #8
10001f22:	d102      	bne.n	10001f2a <PWMSP003_lInit+0x72>
      {
        LevelSelection = HandlePtr->kGateEventActiveLevel;
10001f24:	1c17      	adds	r7, r2, #0
10001f26:	373e      	adds	r7, #62	; 0x3e
10001f28:	783c      	ldrb	r4, [r7, #0]
      else
      {
        /** */
      }

      WR_REG(HandlePtr->CC4yRegsPtr->INS, (uint32_t)CCU4_CC4_INS_EV0EM_Msk,\
10001f2a:	26c0      	movs	r6, #192	; 0xc0
10001f2c:	02b6      	lsls	r6, r6, #10
10001f2e:	0400      	lsls	r0, r0, #16
10001f30:	681f      	ldr	r7, [r3, #0]
10001f32:	4030      	ands	r0, r6
10001f34:	4e77      	ldr	r6, [pc, #476]	; (10002114 <PWMSP003_lInit+0x25c>)
               (uint32_t)CCU4_CC4_INS_EV0EM_Pos, (uint32_t)EdgeSelection);

      WR_REG(HandlePtr->CC4yRegsPtr->INS, (uint32_t)CCU4_CC4_INS_EV0LM_Msk,\
10001f36:	05a4      	lsls	r4, r4, #22
      else
      {
        /** */
      }

      WR_REG(HandlePtr->CC4yRegsPtr->INS, (uint32_t)CCU4_CC4_INS_EV0EM_Msk,\
10001f38:	403e      	ands	r6, r7
10001f3a:	4330      	orrs	r0, r6
10001f3c:	6018      	str	r0, [r3, #0]
               (uint32_t)CCU4_CC4_INS_EV0EM_Pos, (uint32_t)EdgeSelection);

      WR_REG(HandlePtr->CC4yRegsPtr->INS, (uint32_t)CCU4_CC4_INS_EV0LM_Msk,\
10001f3e:	2080      	movs	r0, #128	; 0x80
10001f40:	681f      	ldr	r7, [r3, #0]
10001f42:	03c6      	lsls	r6, r0, #15
10001f44:	4874      	ldr	r0, [pc, #464]	; (10002118 <PWMSP003_lInit+0x260>)
10001f46:	4034      	ands	r4, r6
10001f48:	4007      	ands	r7, r0
10001f4a:	433c      	orrs	r4, r7
10001f4c:	601c      	str	r4, [r3, #0]
               (uint32_t)CCU4_CC4_INS_EV0LM_Pos, (uint32_t)LevelSelection);

      WR_REG(HandlePtr->CC4yRegsPtr->INS, (uint32_t)CCU4_CC4_INS_LPF0M_Msk,\
10001f4e:	1c14      	adds	r4, r2, #0
10001f50:	3430      	adds	r4, #48	; 0x30
10001f52:	7826      	ldrb	r6, [r4, #0]
10001f54:	20c0      	movs	r0, #192	; 0xc0
10001f56:	681f      	ldr	r7, [r3, #0]
10001f58:	0674      	lsls	r4, r6, #25
10001f5a:	04c6      	lsls	r6, r0, #19
10001f5c:	486f      	ldr	r0, [pc, #444]	; (1000211c <PWMSP003_lInit+0x264>)
10001f5e:	4034      	ands	r4, r6
10001f60:	4038      	ands	r0, r7
10001f62:	4320      	orrs	r0, r4
10001f64:	6018      	str	r0, [r3, #0]
               (uint32_t)CCU4_CC4_INS_LPF0M_Pos, HandlePtr->kEvent0_lpfconfig);

      if(HandlePtr->kEvent0Function != PWMSP003_EXTERNAL_START)
10001f66:	2d00      	cmp	r5, #0
10001f68:	d008      	beq.n	10001f7c <PWMSP003_lInit+0xc4>
      {
        WR_REG(HandlePtr->CC4yRegsPtr->CMC,\
10001f6a:	685c      	ldr	r4, [r3, #4]
10001f6c:	2703      	movs	r7, #3
10001f6e:	2501      	movs	r5, #1
10001f70:	408f      	lsls	r7, r1
10001f72:	408d      	lsls	r5, r1
10001f74:	43bc      	bics	r4, r7
10001f76:	402f      	ands	r7, r5
10001f78:	4327      	orrs	r7, r4
10001f7a:	605f      	str	r7, [r3, #4]

    /* Reset to default */
    EdgeSelection = PWMSP003_NO_TRIGGER;
    LevelSelection = PWMSP003_ACTIVE_ON_HIGH;

    if(HandlePtr->kEvent1Function != PWMSP003_NO_FUNCTION)
10001f7c:	1d96      	adds	r6, r2, #6
10001f7e:	7ff4      	ldrb	r4, [r6, #31]
10001f80:	4d67      	ldr	r5, [pc, #412]	; (10002120 <PWMSP003_lInit+0x268>)
10001f82:	b261      	sxtb	r1, r4
10001f84:	1c4f      	adds	r7, r1, #1
10001f86:	d05e      	beq.n	10002046 <PWMSP003_lInit+0x18e>
    {
      if(HandlePtr->kEvent1Function == PWMSP003_EXTERNAL_START)
10001f88:	2c00      	cmp	r4, #0
10001f8a:	d104      	bne.n	10001f96 <PWMSP003_lInit+0xde>
      {
        EdgeSelection = HandlePtr->kStartEdge;
10001f8c:	1c17      	adds	r7, r2, #0
10001f8e:	3743      	adds	r7, #67	; 0x43
10001f90:	783f      	ldrb	r7, [r7, #0]
      }
    }

    /* Reset to default */
    EdgeSelection = PWMSP003_NO_TRIGGER;
    LevelSelection = PWMSP003_ACTIVE_ON_HIGH;
10001f92:	1c20      	adds	r0, r4, #0
10001f94:	e027      	b.n	10001fe6 <PWMSP003_lInit+0x12e>
    {
      if(HandlePtr->kEvent1Function == PWMSP003_EXTERNAL_START)
      {
        EdgeSelection = HandlePtr->kStartEdge;
      }
      else if(HandlePtr->kEvent1Function == PWMSP003_EXTERNAL_STOP)
10001f96:	2902      	cmp	r1, #2
10001f98:	d102      	bne.n	10001fa0 <PWMSP003_lInit+0xe8>
      {
        EdgeSelection = HandlePtr->kStopEdge;
10001f9a:	1c16      	adds	r6, r2, #0
10001f9c:	3644      	adds	r6, #68	; 0x44
10001f9e:	e008      	b.n	10001fb2 <PWMSP003_lInit+0xfa>
      }
      else if(HandlePtr->kEvent1Function == PWMSP003_EXTERNAL_LOAD)
10001fa0:	290c      	cmp	r1, #12
10001fa2:	d102      	bne.n	10001faa <PWMSP003_lInit+0xf2>
      {
        EdgeSelection = HandlePtr->kLoadEventEdge;
10001fa4:	1c16      	adds	r6, r2, #0
10001fa6:	3640      	adds	r6, #64	; 0x40
10001fa8:	e003      	b.n	10001fb2 <PWMSP003_lInit+0xfa>
      }
      else if(HandlePtr->kEvent1Function == PWMSP003_EXTERNAL_COUNT)
10001faa:	290e      	cmp	r1, #14
10001fac:	d103      	bne.n	10001fb6 <PWMSP003_lInit+0xfe>
      {
        EdgeSelection = HandlePtr->kCountEventEdge;
10001fae:	1c16      	adds	r6, r2, #0
10001fb0:	363f      	adds	r6, #63	; 0x3f
10001fb2:	7837      	ldrb	r7, [r6, #0]
10001fb4:	e011      	b.n	10001fda <PWMSP003_lInit+0x122>
      else
      {
        EdgeSelection = PWMSP003_RISING_EDGE;
      }

      if(HandlePtr->kEvent1Function == PWMSP003_EXTERNAL_COUNT_DIRECTION)
10001fb6:	290a      	cmp	r1, #10
10001fb8:	d104      	bne.n	10001fc4 <PWMSP003_lInit+0x10c>
      {
        LevelSelection = HandlePtr->kCntDirActiveLevel;
10001fba:	1c10      	adds	r0, r2, #0
10001fbc:	3036      	adds	r0, #54	; 0x36
10001fbe:	7800      	ldrb	r0, [r0, #0]
      {
        EdgeSelection = HandlePtr->kCountEventEdge;
      }
      else
      {
        EdgeSelection = PWMSP003_RISING_EDGE;
10001fc0:	2701      	movs	r7, #1
10001fc2:	e010      	b.n	10001fe6 <PWMSP003_lInit+0x12e>
10001fc4:	2701      	movs	r7, #1

      if(HandlePtr->kEvent1Function == PWMSP003_EXTERNAL_COUNT_DIRECTION)
      {
        LevelSelection = HandlePtr->kCntDirActiveLevel;
      }
      else if(HandlePtr->kEvent1Function == PWMSP003_EXTERNAL_MODULATION)
10001fc6:	2912      	cmp	r1, #18
10001fc8:	d102      	bne.n	10001fd0 <PWMSP003_lInit+0x118>
      {
        LevelSelection = HandlePtr->kModulationActiveLevel;
10001fca:	1c10      	adds	r0, r2, #0
10001fcc:	3033      	adds	r0, #51	; 0x33
10001fce:	e009      	b.n	10001fe4 <PWMSP003_lInit+0x12c>
      }
      else if(HandlePtr->kEvent1Function == PWMSP003_EXTERNAL_OVERRIDE)
10001fd0:	2910      	cmp	r1, #16
10001fd2:	d102      	bne.n	10001fda <PWMSP003_lInit+0x122>
      {
        LevelSelection = HandlePtr->kOverrideActiveLevel;
10001fd4:	1c10      	adds	r0, r2, #0
10001fd6:	3042      	adds	r0, #66	; 0x42
10001fd8:	e004      	b.n	10001fe4 <PWMSP003_lInit+0x12c>
      }
    }

    /* Reset to default */
    EdgeSelection = PWMSP003_NO_TRIGGER;
    LevelSelection = PWMSP003_ACTIVE_ON_HIGH;
10001fda:	2000      	movs	r0, #0
      }
      else if(HandlePtr->kEvent1Function == PWMSP003_EXTERNAL_OVERRIDE)
      {
        LevelSelection = HandlePtr->kOverrideActiveLevel;
      }
      else if(HandlePtr->kEvent1Function == PWMSP003_EXTERNAL_GATING)
10001fdc:	2908      	cmp	r1, #8
10001fde:	d102      	bne.n	10001fe6 <PWMSP003_lInit+0x12e>
      {
        LevelSelection = HandlePtr->kGateEventActiveLevel;
10001fe0:	1c10      	adds	r0, r2, #0
10001fe2:	303e      	adds	r0, #62	; 0x3e
10001fe4:	7800      	ldrb	r0, [r0, #0]
      else
      {
        /** */
      }

      WR_REG(HandlePtr->CC4yRegsPtr->INS, (uint32_t)CCU4_CC4_INS_EV1EM_Msk,\
10001fe6:	681e      	ldr	r6, [r3, #0]
10001fe8:	04bf      	lsls	r7, r7, #18
10001fea:	46b4      	mov	ip, r6
10001fec:	26c0      	movs	r6, #192	; 0xc0
10001fee:	0336      	lsls	r6, r6, #12
10001ff0:	403e      	ands	r6, r7
10001ff2:	4f4c      	ldr	r7, [pc, #304]	; (10002124 <PWMSP003_lInit+0x26c>)
10001ff4:	9602      	str	r6, [sp, #8]
10001ff6:	4666      	mov	r6, ip
10001ff8:	4037      	ands	r7, r6
10001ffa:	9e02      	ldr	r6, [sp, #8]
               (uint32_t)CCU4_CC4_INS_EV1EM_Pos, (uint32_t)EdgeSelection);

      WR_REG(HandlePtr->CC4yRegsPtr->INS, (uint32_t)CCU4_CC4_INS_EV1LM_Msk,\
10001ffc:	05c0      	lsls	r0, r0, #23
      else
      {
        /** */
      }

      WR_REG(HandlePtr->CC4yRegsPtr->INS, (uint32_t)CCU4_CC4_INS_EV1EM_Msk,\
10001ffe:	4337      	orrs	r7, r6
10002000:	601f      	str	r7, [r3, #0]
               (uint32_t)CCU4_CC4_INS_EV1EM_Pos, (uint32_t)EdgeSelection);

      WR_REG(HandlePtr->CC4yRegsPtr->INS, (uint32_t)CCU4_CC4_INS_EV1LM_Msk,\
10002002:	2780      	movs	r7, #128	; 0x80
10002004:	043f      	lsls	r7, r7, #16
10002006:	681e      	ldr	r6, [r3, #0]
10002008:	4038      	ands	r0, r7
1000200a:	4f47      	ldr	r7, [pc, #284]	; (10002128 <PWMSP003_lInit+0x270>)
1000200c:	403e      	ands	r6, r7
1000200e:	4330      	orrs	r0, r6
               (uint32_t)CCU4_CC4_INS_EV1LM_Pos, (uint32_t)LevelSelection);

      WR_REG(HandlePtr->CC4yRegsPtr->INS, (uint32_t)CCU4_CC4_INS_LPF1M_Msk,\
10002010:	1c16      	adds	r6, r2, #0
      }

      WR_REG(HandlePtr->CC4yRegsPtr->INS, (uint32_t)CCU4_CC4_INS_EV1EM_Msk,\
               (uint32_t)CCU4_CC4_INS_EV1EM_Pos, (uint32_t)EdgeSelection);

      WR_REG(HandlePtr->CC4yRegsPtr->INS, (uint32_t)CCU4_CC4_INS_EV1LM_Msk,\
10002012:	6018      	str	r0, [r3, #0]
               (uint32_t)CCU4_CC4_INS_EV1LM_Pos, (uint32_t)LevelSelection);

      WR_REG(HandlePtr->CC4yRegsPtr->INS, (uint32_t)CCU4_CC4_INS_LPF1M_Msk,\
10002014:	3631      	adds	r6, #49	; 0x31
10002016:	7830      	ldrb	r0, [r6, #0]
10002018:	681f      	ldr	r7, [r3, #0]
1000201a:	06c6      	lsls	r6, r0, #27
1000201c:	20c0      	movs	r0, #192	; 0xc0
1000201e:	0540      	lsls	r0, r0, #21
10002020:	4030      	ands	r0, r6
10002022:	4e42      	ldr	r6, [pc, #264]	; (1000212c <PWMSP003_lInit+0x274>)
10002024:	403e      	ands	r6, r7
10002026:	4306      	orrs	r6, r0
10002028:	601e      	str	r6, [r3, #0]
               (uint32_t)CCU4_CC4_INS_LPF1M_Pos, HandlePtr->kEvent1_lpfconfig);

      if(HandlePtr->kEvent1Function != PWMSP003_EXTERNAL_START)
1000202a:	2c00      	cmp	r4, #0
1000202c:	d00b      	beq.n	10002046 <PWMSP003_lInit+0x18e>
      {
        /* Override Config in CMC Register is only one bit each */
        /* START/STOP etc. are 2 bits each */
        if(HandlePtr->kEvent1Function == PWMSP003_EXTERNAL_OVERRIDE)
1000202e:	2910      	cmp	r1, #16
10002030:	d100      	bne.n	10002034 <PWMSP003_lInit+0x17c>
10002032:	e14f      	b.n	100022d4 <PWMSP003_lInit+0x41c>
              (uint32_t)(CCU4_CC4_CMC_STRTS_Pos + HandlePtr->kEvent1Function),\
              0x01U);
        }
        else
        {
          WR_REG(HandlePtr->CC4yRegsPtr->CMC,\
10002034:	685c      	ldr	r4, [r3, #4]
10002036:	2703      	movs	r7, #3
10002038:	2002      	movs	r0, #2
1000203a:	408f      	lsls	r7, r1
1000203c:	4088      	lsls	r0, r1
1000203e:	43bc      	bics	r4, r7
10002040:	4007      	ands	r7, r0
10002042:	433c      	orrs	r4, r7
10002044:	605c      	str	r4, [r3, #4]

    /* Reset to default */
    EdgeSelection = PWMSP003_NO_TRIGGER;
    LevelSelection = PWMSP003_ACTIVE_ON_HIGH;

    if(HandlePtr->kEvent2Function != PWMSP003_NO_FUNCTION)
10002046:	1dd0      	adds	r0, r2, #7
10002048:	7fc4      	ldrb	r4, [r0, #31]
1000204a:	4e39      	ldr	r6, [pc, #228]	; (10002130 <PWMSP003_lInit+0x278>)
1000204c:	b261      	sxtb	r1, r4
1000204e:	46b4      	mov	ip, r6
10002050:	1c4e      	adds	r6, r1, #1
10002052:	d079      	beq.n	10002148 <PWMSP003_lInit+0x290>
    {
      if(HandlePtr->kEvent2Function == PWMSP003_EXTERNAL_START)
10002054:	2c00      	cmp	r4, #0
10002056:	d104      	bne.n	10002062 <PWMSP003_lInit+0x1aa>
      {
        EdgeSelection = HandlePtr->kStartEdge;
10002058:	1c17      	adds	r7, r2, #0
1000205a:	3743      	adds	r7, #67	; 0x43
1000205c:	783f      	ldrb	r7, [r7, #0]
      }
    }

    /* Reset to default */
    EdgeSelection = PWMSP003_NO_TRIGGER;
    LevelSelection = PWMSP003_ACTIVE_ON_HIGH;
1000205e:	1c20      	adds	r0, r4, #0
10002060:	e02b      	b.n	100020ba <PWMSP003_lInit+0x202>
    {
      if(HandlePtr->kEvent2Function == PWMSP003_EXTERNAL_START)
      {
        EdgeSelection = HandlePtr->kStartEdge;
      }
      else if(HandlePtr->kEvent2Function == PWMSP003_EXTERNAL_STOP)
10002062:	2902      	cmp	r1, #2
10002064:	d102      	bne.n	1000206c <PWMSP003_lInit+0x1b4>
      {
        EdgeSelection = HandlePtr->kStopEdge;
10002066:	1c16      	adds	r6, r2, #0
10002068:	3644      	adds	r6, #68	; 0x44
1000206a:	e008      	b.n	1000207e <PWMSP003_lInit+0x1c6>
      }
      else if(HandlePtr->kEvent2Function == PWMSP003_EXTERNAL_LOAD)
1000206c:	290c      	cmp	r1, #12
1000206e:	d102      	bne.n	10002076 <PWMSP003_lInit+0x1be>
      {
        EdgeSelection = HandlePtr->kLoadEventEdge;
10002070:	1c16      	adds	r6, r2, #0
10002072:	3640      	adds	r6, #64	; 0x40
10002074:	e003      	b.n	1000207e <PWMSP003_lInit+0x1c6>
      }
      else if(HandlePtr->kEvent2Function == PWMSP003_EXTERNAL_COUNT)
10002076:	290e      	cmp	r1, #14
10002078:	d103      	bne.n	10002082 <PWMSP003_lInit+0x1ca>
      {
        EdgeSelection = HandlePtr->kCountEventEdge;
1000207a:	1c16      	adds	r6, r2, #0
1000207c:	363f      	adds	r6, #63	; 0x3f
1000207e:	7837      	ldrb	r7, [r6, #0]
10002080:	e015      	b.n	100020ae <PWMSP003_lInit+0x1f6>
      else
      {
        EdgeSelection = PWMSP003_RISING_EDGE;
      }

      if(HandlePtr->kEvent2Function == PWMSP003_EXTERNAL_COUNT_DIRECTION)
10002082:	290a      	cmp	r1, #10
10002084:	d104      	bne.n	10002090 <PWMSP003_lInit+0x1d8>
      {
        LevelSelection = HandlePtr->kCntDirActiveLevel;
10002086:	1c10      	adds	r0, r2, #0
10002088:	3036      	adds	r0, #54	; 0x36
1000208a:	7800      	ldrb	r0, [r0, #0]
      {
        EdgeSelection = HandlePtr->kCountEventEdge;
      }
      else
      {
        EdgeSelection = PWMSP003_RISING_EDGE;
1000208c:	2701      	movs	r7, #1
1000208e:	e014      	b.n	100020ba <PWMSP003_lInit+0x202>
10002090:	2701      	movs	r7, #1

      if(HandlePtr->kEvent2Function == PWMSP003_EXTERNAL_COUNT_DIRECTION)
      {
        LevelSelection = HandlePtr->kCntDirActiveLevel;
      }
      else if(HandlePtr->kEvent2Function == PWMSP003_EXTERNAL_TRAP)
10002092:	2911      	cmp	r1, #17
10002094:	d101      	bne.n	1000209a <PWMSP003_lInit+0x1e2>
      {
        LevelSelection = HandlePtr->kTrapLevel;
10002096:	7c90      	ldrb	r0, [r2, #18]
10002098:	e00f      	b.n	100020ba <PWMSP003_lInit+0x202>
      }
      else if(HandlePtr->kEvent2Function == PWMSP003_EXTERNAL_MODULATION)
1000209a:	2912      	cmp	r1, #18
1000209c:	d102      	bne.n	100020a4 <PWMSP003_lInit+0x1ec>
      {
        LevelSelection = HandlePtr->kModulationActiveLevel;
1000209e:	1c10      	adds	r0, r2, #0
100020a0:	3033      	adds	r0, #51	; 0x33
100020a2:	e009      	b.n	100020b8 <PWMSP003_lInit+0x200>
      }
      else if(HandlePtr->kEvent2Function == PWMSP003_EXTERNAL_OVERRIDE)
100020a4:	2910      	cmp	r1, #16
100020a6:	d102      	bne.n	100020ae <PWMSP003_lInit+0x1f6>
      {
        LevelSelection = HandlePtr->kOverrideActiveLevel;
100020a8:	1c10      	adds	r0, r2, #0
100020aa:	3042      	adds	r0, #66	; 0x42
100020ac:	e004      	b.n	100020b8 <PWMSP003_lInit+0x200>
      }
    }

    /* Reset to default */
    EdgeSelection = PWMSP003_NO_TRIGGER;
    LevelSelection = PWMSP003_ACTIVE_ON_HIGH;
100020ae:	2000      	movs	r0, #0
      }
      else if(HandlePtr->kEvent2Function == PWMSP003_EXTERNAL_OVERRIDE)
      {
        LevelSelection = HandlePtr->kOverrideActiveLevel;
      }
      else if(HandlePtr->kEvent2Function == PWMSP003_EXTERNAL_GATING)
100020b0:	2908      	cmp	r1, #8
100020b2:	d102      	bne.n	100020ba <PWMSP003_lInit+0x202>
      {
        LevelSelection = HandlePtr->kGateEventActiveLevel;
100020b4:	1c10      	adds	r0, r2, #0
100020b6:	303e      	adds	r0, #62	; 0x3e
100020b8:	7800      	ldrb	r0, [r0, #0]
      else
      {
       /** */
      }

      WR_REG(HandlePtr->CC4yRegsPtr->INS, (uint32_t)CCU4_CC4_INS_EV2EM_Msk,\
100020ba:	681e      	ldr	r6, [r3, #0]
100020bc:	053f      	lsls	r7, r7, #20
100020be:	9602      	str	r6, [sp, #8]
100020c0:	26c0      	movs	r6, #192	; 0xc0
100020c2:	03b6      	lsls	r6, r6, #14
100020c4:	403e      	ands	r6, r7
100020c6:	9601      	str	r6, [sp, #4]
100020c8:	4f1a      	ldr	r7, [pc, #104]	; (10002134 <PWMSP003_lInit+0x27c>)
100020ca:	9e02      	ldr	r6, [sp, #8]
               (uint32_t)CCU4_CC4_INS_EV2EM_Pos, (uint32_t)EdgeSelection);

      WR_REG(HandlePtr->CC4yRegsPtr->INS, (uint32_t)CCU4_CC4_INS_EV2LM_Msk,\
100020cc:	0600      	lsls	r0, r0, #24
      else
      {
       /** */
      }

      WR_REG(HandlePtr->CC4yRegsPtr->INS, (uint32_t)CCU4_CC4_INS_EV2EM_Msk,\
100020ce:	4037      	ands	r7, r6
100020d0:	9e01      	ldr	r6, [sp, #4]
100020d2:	4337      	orrs	r7, r6
100020d4:	601f      	str	r7, [r3, #0]
               (uint32_t)CCU4_CC4_INS_EV2EM_Pos, (uint32_t)EdgeSelection);

      WR_REG(HandlePtr->CC4yRegsPtr->INS, (uint32_t)CCU4_CC4_INS_EV2LM_Msk,\
100020d6:	2780      	movs	r7, #128	; 0x80
100020d8:	681e      	ldr	r6, [r3, #0]
100020da:	047f      	lsls	r7, r7, #17
100020dc:	4038      	ands	r0, r7
100020de:	4667      	mov	r7, ip
100020e0:	403e      	ands	r6, r7
100020e2:	4330      	orrs	r0, r6
               (uint32_t)CCU4_CC4_INS_EV2LM_Pos, (uint32_t)LevelSelection);

      WR_REG(HandlePtr->CC4yRegsPtr->INS, (uint32_t)CCU4_CC4_INS_LPF2M_Msk,\
100020e4:	1c16      	adds	r6, r2, #0
      }

      WR_REG(HandlePtr->CC4yRegsPtr->INS, (uint32_t)CCU4_CC4_INS_EV2EM_Msk,\
               (uint32_t)CCU4_CC4_INS_EV2EM_Pos, (uint32_t)EdgeSelection);

      WR_REG(HandlePtr->CC4yRegsPtr->INS, (uint32_t)CCU4_CC4_INS_EV2LM_Msk,\
100020e6:	6018      	str	r0, [r3, #0]
               (uint32_t)CCU4_CC4_INS_EV2LM_Pos, (uint32_t)LevelSelection);

      WR_REG(HandlePtr->CC4yRegsPtr->INS, (uint32_t)CCU4_CC4_INS_LPF2M_Msk,\
100020e8:	3632      	adds	r6, #50	; 0x32
100020ea:	7830      	ldrb	r0, [r6, #0]
100020ec:	681f      	ldr	r7, [r3, #0]
100020ee:	0746      	lsls	r6, r0, #29
100020f0:	20c0      	movs	r0, #192	; 0xc0
100020f2:	05c0      	lsls	r0, r0, #23
100020f4:	4030      	ands	r0, r6
100020f6:	4e10      	ldr	r6, [pc, #64]	; (10002138 <PWMSP003_lInit+0x280>)
100020f8:	403e      	ands	r6, r7
100020fa:	4306      	orrs	r6, r0
100020fc:	601e      	str	r6, [r3, #0]
               (uint32_t)CCU4_CC4_INS_LPF2M_Pos, HandlePtr->kEvent2_lpfconfig);

      if(HandlePtr->kEvent2Function != PWMSP003_EXTERNAL_START)
100020fe:	2c00      	cmp	r4, #0
10002100:	d022      	beq.n	10002148 <PWMSP003_lInit+0x290>
      {
        /* Trap and Override Config in CMC Register is only one bit each */
        /* START/STOP etc. are 2 bits each */
        if(HandlePtr->kEvent2Function == PWMSP003_EXTERNAL_OVERRIDE)
10002102:	2910      	cmp	r1, #16
10002104:	d01a      	beq.n	1000213c <PWMSP003_lInit+0x284>
          Temp = PWMSP003_TRAPEVENT_BITMASK;
        }
        else
        {
          /* Mask for START,STOP etc. functions, 2 bits */
          Temp = PWMSP003_STARTEVENT_BITMASK;
10002106:	2703      	movs	r7, #3
        if(HandlePtr->kEvent2Function == PWMSP003_EXTERNAL_OVERRIDE)
        {
          /* Mask for Trap, 1 bit */
          Temp = PWMSP003_OVERRIDEEVENT_BITMASK;
        }
        else if(HandlePtr->kEvent2Function == PWMSP003_EXTERNAL_TRAP)
10002108:	2911      	cmp	r1, #17
1000210a:	d000      	beq.n	1000210e <PWMSP003_lInit+0x256>
1000210c:	e0e9      	b.n	100022e2 <PWMSP003_lInit+0x42a>
        {
          /* Mask for Trap, 1 bit */
          Temp = PWMSP003_TRAPEVENT_BITMASK;
1000210e:	2701      	movs	r7, #1
10002110:	e0e7      	b.n	100022e2 <PWMSP003_lInit+0x42a>
10002112:	46c0      	nop			; (mov r8, r8)
10002114:	fffcffff 	.word	0xfffcffff
10002118:	ffbfffff 	.word	0xffbfffff
1000211c:	f9ffffff 	.word	0xf9ffffff
10002120:	fffeffff 	.word	0xfffeffff
10002124:	fff3ffff 	.word	0xfff3ffff
10002128:	ff7fffff 	.word	0xff7fffff
1000212c:	e7ffffff 	.word	0xe7ffffff
10002130:	feffffff 	.word	0xfeffffff
10002134:	ffcfffff 	.word	0xffcfffff
10002138:	9fffffff 	.word	0x9fffffff
          Temp = PWMSP003_STARTEVENT_BITMASK;
        }

        if(HandlePtr->kEvent2Function == PWMSP003_EXTERNAL_OVERRIDE)
        {
          WR_REG(HandlePtr->CC4yRegsPtr->CMC,\
1000213c:	685e      	ldr	r6, [r3, #4]
1000213e:	2780      	movs	r7, #128	; 0x80
10002140:	402e      	ands	r6, r5
10002142:	027c      	lsls	r4, r7, #9
10002144:	4326      	orrs	r6, r4
10002146:	605e      	str	r6, [r3, #4]
        }
      }
    }

    /* Slice Timer Control */
    HandlePtr->CC4yRegsPtr->TC &= ~(CCU4_CC4_TC_TCM_Msk |\
10002148:	6958      	ldr	r0, [r3, #20]
1000214a:	496c      	ldr	r1, [pc, #432]	; (100022fc <PWMSP003_lInit+0x444>)
      CCU4_CC4_TC_TSSM_Msk | CCU4_CC4_TC_CMOD_Msk |\
        CCU4_CC4_TC_STRM_Msk | CCU4_CC4_TC_ENDM_Msk | CCU4_CC4_TC_DITHE_Msk);

    /* Timer control configurations */
    HandlePtr->CC4yRegsPtr->TC |= (((uint32_t)HandlePtr->CountingModeType <<\
1000214c:	1c17      	adds	r7, r2, #0
        }
      }
    }

    /* Slice Timer Control */
    HandlePtr->CC4yRegsPtr->TC &= ~(CCU4_CC4_TC_TCM_Msk |\
1000214e:	4001      	ands	r1, r0
10002150:	6159      	str	r1, [r3, #20]
      CCU4_CC4_TC_TSSM_Msk | CCU4_CC4_TC_CMOD_Msk |\
        CCU4_CC4_TC_STRM_Msk | CCU4_CC4_TC_ENDM_Msk | CCU4_CC4_TC_DITHE_Msk);

    /* Timer control configurations */
    HandlePtr->CC4yRegsPtr->TC |= (((uint32_t)HandlePtr->CountingModeType <<\
10002152:	3756      	adds	r7, #86	; 0x56
        CCU4_CC4_TC_TCM_Pos) & CCU4_CC4_TC_TCM_Msk) |\
10002154:	783c      	ldrb	r4, [r7, #0]
    HandlePtr->CC4yRegsPtr->TC &= ~(CCU4_CC4_TC_TCM_Msk |\
      CCU4_CC4_TC_TSSM_Msk | CCU4_CC4_TC_CMOD_Msk |\
        CCU4_CC4_TC_STRM_Msk | CCU4_CC4_TC_ENDM_Msk | CCU4_CC4_TC_DITHE_Msk);

    /* Timer control configurations */
    HandlePtr->CC4yRegsPtr->TC |= (((uint32_t)HandlePtr->CountingModeType <<\
10002156:	695e      	ldr	r6, [r3, #20]
        CCU4_CC4_TC_TCM_Pos) & CCU4_CC4_TC_TCM_Msk) |\
        (((uint32_t)HandlePtr->kTimerMode  << CCU4_CC4_TC_TSSM_Pos) &\
10002158:	7b10      	ldrb	r0, [r2, #12]
      CCU4_CC4_TC_TSSM_Msk | CCU4_CC4_TC_CMOD_Msk |\
        CCU4_CC4_TC_STRM_Msk | CCU4_CC4_TC_ENDM_Msk | CCU4_CC4_TC_DITHE_Msk);

    /* Timer control configurations */
    HandlePtr->CC4yRegsPtr->TC |= (((uint32_t)HandlePtr->CountingModeType <<\
        CCU4_CC4_TC_TCM_Pos) & CCU4_CC4_TC_TCM_Msk) |\
1000215a:	2101      	movs	r1, #1
1000215c:	400c      	ands	r4, r1
        (((uint32_t)HandlePtr->kTimerMode  << CCU4_CC4_TC_TSSM_Pos) &\
        CCU4_CC4_TC_TSSM_Msk)|(((uint32_t)PWMSP003_COMPARE_MODE <<\
1000215e:	4334      	orrs	r4, r6
        CCU4_CC4_TC_STRM_Msk | CCU4_CC4_TC_ENDM_Msk | CCU4_CC4_TC_DITHE_Msk);

    /* Timer control configurations */
    HandlePtr->CC4yRegsPtr->TC |= (((uint32_t)HandlePtr->CountingModeType <<\
        CCU4_CC4_TC_TCM_Pos) & CCU4_CC4_TC_TCM_Msk) |\
        (((uint32_t)HandlePtr->kTimerMode  << CCU4_CC4_TC_TSSM_Pos) &\
10002160:	4088      	lsls	r0, r1
10002162:	2602      	movs	r6, #2
        CCU4_CC4_TC_TSSM_Msk)|(((uint32_t)PWMSP003_COMPARE_MODE <<\
        CCU4_CC4_TC_CMOD_Pos)& CCU4_CC4_TC_CMOD_Msk) |\
        (((uint32_t)HandlePtr->ExtStartConfigType <<CCU4_CC4_TC_STRM_Pos) &\
10002164:	1c17      	adds	r7, r2, #0
        CCU4_CC4_TC_STRM_Msk | CCU4_CC4_TC_ENDM_Msk | CCU4_CC4_TC_DITHE_Msk);

    /* Timer control configurations */
    HandlePtr->CC4yRegsPtr->TC |= (((uint32_t)HandlePtr->CountingModeType <<\
        CCU4_CC4_TC_TCM_Pos) & CCU4_CC4_TC_TCM_Msk) |\
        (((uint32_t)HandlePtr->kTimerMode  << CCU4_CC4_TC_TSSM_Pos) &\
10002166:	4030      	ands	r0, r6
        CCU4_CC4_TC_TSSM_Msk)|(((uint32_t)PWMSP003_COMPARE_MODE <<\
        CCU4_CC4_TC_CMOD_Pos)& CCU4_CC4_TC_CMOD_Msk) |\
        (((uint32_t)HandlePtr->ExtStartConfigType <<CCU4_CC4_TC_STRM_Pos) &\
10002168:	3754      	adds	r7, #84	; 0x54
    /* Timer control configurations */
    HandlePtr->CC4yRegsPtr->TC |= (((uint32_t)HandlePtr->CountingModeType <<\
        CCU4_CC4_TC_TCM_Pos) & CCU4_CC4_TC_TCM_Msk) |\
        (((uint32_t)HandlePtr->kTimerMode  << CCU4_CC4_TC_TSSM_Pos) &\
        CCU4_CC4_TC_TSSM_Msk)|(((uint32_t)PWMSP003_COMPARE_MODE <<\
        CCU4_CC4_TC_CMOD_Pos)& CCU4_CC4_TC_CMOD_Msk) |\
1000216a:	4320      	orrs	r0, r4
        (((uint32_t)HandlePtr->ExtStartConfigType <<CCU4_CC4_TC_STRM_Pos) &\
1000216c:	783c      	ldrb	r4, [r7, #0]
1000216e:	2180      	movs	r1, #128	; 0x80
10002170:	02a7      	lsls	r7, r4, #10
10002172:	00c9      	lsls	r1, r1, #3
10002174:	4039      	ands	r1, r7
        CCU4_CC4_TC_STRM_Msk)|(((uint32_t)HandlePtr->ExtStopConfigType <<\
10002176:	4301      	orrs	r1, r0
10002178:	1c10      	adds	r0, r2, #0
1000217a:	3055      	adds	r0, #85	; 0x55
1000217c:	7804      	ldrb	r4, [r0, #0]
        CCU4_CC4_TC_ENDM_Pos)& CCU4_CC4_TC_ENDM_Msk);
1000217e:	20c0      	movs	r0, #192	; 0xc0
        CCU4_CC4_TC_TCM_Pos) & CCU4_CC4_TC_TCM_Msk) |\
        (((uint32_t)HandlePtr->kTimerMode  << CCU4_CC4_TC_TSSM_Pos) &\
        CCU4_CC4_TC_TSSM_Msk)|(((uint32_t)PWMSP003_COMPARE_MODE <<\
        CCU4_CC4_TC_CMOD_Pos)& CCU4_CC4_TC_CMOD_Msk) |\
        (((uint32_t)HandlePtr->ExtStartConfigType <<CCU4_CC4_TC_STRM_Pos) &\
        CCU4_CC4_TC_STRM_Msk)|(((uint32_t)HandlePtr->ExtStopConfigType <<\
10002180:	0227      	lsls	r7, r4, #8
        CCU4_CC4_TC_ENDM_Pos)& CCU4_CC4_TC_ENDM_Msk);
10002182:	40b0      	lsls	r0, r6
10002184:	4038      	ands	r0, r7
    HandlePtr->CC4yRegsPtr->TC &= ~(CCU4_CC4_TC_TCM_Msk |\
      CCU4_CC4_TC_TSSM_Msk | CCU4_CC4_TC_CMOD_Msk |\
        CCU4_CC4_TC_STRM_Msk | CCU4_CC4_TC_ENDM_Msk | CCU4_CC4_TC_DITHE_Msk);

    /* Timer control configurations */
    HandlePtr->CC4yRegsPtr->TC |= (((uint32_t)HandlePtr->CountingModeType <<\
10002186:	4301      	orrs	r1, r0
10002188:	6159      	str	r1, [r3, #20]
        (((uint32_t)HandlePtr->ExtStartConfigType <<CCU4_CC4_TC_STRM_Pos) &\
        CCU4_CC4_TC_STRM_Msk)|(((uint32_t)HandlePtr->ExtStopConfigType <<\
        CCU4_CC4_TC_ENDM_Pos)& CCU4_CC4_TC_ENDM_Msk);

    /*Set the dither mode setting*/
    WR_REG(HandlePtr->CC4yRegsPtr->TC,(uint32_t)CCU4_CC4_TC_DITHE_Msk,\
1000218a:	1c51      	adds	r1, r2, #1
1000218c:	7fcc      	ldrb	r4, [r1, #31]
1000218e:	695e      	ldr	r6, [r3, #20]
10002190:	0367      	lsls	r7, r4, #13
10002192:	20c0      	movs	r0, #192	; 0xc0
10002194:	4c5a      	ldr	r4, [pc, #360]	; (10002300 <PWMSP003_lInit+0x448>)
10002196:	01c1      	lsls	r1, r0, #7
10002198:	4034      	ands	r4, r6
1000219a:	4039      	ands	r1, r7
1000219c:	4321      	orrs	r1, r4
1000219e:	6159      	str	r1, [r3, #20]
      (uint32_t)CCU4_CC4_TC_DITHE_Pos, HandlePtr->kDitherSetting);

    /* Set the floating point prescaler mode */
    WR_REG(HandlePtr->CC4yRegsPtr->TC,(uint32_t)CCU4_CC4_TC_FPE_Msk,\
100021a0:	1d16      	adds	r6, r2, #4
100021a2:	7ff0      	ldrb	r0, [r6, #31]
100021a4:	695f      	ldr	r7, [r3, #20]
100021a6:	2480      	movs	r4, #128	; 0x80
100021a8:	0401      	lsls	r1, r0, #16
100021aa:	0266      	lsls	r6, r4, #9
100021ac:	403d      	ands	r5, r7
100021ae:	400e      	ands	r6, r1
100021b0:	432e      	orrs	r6, r5
100021b2:	615e      	str	r6, [r3, #20]
      (uint32_t)CCU4_CC4_TC_FPE_Pos, HandlePtr->kPrescalerMode);

    WR_REG(HandlePtr->CC4yRegsPtr->DITS,(uint32_t)CCU4_CC4_DITS_DCVS_Msk,\
100021b4:	6a1f      	ldr	r7, [r3, #32]
100021b6:	7b55      	ldrb	r5, [r2, #13]
100021b8:	210f      	movs	r1, #15
100021ba:	400d      	ands	r5, r1
100021bc:	438f      	bics	r7, r1
100021be:	432f      	orrs	r7, r5
100021c0:	621f      	str	r7, [r3, #32]
      (uint32_t)CCU4_CC4_DITS_DCVS_Pos, HandlePtr->kDitherCompare);

    /* Configure Trap mode */
    WR_REG(HandlePtr->CC4yRegsPtr->TC, (uint32_t)CCU4_CC4_TC_TRPSE_Msk,\
100021c2:	7cd4      	ldrb	r4, [r2, #19]
100021c4:	2580      	movs	r5, #128	; 0x80
100021c6:	0567      	lsls	r7, r4, #21
100021c8:	03ac      	lsls	r4, r5, #14
100021ca:	695e      	ldr	r6, [r3, #20]
100021cc:	403c      	ands	r4, r7
100021ce:	4f4d      	ldr	r7, [pc, #308]	; (10002304 <PWMSP003_lInit+0x44c>)
          (uint32_t)CCU4_CC4_TC_TRPSE_Pos, HandlePtr->kTrapSync);

    /* Configure Trap exit mode */
    WR_REG(HandlePtr->CC4yRegsPtr->TC, (uint32_t)CCU4_CC4_TC_TRPSW_Msk,\
100021d0:	2580      	movs	r5, #128	; 0x80

    WR_REG(HandlePtr->CC4yRegsPtr->DITS,(uint32_t)CCU4_CC4_DITS_DCVS_Msk,\
      (uint32_t)CCU4_CC4_DITS_DCVS_Pos, HandlePtr->kDitherCompare);

    /* Configure Trap mode */
    WR_REG(HandlePtr->CC4yRegsPtr->TC, (uint32_t)CCU4_CC4_TC_TRPSE_Msk,\
100021d2:	4037      	ands	r7, r6
100021d4:	4327      	orrs	r7, r4
100021d6:	615f      	str	r7, [r3, #20]
          (uint32_t)CCU4_CC4_TC_TRPSE_Pos, HandlePtr->kTrapSync);

    /* Configure Trap exit mode */
    WR_REG(HandlePtr->CC4yRegsPtr->TC, (uint32_t)CCU4_CC4_TC_TRPSW_Msk,\
100021d8:	7d16      	ldrb	r6, [r2, #20]
100021da:	695c      	ldr	r4, [r3, #20]
100021dc:	05b7      	lsls	r7, r6, #22
100021de:	4e4a      	ldr	r6, [pc, #296]	; (10002308 <PWMSP003_lInit+0x450>)
100021e0:	408d      	lsls	r5, r1
100021e2:	4034      	ands	r4, r6
100021e4:	403d      	ands	r5, r7
100021e6:	4325      	orrs	r5, r4
          (uint32_t)CCU4_CC4_TC_TRPSW_Pos, HandlePtr->kTrapExitControl);

    /* External modulation sync  */
    WR_REG(HandlePtr->CC4yRegsPtr->TC, (uint32_t)CCU4_CC4_TC_EMS_Msk,\
100021e8:	1c17      	adds	r7, r2, #0
    /* Configure Trap mode */
    WR_REG(HandlePtr->CC4yRegsPtr->TC, (uint32_t)CCU4_CC4_TC_TRPSE_Msk,\
          (uint32_t)CCU4_CC4_TC_TRPSE_Pos, HandlePtr->kTrapSync);

    /* Configure Trap exit mode */
    WR_REG(HandlePtr->CC4yRegsPtr->TC, (uint32_t)CCU4_CC4_TC_TRPSW_Msk,\
100021ea:	615d      	str	r5, [r3, #20]
          (uint32_t)CCU4_CC4_TC_TRPSW_Pos, HandlePtr->kTrapExitControl);

    /* External modulation sync  */
    WR_REG(HandlePtr->CC4yRegsPtr->TC, (uint32_t)CCU4_CC4_TC_EMS_Msk,\
100021ec:	3735      	adds	r7, #53	; 0x35
100021ee:	783d      	ldrb	r5, [r7, #0]
100021f0:	2780      	movs	r7, #128	; 0x80
100021f2:	05ee      	lsls	r6, r5, #23
100021f4:	043d      	lsls	r5, r7, #16
100021f6:	695c      	ldr	r4, [r3, #20]
100021f8:	4035      	ands	r5, r6
100021fa:	4e44      	ldr	r6, [pc, #272]	; (1000230c <PWMSP003_lInit+0x454>)
100021fc:	4034      	ands	r4, r6
100021fe:	4325      	orrs	r5, r4
          (uint32_t)CCU4_CC4_TC_EMS_Pos, HandlePtr->kModulationSync);

    /* External modulation type  */
    WR_REG(HandlePtr->CC4yRegsPtr->TC, (uint32_t)CCU4_CC4_TC_EMT_Msk,\
10002200:	1c14      	adds	r4, r2, #0
    /* Configure Trap exit mode */
    WR_REG(HandlePtr->CC4yRegsPtr->TC, (uint32_t)CCU4_CC4_TC_TRPSW_Msk,\
          (uint32_t)CCU4_CC4_TC_TRPSW_Pos, HandlePtr->kTrapExitControl);

    /* External modulation sync  */
    WR_REG(HandlePtr->CC4yRegsPtr->TC, (uint32_t)CCU4_CC4_TC_EMS_Msk,\
10002202:	615d      	str	r5, [r3, #20]
          (uint32_t)CCU4_CC4_TC_EMS_Pos, HandlePtr->kModulationSync);

    /* External modulation type  */
    WR_REG(HandlePtr->CC4yRegsPtr->TC, (uint32_t)CCU4_CC4_TC_EMT_Msk,\
10002204:	3434      	adds	r4, #52	; 0x34
10002206:	7825      	ldrb	r5, [r4, #0]
10002208:	2480      	movs	r4, #128	; 0x80
1000220a:	695f      	ldr	r7, [r3, #20]
1000220c:	062e      	lsls	r6, r5, #24
1000220e:	0465      	lsls	r5, r4, #17
10002210:	4035      	ands	r5, r6
10002212:	4666      	mov	r6, ip
10002214:	4037      	ands	r7, r6
10002216:	433d      	orrs	r5, r7
10002218:	615d      	str	r5, [r3, #20]
          (uint32_t)CCU4_CC4_TC_EMT_Pos, HandlePtr->kModulationMode);

    /* Set the prescaler divider and passive level of the o/p signal */
    WR_REG(HandlePtr->CC4yRegsPtr->PSC, (uint32_t)CCU4_CC4_PSC_PSIV_Msk,\
1000221a:	6a5f      	ldr	r7, [r3, #36]	; 0x24
1000221c:	1c94      	adds	r4, r2, #2
1000221e:	7fe5      	ldrb	r5, [r4, #31]
10002220:	438f      	bics	r7, r1
10002222:	400d      	ands	r5, r1
10002224:	1c39      	adds	r1, r7, #0
10002226:	4329      	orrs	r1, r5
10002228:	6259      	str	r1, [r3, #36]	; 0x24
      (uint32_t)CCU4_CC4_PSC_PSIV_Pos, HandlePtr->kCCUPrescaler);

    /* if Selected prescaler is Floating Prescaler, set FP register */
    if(HandlePtr->kPrescalerMode ==
1000222a:	2801      	cmp	r0, #1
1000222c:	d102      	bne.n	10002234 <PWMSP003_lInit+0x37c>
                        (PWMSP003_PrescalerModeType)PWMSP003_FLOATING_PRESCALER)
    {
      HandlePtr->CC4yRegsPtr->FPCS =\
                        (uint32_t)HandlePtr->kFloatingPrescalepcmpvalue;
1000222e:	1cd0      	adds	r0, r2, #3
10002230:	7fc6      	ldrb	r6, [r0, #31]

    /* if Selected prescaler is Floating Prescaler, set FP register */
    if(HandlePtr->kPrescalerMode ==
                        (PWMSP003_PrescalerModeType)PWMSP003_FLOATING_PRESCALER)
    {
      HandlePtr->CC4yRegsPtr->FPCS =\
10002232:	62de      	str	r6, [r3, #44]	; 0x2c
                        (uint32_t)HandlePtr->kFloatingPrescalepcmpvalue;
    }
    HandlePtr->CC4yRegsPtr->PSL = HandlePtr->kPassiveLevel;

    /* Setting period register's value */
    HandlePtr->CC4yRegsPtr->PRS = (uint32_t)(HandlePtr->kPeriodVal & 0xFFFFU);
10002234:	2448      	movs	r4, #72	; 0x48
                        (PWMSP003_PrescalerModeType)PWMSP003_FLOATING_PRESCALER)
    {
      HandlePtr->CC4yRegsPtr->FPCS =\
                        (uint32_t)HandlePtr->kFloatingPrescalepcmpvalue;
    }
    HandlePtr->CC4yRegsPtr->PSL = HandlePtr->kPassiveLevel;
10002236:	7c17      	ldrb	r7, [r2, #16]

    /* Setting period register's value */
    HandlePtr->CC4yRegsPtr->PRS = (uint32_t)(HandlePtr->kPeriodVal & 0xFFFFU);
10002238:	5aa5      	ldrh	r5, [r4, r2]
    /*Setting compare register's value*/
    HandlePtr->CC4yRegsPtr->CRS = (uint32_t)(HandlePtr->kCompareValue &0xFFFFU);
1000223a:	8911      	ldrh	r1, [r2, #8]
    HandlePtr->CC4yRegsPtr->SWR |= PWMSP003_ALL_CCU4_INTR_CLEAR;
1000223c:	1c1e      	adds	r6, r3, #0
                        (PWMSP003_PrescalerModeType)PWMSP003_FLOATING_PRESCALER)
    {
      HandlePtr->CC4yRegsPtr->FPCS =\
                        (uint32_t)HandlePtr->kFloatingPrescalepcmpvalue;
    }
    HandlePtr->CC4yRegsPtr->PSL = HandlePtr->kPassiveLevel;
1000223e:	619f      	str	r7, [r3, #24]

    /* Setting period register's value */
    HandlePtr->CC4yRegsPtr->PRS = (uint32_t)(HandlePtr->kPeriodVal & 0xFFFFU);
    /*Setting compare register's value*/
    HandlePtr->CC4yRegsPtr->CRS = (uint32_t)(HandlePtr->kCompareValue &0xFFFFU);
    HandlePtr->CC4yRegsPtr->SWR |= PWMSP003_ALL_CCU4_INTR_CLEAR;
10002240:	36b0      	adds	r6, #176	; 0xb0
                        (uint32_t)HandlePtr->kFloatingPrescalepcmpvalue;
    }
    HandlePtr->CC4yRegsPtr->PSL = HandlePtr->kPassiveLevel;

    /* Setting period register's value */
    HandlePtr->CC4yRegsPtr->PRS = (uint32_t)(HandlePtr->kPeriodVal & 0xFFFFU);
10002242:	635d      	str	r5, [r3, #52]	; 0x34
    /*Setting compare register's value*/
    HandlePtr->CC4yRegsPtr->CRS = (uint32_t)(HandlePtr->kCompareValue &0xFFFFU);
10002244:	63d9      	str	r1, [r3, #60]	; 0x3c
    HandlePtr->CC4yRegsPtr->SWR |= PWMSP003_ALL_CCU4_INTR_CLEAR;
10002246:	6830      	ldr	r0, [r6, #0]
10002248:	4f31      	ldr	r7, [pc, #196]	; (10002310 <PWMSP003_lInit+0x458>)

    /* Applying Interrupt settings */
    HandlePtr->CC4yRegsPtr->INTE |= HandlePtr->InterruptControl;
1000224a:	6d14      	ldr	r4, [r2, #80]	; 0x50

    /* Setting period register's value */
    HandlePtr->CC4yRegsPtr->PRS = (uint32_t)(HandlePtr->kPeriodVal & 0xFFFFU);
    /*Setting compare register's value*/
    HandlePtr->CC4yRegsPtr->CRS = (uint32_t)(HandlePtr->kCompareValue &0xFFFFU);
    HandlePtr->CC4yRegsPtr->SWR |= PWMSP003_ALL_CCU4_INTR_CLEAR;
1000224c:	4338      	orrs	r0, r7
1000224e:	6030      	str	r0, [r6, #0]

    /* Applying Interrupt settings */
    HandlePtr->CC4yRegsPtr->INTE |= HandlePtr->InterruptControl;
10002250:	3e0c      	subs	r6, #12
10002252:	6835      	ldr	r5, [r6, #0]

    /* Request SW shadow transfer for period, compare, dither and prescaler */
    HandlePtr->CC4yKernRegsPtr->GCSS |=\
    (((uint32_t)0x1U << (PWMSP003_NO_OF_SLICES * (uint32_t)HandlePtr->Slice)) |\
10002254:	1c10      	adds	r0, r2, #0
    /*Setting compare register's value*/
    HandlePtr->CC4yRegsPtr->CRS = (uint32_t)(HandlePtr->kCompareValue &0xFFFFU);
    HandlePtr->CC4yRegsPtr->SWR |= PWMSP003_ALL_CCU4_INTR_CLEAR;

    /* Applying Interrupt settings */
    HandlePtr->CC4yRegsPtr->INTE |= HandlePtr->InterruptControl;
10002256:	4325      	orrs	r5, r4
10002258:	6035      	str	r5, [r6, #0]

    /* Request SW shadow transfer for period, compare, dither and prescaler */
    HandlePtr->CC4yKernRegsPtr->GCSS |=\
    (((uint32_t)0x1U << (PWMSP003_NO_OF_SLICES * (uint32_t)HandlePtr->Slice)) |\
1000225a:	3058      	adds	r0, #88	; 0x58

    /* Applying Interrupt settings */
    HandlePtr->CC4yRegsPtr->INTE |= HandlePtr->InterruptControl;

    /* Request SW shadow transfer for period, compare, dither and prescaler */
    HandlePtr->CC4yKernRegsPtr->GCSS |=\
1000225c:	6991      	ldr	r1, [r2, #24]
    (((uint32_t)0x1U << (PWMSP003_NO_OF_SLICES * (uint32_t)HandlePtr->Slice)) |\
1000225e:	7804      	ldrb	r4, [r0, #0]
10002260:	2001      	movs	r0, #1

    /* Applying Interrupt settings */
    HandlePtr->CC4yRegsPtr->INTE |= HandlePtr->InterruptControl;

    /* Request SW shadow transfer for period, compare, dither and prescaler */
    HandlePtr->CC4yKernRegsPtr->GCSS |=\
10002262:	690e      	ldr	r6, [r1, #16]
    (((uint32_t)0x1U << (PWMSP003_NO_OF_SLICES * (uint32_t)HandlePtr->Slice)) |\
10002264:	00a5      	lsls	r5, r4, #2
10002266:	1c07      	adds	r7, r0, #0
10002268:	40af      	lsls	r7, r5
1000226a:	4337      	orrs	r7, r6
1000226c:	9702      	str	r7, [sp, #8]
    ((uint32_t)0x1U <<\
    ((PWMSP003_NO_OF_SLICES * (uint32_t)HandlePtr->Slice) + (uint32_t)0x1U)) |\
1000226e:	182e      	adds	r6, r5, r0
    HandlePtr->CC4yRegsPtr->INTE |= HandlePtr->InterruptControl;

    /* Request SW shadow transfer for period, compare, dither and prescaler */
    HandlePtr->CC4yKernRegsPtr->GCSS |=\
    (((uint32_t)0x1U << (PWMSP003_NO_OF_SLICES * (uint32_t)HandlePtr->Slice)) |\
    ((uint32_t)0x1U <<\
10002270:	1c07      	adds	r7, r0, #0
10002272:	40b7      	lsls	r7, r6
10002274:	46bc      	mov	ip, r7
    ((PWMSP003_NO_OF_SLICES * (uint32_t)HandlePtr->Slice) + (uint32_t)0x1U)) |\
10002276:	9f02      	ldr	r7, [sp, #8]
10002278:	4666      	mov	r6, ip
1000227a:	4337      	orrs	r7, r6
    ((uint32_t)0x1U <<\
    ((PWMSP003_NO_OF_SLICES * (uint32_t)HandlePtr->Slice) + (uint32_t)0x2U)));
1000227c:	3502      	adds	r5, #2
    /* Request SW shadow transfer for period, compare, dither and prescaler */
    HandlePtr->CC4yKernRegsPtr->GCSS |=\
    (((uint32_t)0x1U << (PWMSP003_NO_OF_SLICES * (uint32_t)HandlePtr->Slice)) |\
    ((uint32_t)0x1U <<\
    ((PWMSP003_NO_OF_SLICES * (uint32_t)HandlePtr->Slice) + (uint32_t)0x1U)) |\
    ((uint32_t)0x1U <<\
1000227e:	1c06      	adds	r6, r0, #0
10002280:	40ae      	lsls	r6, r5

    /* Applying Interrupt settings */
    HandlePtr->CC4yRegsPtr->INTE |= HandlePtr->InterruptControl;

    /* Request SW shadow transfer for period, compare, dither and prescaler */
    HandlePtr->CC4yKernRegsPtr->GCSS |=\
10002282:	1c3d      	adds	r5, r7, #0
10002284:	4335      	orrs	r5, r6
    ((PWMSP003_NO_OF_SLICES * (uint32_t)HandlePtr->Slice) + (uint32_t)0x1U)) |\
    ((uint32_t)0x1U <<\
    ((PWMSP003_NO_OF_SLICES * (uint32_t)HandlePtr->Slice) + (uint32_t)0x2U)));

    /* Multi channel shadow transfer enable or disable */
    WR_REG(HandlePtr->CC4yRegsPtr->TC,  (uint32_t)CCU4_CC4_TC_MCME_Msk,\
10002286:	1c16      	adds	r6, r2, #0

    /* Applying Interrupt settings */
    HandlePtr->CC4yRegsPtr->INTE |= HandlePtr->InterruptControl;

    /* Request SW shadow transfer for period, compare, dither and prescaler */
    HandlePtr->CC4yKernRegsPtr->GCSS |=\
10002288:	610d      	str	r5, [r1, #16]
    ((PWMSP003_NO_OF_SLICES * (uint32_t)HandlePtr->Slice) + (uint32_t)0x1U)) |\
    ((uint32_t)0x1U <<\
    ((PWMSP003_NO_OF_SLICES * (uint32_t)HandlePtr->Slice) + (uint32_t)0x2U)));

    /* Multi channel shadow transfer enable or disable */
    WR_REG(HandlePtr->CC4yRegsPtr->TC,  (uint32_t)CCU4_CC4_TC_MCME_Msk,\
1000228a:	3637      	adds	r6, #55	; 0x37
1000228c:	7835      	ldrb	r5, [r6, #0]
1000228e:	695f      	ldr	r7, [r3, #20]
10002290:	066e      	lsls	r6, r5, #25
10002292:	2580      	movs	r5, #128	; 0x80
10002294:	04ad      	lsls	r5, r5, #18
10002296:	402e      	ands	r6, r5
10002298:	4d1e      	ldr	r5, [pc, #120]	; (10002314 <PWMSP003_lInit+0x45c>)
1000229a:	403d      	ands	r5, r7
1000229c:	4335      	orrs	r5, r6
                        (uint32_t)CCU4_CC4_TC_MCME_Pos, HandlePtr->kMCMode);

    /* Multi channel shadow transfer source select */
    WR_REG(HandlePtr->CC4yKernRegsPtr->GCTRL,
1000229e:	1c16      	adds	r6, r2, #0
    ((PWMSP003_NO_OF_SLICES * (uint32_t)HandlePtr->Slice) + (uint32_t)0x1U)) |\
    ((uint32_t)0x1U <<\
    ((PWMSP003_NO_OF_SLICES * (uint32_t)HandlePtr->Slice) + (uint32_t)0x2U)));

    /* Multi channel shadow transfer enable or disable */
    WR_REG(HandlePtr->CC4yRegsPtr->TC,  (uint32_t)CCU4_CC4_TC_MCME_Msk,\
100022a0:	615d      	str	r5, [r3, #20]
                        (uint32_t)CCU4_CC4_TC_MCME_Pos, HandlePtr->kMCMode);

    /* Multi channel shadow transfer source select */
    WR_REG(HandlePtr->CC4yKernRegsPtr->GCTRL,
100022a2:	3638      	adds	r6, #56	; 0x38
100022a4:	2380      	movs	r3, #128	; 0x80
100022a6:	00df      	lsls	r7, r3, #3
100022a8:	7833      	ldrb	r3, [r6, #0]
100022aa:	680d      	ldr	r5, [r1, #0]
100022ac:	40a7      	lsls	r7, r4
100022ae:	340a      	adds	r4, #10
100022b0:	40a3      	lsls	r3, r4
100022b2:	43bd      	bics	r5, r7
100022b4:	401f      	ands	r7, r3
100022b6:	432f      	orrs	r7, r5
100022b8:	600f      	str	r7, [r1, #0]
            (uint32_t)(CCU4_GCTRL_MSE0_Msk << HandlePtr->Slice),\
            (uint32_t)(CCU4_GCTRL_MSE0_Pos + HandlePtr->Slice),\
            (uint32_t)HandlePtr->kMCModeShadowRequest);

    /* Multi channel shadow transfer configuration */
    WR_REG(HandlePtr->CC4yKernRegsPtr->GCTRL,
100022ba:	3239      	adds	r2, #57	; 0x39
100022bc:	7812      	ldrb	r2, [r2, #0]
100022be:	680f      	ldr	r7, [r1, #0]
100022c0:	4b15      	ldr	r3, [pc, #84]	; (10002318 <PWMSP003_lInit+0x460>)
100022c2:	0795      	lsls	r5, r2, #30
100022c4:	0c2e      	lsrs	r6, r5, #16
100022c6:	403b      	ands	r3, r7
100022c8:	4333      	orrs	r3, r6
100022ca:	600b      	str	r3, [r1, #0]
              (uint32_t)CCU4_GCTRL_MSDE_Msk,\
            (uint32_t)CCU4_GCTRL_MSDE_Pos,
            (uint32_t)HandlePtr->kMCModeShadowConfig);

    Status = (uint32_t)DAVEApp_SUCCESS;
    HandlePtr->DynamicDataType->StateType = PWMSP003_INITIALIZED;
100022cc:	9903      	ldr	r1, [sp, #12]
100022ce:	7008      	strb	r0, [r1, #0]
    WR_REG(HandlePtr->CC4yKernRegsPtr->GCTRL,
              (uint32_t)CCU4_GCTRL_MSDE_Msk,\
            (uint32_t)CCU4_GCTRL_MSDE_Pos,
            (uint32_t)HandlePtr->kMCModeShadowConfig);

    Status = (uint32_t)DAVEApp_SUCCESS;
100022d0:	2000      	movs	r0, #0
100022d2:	e010      	b.n	100022f6 <PWMSP003_lInit+0x43e>
          Temp = PWMSP003_STARTEVENT_BITMASK;
        }

        if(HandlePtr->kEvent1Function == PWMSP003_EXTERNAL_OVERRIDE)
        {
          WR_REG(HandlePtr->CC4yRegsPtr->CMC,\
100022d4:	685e      	ldr	r6, [r3, #4]
100022d6:	2780      	movs	r7, #128	; 0x80
100022d8:	402e      	ands	r6, r5
100022da:	027c      	lsls	r4, r7, #9
100022dc:	4326      	orrs	r6, r4
100022de:	605e      	str	r6, [r3, #4]
100022e0:	e6b1      	b.n	10002046 <PWMSP003_lInit+0x18e>
              (uint32_t)(CCU4_CC4_CMC_STRTS_Pos + HandlePtr->kEvent2Function),\
              0x01U);
        }
        else
        {
          WR_REG(HandlePtr->CC4yRegsPtr->CMC,\
100022e2:	2003      	movs	r0, #3
100022e4:	685c      	ldr	r4, [r3, #4]
100022e6:	4088      	lsls	r0, r1
100022e8:	408f      	lsls	r7, r1
100022ea:	1c01      	adds	r1, r0, #0
100022ec:	43bc      	bics	r4, r7
100022ee:	4039      	ands	r1, r7
100022f0:	430c      	orrs	r4, r1
100022f2:	605c      	str	r4, [r3, #4]
100022f4:	e728      	b.n	10002148 <PWMSP003_lInit+0x290>
    Status = (uint32_t)DAVEApp_SUCCESS;
    HandlePtr->DynamicDataType->StateType = PWMSP003_INITIALIZED;
  } while (0);

  return Status;
}
100022f6:	b005      	add	sp, #20
100022f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
100022fa:	46c0      	nop			; (mov r8, r8)
100022fc:	ffff98f4 	.word	0xffff98f4
10002300:	ffff9fff 	.word	0xffff9fff
10002304:	ffdfffff 	.word	0xffdfffff
10002308:	ffbfffff 	.word	0xffbfffff
1000230c:	ff7fffff 	.word	0xff7fffff
10002310:	00000f0f 	.word	0x00000f0f
10002314:	fdffffff 	.word	0xfdffffff
10002318:	ffff3fff 	.word	0xffff3fff

1000231c <PWMSP003_Start>:
/**
 * This function starts the app.
 * This function should be called even if external start is configured.
 */
status_t PWMSP003_Start(const PWMSP003_HandleType* HandlePtr)
{
1000231c:	b5f0      	push	{r4, r5, r6, r7, lr}
  status_t Status = (uint32_t)PWMSP003_OPER_NOT_ALLOWED_ERROR;

  do
  {
    if((HandlePtr->DynamicDataType->StateType == PWMSP003_UNINITIALIZED) ||
1000231e:	6dc4      	ldr	r4, [r0, #92]	; 0x5c
/**
 * This function starts the app.
 * This function should be called even if external start is configured.
 */
status_t PWMSP003_Start(const PWMSP003_HandleType* HandlePtr)
{
10002320:	1c02      	adds	r2, r0, #0
  status_t Status = (uint32_t)PWMSP003_OPER_NOT_ALLOWED_ERROR;

  do
  {
    if((HandlePtr->DynamicDataType->StateType == PWMSP003_UNINITIALIZED) ||
10002322:	7823      	ldrb	r3, [r4, #0]
 * This function starts the app.
 * This function should be called even if external start is configured.
 */
status_t PWMSP003_Start(const PWMSP003_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)PWMSP003_OPER_NOT_ALLOWED_ERROR;
10002324:	2001      	movs	r0, #1

  do
  {
    if((HandlePtr->DynamicDataType->StateType == PWMSP003_UNINITIALIZED) ||
10002326:	2b00      	cmp	r3, #0
10002328:	d030      	beq.n	1000238c <PWMSP003_Start+0x70>
1000232a:	2b02      	cmp	r3, #2
1000232c:	d02e      	beq.n	1000238c <PWMSP003_Start+0x70>
       (HandlePtr->DynamicDataType->StateType == PWMSP003_RUNNING))
    {
      break;
    }

    HandlePtr->CC4yRegsPtr->SWR = PWMSP003_ALL_CCU4_INTR_CLEAR;
1000232e:	69d3      	ldr	r3, [r2, #28]
10002330:	4d17      	ldr	r5, [pc, #92]	; (10002390 <PWMSP003_Start+0x74>)
10002332:	1c19      	adds	r1, r3, #0
10002334:	31b0      	adds	r1, #176	; 0xb0
10002336:	600d      	str	r5, [r1, #0]

    /* Start the Prescaler */
    HandlePtr->CC4yKernRegsPtr->GIDLC |=\
10002338:	6991      	ldr	r1, [r2, #24]
1000233a:	2780      	movs	r7, #128	; 0x80
1000233c:	68ce      	ldr	r6, [r1, #12]
1000233e:	4087      	lsls	r7, r0
10002340:	4337      	orrs	r7, r6
            ((uint32_t)0x1U << ((uint32_t)CCU4_GIDLC_SPRB_Pos));

    /* Start the timer slice */
    HandlePtr->CC4yKernRegsPtr->GIDLC |=\
        ((uint32_t)0x1U << ((uint32_t)CCU4_GIDLC_CS0I_Pos +\
            (uint32_t)HandlePtr->Slice));
10002342:	1c15      	adds	r5, r2, #0
    }

    HandlePtr->CC4yRegsPtr->SWR = PWMSP003_ALL_CCU4_INTR_CLEAR;

    /* Start the Prescaler */
    HandlePtr->CC4yKernRegsPtr->GIDLC |=\
10002344:	60cf      	str	r7, [r1, #12]
            ((uint32_t)0x1U << ((uint32_t)CCU4_GIDLC_SPRB_Pos));

    /* Start the timer slice */
    HandlePtr->CC4yKernRegsPtr->GIDLC |=\
        ((uint32_t)0x1U << ((uint32_t)CCU4_GIDLC_CS0I_Pos +\
            (uint32_t)HandlePtr->Slice));
10002346:	3558      	adds	r5, #88	; 0x58
    HandlePtr->CC4yKernRegsPtr->GIDLC |=\
            ((uint32_t)0x1U << ((uint32_t)CCU4_GIDLC_SPRB_Pos));

    /* Start the timer slice */
    HandlePtr->CC4yKernRegsPtr->GIDLC |=\
        ((uint32_t)0x1U << ((uint32_t)CCU4_GIDLC_CS0I_Pos +\
10002348:	782d      	ldrb	r5, [r5, #0]
1000234a:	1c07      	adds	r7, r0, #0
    /* Start the Prescaler */
    HandlePtr->CC4yKernRegsPtr->GIDLC |=\
            ((uint32_t)0x1U << ((uint32_t)CCU4_GIDLC_SPRB_Pos));

    /* Start the timer slice */
    HandlePtr->CC4yKernRegsPtr->GIDLC |=\
1000234c:	68ce      	ldr	r6, [r1, #12]
        ((uint32_t)0x1U << ((uint32_t)CCU4_GIDLC_CS0I_Pos +\
1000234e:	40af      	lsls	r7, r5
10002350:	1c3d      	adds	r5, r7, #0
    /* Start the Prescaler */
    HandlePtr->CC4yKernRegsPtr->GIDLC |=\
            ((uint32_t)0x1U << ((uint32_t)CCU4_GIDLC_SPRB_Pos));

    /* Start the timer slice */
    HandlePtr->CC4yKernRegsPtr->GIDLC |=\
10002352:	4335      	orrs	r5, r6
10002354:	60cd      	str	r5, [r1, #12]
        ((uint32_t)0x1U << ((uint32_t)CCU4_GIDLC_CS0I_Pos +\
            (uint32_t)HandlePtr->Slice));

    WR_REG(HandlePtr->CC4yRegsPtr->TC, CCU4_CC4_TC_TRAPE_Msk,\
10002356:	7c51      	ldrb	r1, [r2, #17]
10002358:	2580      	movs	r5, #128	; 0x80
1000235a:	695e      	ldr	r6, [r3, #20]
1000235c:	044f      	lsls	r7, r1, #17
1000235e:	02a9      	lsls	r1, r5, #10
10002360:	4d0c      	ldr	r5, [pc, #48]	; (10002394 <PWMSP003_Start+0x78>)
10002362:	400f      	ands	r7, r1
10002364:	4035      	ands	r5, r6
10002366:	433d      	orrs	r5, r7
10002368:	615d      	str	r5, [r3, #20]
          (uint32_t)CCU4_CC4_TC_TRAPE_Pos, HandlePtr->kTrapEnable);

    /* Set run bit of slices if external start is not configured */
    if (HandlePtr->kStartEvent == PWMSP003_NO_EVENT)
1000236a:	3208      	adds	r2, #8
1000236c:	7fd6      	ldrb	r6, [r2, #31]
1000236e:	2e00      	cmp	r6, #0
10002370:	d103      	bne.n	1000237a <PWMSP003_Start+0x5e>
    {
      HandlePtr->CC4yRegsPtr->TCSET |= (uint32_t)0x1U;
10002372:	68d9      	ldr	r1, [r3, #12]
10002374:	4308      	orrs	r0, r1
10002376:	60d8      	str	r0, [r3, #12]
10002378:	e005      	b.n	10002386 <PWMSP003_Start+0x6a>
    }
    else
    {
      WR_REG(HandlePtr->CC4yRegsPtr->CMC,\
1000237a:	6858      	ldr	r0, [r3, #4]
1000237c:	2203      	movs	r2, #3
1000237e:	4016      	ands	r6, r2
10002380:	4390      	bics	r0, r2
10002382:	4306      	orrs	r6, r0
10002384:	605e      	str	r6, [r3, #4]
               (uint32_t)CCU4_CC4_CMC_STRTS_Msk,\
               (uint32_t)CCU4_CC4_CMC_STRTS_Pos,\
               HandlePtr->kStartEvent);
    }

    HandlePtr->DynamicDataType->StateType = PWMSP003_RUNNING;
10002386:	2302      	movs	r3, #2
10002388:	7023      	strb	r3, [r4, #0]
    Status = (uint32_t)DAVEApp_SUCCESS;
1000238a:	2000      	movs	r0, #0
  } while (0);

  return Status;
}
1000238c:	bdf0      	pop	{r4, r5, r6, r7, pc}
1000238e:	46c0      	nop			; (mov r8, r8)
10002390:	00000f0f 	.word	0x00000f0f
10002394:	fffdffff 	.word	0xfffdffff

10002398 <PWMSP003_Init>:

/**
 * This function initializes the app
 */
void PWMSP003_Init(void)
{
10002398:	b538      	push	{r3, r4, r5, lr}
1000239a:	2400      	movs	r4, #0
  status_t Error = (uint32_t)PWMSP003_OPER_NOT_ALLOWED_ERROR;
  uint8_t HandleNum;

  for(HandleNum = 0; HandleNum < PWMSP003_NUM_INSTANCES; HandleNum++)
  {
    Error = PWMSP003_lInit((PWMSP003_HandleType*)PWMSP003_HandleArr[HandleNum]);
1000239c:	4d08      	ldr	r5, [pc, #32]	; (100023c0 <PWMSP003_Init+0x28>)
1000239e:	1965      	adds	r5, r4, r5
100023a0:	6828      	ldr	r0, [r5, #0]
100023a2:	f7ff fd89 	bl	10001eb8 <PWMSP003_lInit>

    /* Start the app if "Start after initialization" is checked */
    if(Error == (uint32_t)DAVEApp_SUCCESS)
100023a6:	2800      	cmp	r0, #0
100023a8:	d105      	bne.n	100023b6 <PWMSP003_Init+0x1e>
    {
      if (PWMSP003_HandleArr[HandleNum]->StartControl == (uint8_t)SET)
100023aa:	6828      	ldr	r0, [r5, #0]
100023ac:	7803      	ldrb	r3, [r0, #0]
100023ae:	2b01      	cmp	r3, #1
100023b0:	d101      	bne.n	100023b6 <PWMSP003_Init+0x1e>
      {
        Error = PWMSP003_Start((PWMSP003_HandleType*)
100023b2:	f7ff ffb3 	bl	1000231c <PWMSP003_Start>
100023b6:	3404      	adds	r4, #4
void PWMSP003_Init(void)
{
  status_t Error = (uint32_t)PWMSP003_OPER_NOT_ALLOWED_ERROR;
  uint8_t HandleNum;

  for(HandleNum = 0; HandleNum < PWMSP003_NUM_INSTANCES; HandleNum++)
100023b8:	2c0c      	cmp	r4, #12
100023ba:	d1ef      	bne.n	1000239c <PWMSP003_Init+0x4>
        Error = PWMSP003_Start((PWMSP003_HandleType*)
                                            PWMSP003_HandleArr[HandleNum]);
      }
    }
  }
}
100023bc:	bd38      	pop	{r3, r4, r5, pc}
100023be:	46c0      	nop			; (mov r8, r8)
100023c0:	20000644 	.word	0x20000644

100023c4 <PWMSP003_UpdateCompare>:
/**
 * This function changes the compare register value.
 */
status_t PWMSP003_UpdateCompare(const PWMSP003_HandleType * HandlePtr,
                                uint32_t CompareVal, uint8_t Recall)
{
100023c4:	b530      	push	{r4, r5, lr}
100023c6:	1c03      	adds	r3, r0, #0
  status_t Status = (uint32_t)PWMSP003_OPER_NOT_ALLOWED_ERROR;
  uint32_t Temp1;

  if ((HandlePtr->DynamicDataType->StateType != PWMSP003_UNINITIALIZED))
100023c8:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
100023ca:	7804      	ldrb	r4, [r0, #0]
 * This function changes the compare register value.
 */
status_t PWMSP003_UpdateCompare(const PWMSP003_HandleType * HandlePtr,
                                uint32_t CompareVal, uint8_t Recall)
{
  status_t Status = (uint32_t)PWMSP003_OPER_NOT_ALLOWED_ERROR;
100023cc:	2001      	movs	r0, #1
  uint32_t Temp1;

  if ((HandlePtr->DynamicDataType->StateType != PWMSP003_UNINITIALIZED))
100023ce:	2c00      	cmp	r4, #0
100023d0:	d017      	beq.n	10002402 <PWMSP003_UpdateCompare+0x3e>
100023d2:	1c1d      	adds	r5, r3, #0
100023d4:	699c      	ldr	r4, [r3, #24]
100023d6:	3558      	adds	r5, #88	; 0x58
  {
    if(Recall != TRUE)
100023d8:	4282      	cmp	r2, r0
100023da:	d00a      	beq.n	100023f2 <PWMSP003_UpdateCompare+0x2e>
    {
      HandlePtr->CC4yRegsPtr->CRS = (CompareVal & 0xFFFFU);
100023dc:	69da      	ldr	r2, [r3, #28]
100023de:	b28b      	uxth	r3, r1
100023e0:	63d3      	str	r3, [r2, #60]	; 0x3c

      /*Request shadow transfer for the slice*/
      Temp1 = CCU4_GCSS_S0SE_Pos +\
                       (PWMSP003_NO_OF_SLICES * (uint32_t)HandlePtr->Slice);
100023e2:	782d      	ldrb	r5, [r5, #0]

      HandlePtr->CC4yKernRegsPtr->GCSS |=    ((uint32_t)0x01 << Temp1);
100023e4:	6921      	ldr	r1, [r4, #16]
    if(Recall != TRUE)
    {
      HandlePtr->CC4yRegsPtr->CRS = (CompareVal & 0xFFFFU);

      /*Request shadow transfer for the slice*/
      Temp1 = CCU4_GCSS_S0SE_Pos +\
100023e6:	00aa      	lsls	r2, r5, #2
                       (PWMSP003_NO_OF_SLICES * (uint32_t)HandlePtr->Slice);

      HandlePtr->CC4yKernRegsPtr->GCSS |=    ((uint32_t)0x01 << Temp1);
100023e8:	4090      	lsls	r0, r2
100023ea:	4308      	orrs	r0, r1
100023ec:	6120      	str	r0, [r4, #16]

      Status = (uint32_t)DAVEApp_SUCCESS;
100023ee:	2000      	movs	r0, #0
100023f0:	e007      	b.n	10002402 <PWMSP003_UpdateCompare+0x3e>

    else
    {
      /* Cancel any pending shadow transfer of the slice */
      Temp1 = CCU4_GCSC_S0SC_Pos +\
                      (PWMSP003_NO_OF_SLICES * (uint32_t)HandlePtr->Slice);
100023f2:	7829      	ldrb	r1, [r5, #0]

      HandlePtr->CC4yKernRegsPtr->GCSC |=  ((uint32_t)0x01 << Temp1);
100023f4:	1c05      	adds	r5, r0, #0
    }

    else
    {
      /* Cancel any pending shadow transfer of the slice */
      Temp1 = CCU4_GCSC_S0SC_Pos +\
100023f6:	008b      	lsls	r3, r1, #2
                      (PWMSP003_NO_OF_SLICES * (uint32_t)HandlePtr->Slice);

      HandlePtr->CC4yKernRegsPtr->GCSC |=  ((uint32_t)0x01 << Temp1);
100023f8:	6962      	ldr	r2, [r4, #20]
100023fa:	409d      	lsls	r5, r3
100023fc:	1c29      	adds	r1, r5, #0
100023fe:	4311      	orrs	r1, r2
10002400:	6161      	str	r1, [r4, #20]
    }
  }

  return Status;
}
10002402:	bd30      	pop	{r4, r5, pc}

10002404 <NVIC002_Init>:

/**  Function to initialize the NVIC node parameters based on 
 *  UI configuration.
 */
void NVIC002_Init(void)
{
10002404:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
10002406:	2300      	movs	r3, #0
  uint32_t Count;
  for (Count = 0U; Count<(uint32_t)NVIC002_NUM_INSTANCES; Count++)
  {
	  NVIC002_lInit(NVIC002_HandleArray[Count]);
10002408:	4a1e      	ldr	r2, [pc, #120]	; (10002484 <NVIC002_Init+0x80>)
1000240a:	58d2      	ldr	r2, [r2, r3]
static void NVIC002_lInit(const NVIC002_HandleType * Handle)
{
   /* Set Interrupt Priority for NVIC <%=NodeID%> 
      Node App Instance <%=appInst%>  */
	#if (UC_FAMILY == XMC1) 
	   NVIC_SetPriority((IRQn_Type)Handle->NodeID, 
1000240c:	7811      	ldrb	r1, [r2, #0]
1000240e:	7856      	ldrb	r6, [r2, #1]
    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
10002410:	b24c      	sxtb	r4, r1
10002412:	01b6      	lsls	r6, r6, #6
10002414:	2c00      	cmp	r4, #0
10002416:	da14      	bge.n	10002442 <NVIC002_Init+0x3e>
    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
10002418:	200f      	movs	r0, #15
1000241a:	4008      	ands	r0, r1
1000241c:	3808      	subs	r0, #8
1000241e:	0884      	lsrs	r4, r0, #2
10002420:	4f19      	ldr	r7, [pc, #100]	; (10002488 <NVIC002_Init+0x84>)
10002422:	00a5      	lsls	r5, r4, #2
10002424:	19e8      	adds	r0, r5, r7
10002426:	2503      	movs	r5, #3
10002428:	4029      	ands	r1, r5
1000242a:	40a9      	lsls	r1, r5
1000242c:	25ff      	movs	r5, #255	; 0xff
1000242e:	6844      	ldr	r4, [r0, #4]
10002430:	1c2f      	adds	r7, r5, #0
10002432:	408f      	lsls	r7, r1
10002434:	43bc      	bics	r4, r7
        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
10002436:	4035      	ands	r5, r6
10002438:	408d      	lsls	r5, r1
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
1000243a:	1c21      	adds	r1, r4, #0
1000243c:	4329      	orrs	r1, r5
1000243e:	6041      	str	r1, [r0, #4]
10002440:	e013      	b.n	1000246a <NVIC002_Init+0x66>
        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
  else {
    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
10002442:	08a5      	lsrs	r5, r4, #2
10002444:	4811      	ldr	r0, [pc, #68]	; (1000248c <NVIC002_Init+0x88>)
10002446:	35c0      	adds	r5, #192	; 0xc0
10002448:	00ac      	lsls	r4, r5, #2
1000244a:	2503      	movs	r5, #3
1000244c:	5827      	ldr	r7, [r4, r0]
1000244e:	4029      	ands	r1, r5
10002450:	40a9      	lsls	r1, r5
10002452:	25ff      	movs	r5, #255	; 0xff
10002454:	9701      	str	r7, [sp, #4]
10002456:	9100      	str	r1, [sp, #0]
10002458:	1c2f      	adds	r7, r5, #0
1000245a:	408f      	lsls	r7, r1
        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
1000245c:	4035      	ands	r5, r6
{
  if(IRQn < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
  else {
    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
1000245e:	9901      	ldr	r1, [sp, #4]
        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
10002460:	9e00      	ldr	r6, [sp, #0]
{
  if(IRQn < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
  else {
    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
10002462:	43b9      	bics	r1, r7
        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
10002464:	40b5      	lsls	r5, r6
{
  if(IRQn < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
  else {
    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
10002466:	4329      	orrs	r1, r5
10002468:	5021      	str	r1, [r4, r0]
	   NVIC_SetPriority((IRQn_Type)Handle->NodeID, 
			   	   	     NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
			   	   	     Handle->Priority,
			   	   	     Handle->SubPriority));
	#endif
	if(Handle->InterruptEnable == 1)
1000246a:	78d6      	ldrb	r6, [r2, #3]
1000246c:	2e01      	cmp	r6, #1
1000246e:	d105      	bne.n	1000247c <NVIC002_Init+0x78>

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
10002470:	7810      	ldrb	r0, [r2, #0]
10002472:	221f      	movs	r2, #31
10002474:	4002      	ands	r2, r0
10002476:	4c05      	ldr	r4, [pc, #20]	; (1000248c <NVIC002_Init+0x88>)
10002478:	4096      	lsls	r6, r2
1000247a:	6026      	str	r6, [r4, #0]
1000247c:	3304      	adds	r3, #4
 *  UI configuration.
 */
void NVIC002_Init(void)
{
  uint32_t Count;
  for (Count = 0U; Count<(uint32_t)NVIC002_NUM_INSTANCES; Count++)
1000247e:	2b0c      	cmp	r3, #12
10002480:	d1c2      	bne.n	10002408 <NVIC002_Init+0x4>
  {
	  NVIC002_lInit(NVIC002_HandleArray[Count]);
  }
}
10002482:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
10002484:	20000650 	.word	0x20000650
10002488:	e000ed18 	.word	0xe000ed18
1000248c:	e000e100 	.word	0xe000e100

10002490 <IO004_Init>:
   /* <<<DD_IO004_API_1>>> */

	   

  /* Configuration of 0 Port 13 based on User configuration */
  IO004_Handle0.PortRegs->OMR = 0U<< 13;
10002490:	4b05      	ldr	r3, [pc, #20]	; (100024a8 <IO004_Init+0x18>)
10002492:	2200      	movs	r2, #0
10002494:	6858      	ldr	r0, [r3, #4]
  
  IO004_Handle0.PortRegs->IOCR12 |= (0U << 11);   

  /* Configuration of 0 Port 0 based on User configuration */
  IO004_Handle1.PortRegs->OMR = 0U<< 0;
10002496:	4b05      	ldr	r3, [pc, #20]	; (100024ac <IO004_Init+0x1c>)
   /* <<<DD_IO004_API_1>>> */

	   

  /* Configuration of 0 Port 13 based on User configuration */
  IO004_Handle0.PortRegs->OMR = 0U<< 13;
10002498:	6042      	str	r2, [r0, #4]
  
  IO004_Handle0.PortRegs->IOCR12 |= (0U << 11);   
1000249a:	69c1      	ldr	r1, [r0, #28]
1000249c:	61c1      	str	r1, [r0, #28]

  /* Configuration of 0 Port 0 based on User configuration */
  IO004_Handle1.PortRegs->OMR = 0U<< 0;
1000249e:	6858      	ldr	r0, [r3, #4]
100024a0:	6042      	str	r2, [r0, #4]
  
  IO004_Handle1.PortRegs->IOCR0 |= (0U << 3);
100024a2:	6902      	ldr	r2, [r0, #16]
100024a4:	6102      	str	r2, [r0, #16]
}
100024a6:	4770      	bx	lr
100024a8:	10004214 	.word	0x10004214
100024ac:	1000420c 	.word	0x1000420c

100024b0 <IO002_Init>:

/* Function to configure Port Pins based on user configuration & Higher App 
 * configurations.
 */
void IO002_Init(void)
{
100024b0:	b570      	push	{r4, r5, r6, lr}
100024b2:	2100      	movs	r1, #0
	uint32_t i = (uint32_t)0;
	/*Initialize IO for number of instances*/
	for(; i < IO002_NUM_INSTANCES;i++ )
	{
		IO002_lInit(IO002_HandleArr[i]);
100024b4:	4b4a      	ldr	r3, [pc, #296]	; (100025e0 <IO002_Init+0x130>)
100024b6:	585b      	ldr	r3, [r3, r1]
{
	/*Get the port pin assigned for the particular instance of IO002 handle*/
	uint32_t Pin = handle->PortPin;
		
	/* Configuration of port pins based on User configuration */
	if(handle->IOCR_OE == 1U )
100024b8:	69d8      	ldr	r0, [r3, #28]
*The function initialises the provided instance of IO002 app.
*/
static void IO002_lInit(const IO002_HandleType * handle)
{
	/*Get the port pin assigned for the particular instance of IO002 handle*/
	uint32_t Pin = handle->PortPin;
100024ba:	785a      	ldrb	r2, [r3, #1]
		
	/* Configuration of port pins based on User configuration */
	if(handle->IOCR_OE == 1U )
100024bc:	2801      	cmp	r0, #1
100024be:	d103      	bne.n	100024c8 <IO002_Init+0x18>
	{
		handle->PortRegs->OMR = (handle->OMR_PS << Pin);
100024c0:	685d      	ldr	r5, [r3, #4]
100024c2:	6c1c      	ldr	r4, [r3, #64]	; 0x40
100024c4:	4095      	lsls	r5, r2
100024c6:	6065      	str	r5, [r4, #4]
	/*XMC 4 family specific initialisation*/
	IO002_XMC4_lInit(handle,Pin);
#endif

	/*Hardware control configuration*/
	if(handle->HW_SEL == 1U )
100024c8:	68de      	ldr	r6, [r3, #12]
100024ca:	2e01      	cmp	r6, #1
100024cc:	d105      	bne.n	100024da <IO002_Init+0x2a>
	{
		handle->PortRegs->HWSEL  |= ((uint32_t)2U << Pin);
100024ce:	6c1c      	ldr	r4, [r3, #64]	; 0x40
100024d0:	2502      	movs	r5, #2
100024d2:	6f66      	ldr	r6, [r4, #116]	; 0x74
100024d4:	4095      	lsls	r5, r2
100024d6:	4335      	orrs	r5, r6
100024d8:	6765      	str	r5, [r4, #116]	; 0x74
	}

	/*Check input/output control output enable is true*/
	if(handle->IOCR_OE == 1U )
100024da:	2801      	cmp	r0, #1
100024dc:	d123      	bne.n	10002526 <IO002_Init+0x76>

/*This function initialises the input/output control registers.*/
static void IO002_IOCR_OE_Enabled_lInit(const IO002_HandleType * handle,
		                                                      uint32_t Pin)
{
	if(Pin < 4U)
100024de:	2a03      	cmp	r2, #3
100024e0:	d805      	bhi.n	100024ee <IO002_Init+0x3e>
	{
		handle->PortRegs->IOCR0 |= (handle->IOCR << (3U+(Pin*8U)));
100024e2:	6c1d      	ldr	r5, [r3, #64]	; 0x40
100024e4:	00d2      	lsls	r2, r2, #3
100024e6:	6928      	ldr	r0, [r5, #16]
100024e8:	3203      	adds	r2, #3
100024ea:	6a5c      	ldr	r4, [r3, #36]	; 0x24
100024ec:	e049      	b.n	10002582 <IO002_Init+0xd2>
	}
	else if ((Pin >= 4U) && (Pin <= 7U))
100024ee:	1f16      	subs	r6, r2, #4
100024f0:	2e03      	cmp	r6, #3
100024f2:	d805      	bhi.n	10002500 <IO002_Init+0x50>
	{
		Pin = (Pin - 4U);
		handle->PortRegs->IOCR4 |= (handle->IOCR << (3U+(Pin*8U)));
100024f4:	6c1a      	ldr	r2, [r3, #64]	; 0x40
100024f6:	00f6      	lsls	r6, r6, #3
100024f8:	6954      	ldr	r4, [r2, #20]
100024fa:	3603      	adds	r6, #3
100024fc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
100024fe:	e04d      	b.n	1000259c <IO002_Init+0xec>
	}
	else if ((Pin >= 8U) && (Pin <= 11U))
10002500:	1c15      	adds	r5, r2, #0
10002502:	3d08      	subs	r5, #8
10002504:	2d03      	cmp	r5, #3
10002506:	d805      	bhi.n	10002514 <IO002_Init+0x64>
	{
		Pin = (Pin - 8U);
		handle->PortRegs->IOCR8 |= (handle->IOCR << (3U+(Pin*8U)));
10002508:	6c1e      	ldr	r6, [r3, #64]	; 0x40
1000250a:	00ed      	lsls	r5, r5, #3
1000250c:	69b4      	ldr	r4, [r6, #24]
1000250e:	3503      	adds	r5, #3
10002510:	6a58      	ldr	r0, [r3, #36]	; 0x24
10002512:	e051      	b.n	100025b8 <IO002_Init+0x108>
	}
	else if ((Pin >= 12U) && (Pin <= 15U))
10002514:	3a0c      	subs	r2, #12
10002516:	2a03      	cmp	r2, #3
10002518:	d85d      	bhi.n	100025d6 <IO002_Init+0x126>
	{
		Pin = (Pin - 12U);
		handle->PortRegs->IOCR12 |= (handle->IOCR << (3U+(Pin*8U)));
1000251a:	6c18      	ldr	r0, [r3, #64]	; 0x40
1000251c:	00d2      	lsls	r2, r2, #3
1000251e:	69c4      	ldr	r4, [r0, #28]
10002520:	3203      	adds	r2, #3
10002522:	6a5b      	ldr	r3, [r3, #36]	; 0x24
10002524:	e054      	b.n	100025d0 <IO002_Init+0x120>
    {
	    IO002_IOCR_OE_Enabled_lInit(handle,Pin);
    }

	/*If output enable is false*/
	if(handle->IOCR_OE == (uint32_t)0 )
10002526:	2800      	cmp	r0, #0
10002528:	d155      	bne.n	100025d6 <IO002_Init+0x126>
#if(UC_FAMILY == 1)
/*This function initialises the hysteresis control register for XMC1000 
devices*/
static void IO002_XMC1_lInit(const IO002_HandleType * handle,uint32_t Pin)
{
	if (handle->PHCR_EN == 1U)
1000252a:	6a18      	ldr	r0, [r3, #32]
1000252c:	2801      	cmp	r0, #1
1000252e:	d10f      	bne.n	10002550 <IO002_Init+0xa0>
	{
		if (Pin < 8U)
10002530:	2a07      	cmp	r2, #7
10002532:	d804      	bhi.n	1000253e <IO002_Init+0x8e>
		{
			handle->PortRegs->PHCR0 |= handle->PHCR0_MSK;
10002534:	6c1e      	ldr	r6, [r3, #64]	; 0x40
10002536:	6b98      	ldr	r0, [r3, #56]	; 0x38
10002538:	6c34      	ldr	r4, [r6, #64]	; 0x40
1000253a:	4304      	orrs	r4, r0
1000253c:	e00e      	b.n	1000255c <IO002_Init+0xac>
		}
		else if ((Pin >= 8U) && (Pin <= 15U))
1000253e:	1c15      	adds	r5, r2, #0
10002540:	3d08      	subs	r5, #8
10002542:	2d07      	cmp	r5, #7
10002544:	d822      	bhi.n	1000258c <IO002_Init+0xdc>
		{
			handle->PortRegs->PHCR1 |= handle->PHCR1_MSK;
10002546:	6c1e      	ldr	r6, [r3, #64]	; 0x40
10002548:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
1000254a:	6c70      	ldr	r0, [r6, #68]	; 0x44
1000254c:	4320      	orrs	r0, r4
1000254e:	e016      	b.n	1000257e <IO002_Init+0xce>
		{
		}
	}
	else
	{
		if (Pin < 8U)
10002550:	2a07      	cmp	r2, #7
10002552:	d80c      	bhi.n	1000256e <IO002_Init+0xbe>
		{
			handle->PortRegs->PHCR0 &= ~(handle->PHCR0_MSK);
10002554:	6c1e      	ldr	r6, [r3, #64]	; 0x40
10002556:	6b98      	ldr	r0, [r3, #56]	; 0x38
10002558:	6c34      	ldr	r4, [r6, #64]	; 0x40
1000255a:	4384      	bics	r4, r0
1000255c:	6434      	str	r4, [r6, #64]	; 0x40
/*This function initialises the input/output control registers when output 
enable is false*/
static void IO002_IOCR_OE_Disabled_lInit(const IO002_HandleType * handle,
		                                                      uint32_t Pin)
{
	if(Pin < 4U)
1000255e:	2a03      	cmp	r2, #3
10002560:	d814      	bhi.n	1000258c <IO002_Init+0xdc>
	{
		handle->PortRegs->IOCR0 |= (handle->IOCR_PCR2 << (3U+(Pin*8U)));
10002562:	6c1d      	ldr	r5, [r3, #64]	; 0x40
10002564:	00d2      	lsls	r2, r2, #3
10002566:	6928      	ldr	r0, [r5, #16]
10002568:	3203      	adds	r2, #3
1000256a:	695c      	ldr	r4, [r3, #20]
1000256c:	e009      	b.n	10002582 <IO002_Init+0xd2>
	{
		if (Pin < 8U)
		{
			handle->PortRegs->PHCR0 &= ~(handle->PHCR0_MSK);
		}
		else if ((Pin >= 8U) && (Pin <= 15U))
1000256e:	1c14      	adds	r4, r2, #0
10002570:	3c08      	subs	r4, #8
10002572:	2c07      	cmp	r4, #7
10002574:	d80a      	bhi.n	1000258c <IO002_Init+0xdc>
		{
			handle->PortRegs->PHCR1 &= ~(handle->PHCR1_MSK);
10002576:	6c1e      	ldr	r6, [r3, #64]	; 0x40
10002578:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
1000257a:	6c70      	ldr	r0, [r6, #68]	; 0x44
1000257c:	43a8      	bics	r0, r5
1000257e:	6470      	str	r0, [r6, #68]	; 0x44
10002580:	e004      	b.n	1000258c <IO002_Init+0xdc>
static void IO002_IOCR_OE_Disabled_lInit(const IO002_HandleType * handle,
		                                                      uint32_t Pin)
{
	if(Pin < 4U)
	{
		handle->PortRegs->IOCR0 |= (handle->IOCR_PCR2 << (3U+(Pin*8U)));
10002582:	4094      	lsls	r4, r2
10002584:	1c22      	adds	r2, r4, #0
10002586:	4302      	orrs	r2, r0
10002588:	612a      	str	r2, [r5, #16]
1000258a:	e024      	b.n	100025d6 <IO002_Init+0x126>
	}
	else if ((Pin >= 4U) && (Pin <= 7U))
1000258c:	1f16      	subs	r6, r2, #4
1000258e:	2e03      	cmp	r6, #3
10002590:	d809      	bhi.n	100025a6 <IO002_Init+0xf6>
	{
		Pin = (Pin - 4U);
		handle->PortRegs->IOCR4 |= (handle->IOCR_PCR2 << (3U+(Pin*8U)));
10002592:	6c1a      	ldr	r2, [r3, #64]	; 0x40
10002594:	00f6      	lsls	r6, r6, #3
10002596:	6954      	ldr	r4, [r2, #20]
10002598:	695b      	ldr	r3, [r3, #20]
1000259a:	3603      	adds	r6, #3
1000259c:	40b3      	lsls	r3, r6
1000259e:	1c1e      	adds	r6, r3, #0
100025a0:	4326      	orrs	r6, r4
100025a2:	6156      	str	r6, [r2, #20]
100025a4:	e017      	b.n	100025d6 <IO002_Init+0x126>
	}
	else if ((Pin >= 8U) && (Pin <= 11U))
100025a6:	1c15      	adds	r5, r2, #0
100025a8:	3d08      	subs	r5, #8
100025aa:	2d03      	cmp	r5, #3
100025ac:	d808      	bhi.n	100025c0 <IO002_Init+0x110>
	{
		Pin = (Pin - 8U);
		handle->PortRegs->IOCR8 |= (handle->IOCR_PCR2 << (3U+(Pin*8U)));
100025ae:	6c1e      	ldr	r6, [r3, #64]	; 0x40
100025b0:	00ed      	lsls	r5, r5, #3
100025b2:	69b4      	ldr	r4, [r6, #24]
100025b4:	6958      	ldr	r0, [r3, #20]
100025b6:	3503      	adds	r5, #3
100025b8:	40a8      	lsls	r0, r5
100025ba:	4320      	orrs	r0, r4
100025bc:	61b0      	str	r0, [r6, #24]
100025be:	e00a      	b.n	100025d6 <IO002_Init+0x126>
	}
	else if ((Pin >= 12U) && (Pin <= 15U))
100025c0:	3a0c      	subs	r2, #12
100025c2:	2a03      	cmp	r2, #3
100025c4:	d807      	bhi.n	100025d6 <IO002_Init+0x126>
	{
		Pin = (Pin - 12U);
		handle->PortRegs->IOCR12 |= (handle->IOCR_PCR2 << (3U+(Pin*8U)));
100025c6:	6c18      	ldr	r0, [r3, #64]	; 0x40
100025c8:	00d2      	lsls	r2, r2, #3
100025ca:	69c4      	ldr	r4, [r0, #28]
100025cc:	695b      	ldr	r3, [r3, #20]
100025ce:	3203      	adds	r2, #3
100025d0:	4093      	lsls	r3, r2
100025d2:	4323      	orrs	r3, r4
100025d4:	61c3      	str	r3, [r0, #28]
100025d6:	3104      	adds	r1, #4
 */
void IO002_Init(void)
{
	uint32_t i = (uint32_t)0;
	/*Initialize IO for number of instances*/
	for(; i < IO002_NUM_INSTANCES;i++ )
100025d8:	291c      	cmp	r1, #28
100025da:	d000      	beq.n	100025de <IO002_Init+0x12e>
100025dc:	e76a      	b.n	100024b4 <IO002_Init+0x4>
	{
		IO002_lInit(IO002_HandleArr[i]);
	}  
}
100025de:	bd70      	pop	{r4, r5, r6, pc}
100025e0:	2000065c 	.word	0x2000065c

100025e4 <IO001_Init>:
{
   /* <<<DD_IO001_API_1>>> */

  /* Configuration of Port 2 Pin 8 based on User configuration */
  /* Enable Digital Pad Input*/
  IO001_Handle0.PortRegs->PDISC  &= (~((uint32_t)0x1U << 8));
100025e4:	4b18      	ldr	r3, [pc, #96]	; (10002648 <IO001_Init+0x64>)
100025e6:	4a19      	ldr	r2, [pc, #100]	; (1000264c <IO001_Init+0x68>)
100025e8:	6858      	ldr	r0, [r3, #4]
100025ea:	6e01      	ldr	r1, [r0, #96]	; 0x60
100025ec:	400a      	ands	r2, r1
100025ee:	6602      	str	r2, [r0, #96]	; 0x60
  /*configure the Digital Input characteristics in IOCR register*/
  IO001_Handle0.PortRegs->IOCR8 |= (0U << 3);
100025f0:	6983      	ldr	r3, [r0, #24]
  /* Configuration of Port 2 Pin 9 based on User configuration */
  /* Enable Digital Pad Input*/
  IO001_Handle1.PortRegs->PDISC  &= (~((uint32_t)0x1U << 9));
100025f2:	4a17      	ldr	r2, [pc, #92]	; (10002650 <IO001_Init+0x6c>)

  /* Configuration of Port 2 Pin 8 based on User configuration */
  /* Enable Digital Pad Input*/
  IO001_Handle0.PortRegs->PDISC  &= (~((uint32_t)0x1U << 8));
  /*configure the Digital Input characteristics in IOCR register*/
  IO001_Handle0.PortRegs->IOCR8 |= (0U << 3);
100025f4:	6183      	str	r3, [r0, #24]
  /* Configuration of Port 2 Pin 9 based on User configuration */
  /* Enable Digital Pad Input*/
  IO001_Handle1.PortRegs->PDISC  &= (~((uint32_t)0x1U << 9));
100025f6:	4817      	ldr	r0, [pc, #92]	; (10002654 <IO001_Init+0x70>)
100025f8:	6843      	ldr	r3, [r0, #4]
100025fa:	6e19      	ldr	r1, [r3, #96]	; 0x60
100025fc:	400a      	ands	r2, r1
100025fe:	661a      	str	r2, [r3, #96]	; 0x60
  /*configure the Digital Input characteristics in IOCR register*/
  IO001_Handle1.PortRegs->IOCR8 |= (0U << 11);
10002600:	6998      	ldr	r0, [r3, #24]
  /* Configuration of Port 2 Pin 6 based on User configuration */
  /* Enable Digital Pad Input*/
  IO001_Handle2.PortRegs->PDISC  &= (~((uint32_t)0x1U << 6));
10002602:	2140      	movs	r1, #64	; 0x40
  IO001_Handle0.PortRegs->IOCR8 |= (0U << 3);
  /* Configuration of Port 2 Pin 9 based on User configuration */
  /* Enable Digital Pad Input*/
  IO001_Handle1.PortRegs->PDISC  &= (~((uint32_t)0x1U << 9));
  /*configure the Digital Input characteristics in IOCR register*/
  IO001_Handle1.PortRegs->IOCR8 |= (0U << 11);
10002604:	6198      	str	r0, [r3, #24]
  /* Configuration of Port 2 Pin 6 based on User configuration */
  /* Enable Digital Pad Input*/
  IO001_Handle2.PortRegs->PDISC  &= (~((uint32_t)0x1U << 6));
10002606:	4b14      	ldr	r3, [pc, #80]	; (10002658 <IO001_Init+0x74>)
10002608:	6858      	ldr	r0, [r3, #4]
1000260a:	6e02      	ldr	r2, [r0, #96]	; 0x60
1000260c:	438a      	bics	r2, r1
1000260e:	6602      	str	r2, [r0, #96]	; 0x60
  /*configure the Digital Input characteristics in IOCR register*/
  IO001_Handle2.PortRegs->IOCR4 |= (0U << 19);
10002610:	6943      	ldr	r3, [r0, #20]
  /* Configuration of Port 2 Pin 7 based on User configuration */
  /* Enable Digital Pad Input*/
  IO001_Handle3.PortRegs->PDISC  &= (~((uint32_t)0x1U << 7));
10002612:	2180      	movs	r1, #128	; 0x80
  IO001_Handle1.PortRegs->IOCR8 |= (0U << 11);
  /* Configuration of Port 2 Pin 6 based on User configuration */
  /* Enable Digital Pad Input*/
  IO001_Handle2.PortRegs->PDISC  &= (~((uint32_t)0x1U << 6));
  /*configure the Digital Input characteristics in IOCR register*/
  IO001_Handle2.PortRegs->IOCR4 |= (0U << 19);
10002614:	6143      	str	r3, [r0, #20]
  /* Configuration of Port 2 Pin 7 based on User configuration */
  /* Enable Digital Pad Input*/
  IO001_Handle3.PortRegs->PDISC  &= (~((uint32_t)0x1U << 7));
10002616:	4811      	ldr	r0, [pc, #68]	; (1000265c <IO001_Init+0x78>)
10002618:	6843      	ldr	r3, [r0, #4]
1000261a:	6e1a      	ldr	r2, [r3, #96]	; 0x60
1000261c:	438a      	bics	r2, r1
1000261e:	661a      	str	r2, [r3, #96]	; 0x60
  /*configure the Digital Input characteristics in IOCR register*/
  IO001_Handle3.PortRegs->IOCR4 |= (0U << 27);
10002620:	6958      	ldr	r0, [r3, #20]
  /* Configuration of Port 2 Pin 2 based on User configuration */
  /* Enable Digital Pad Input*/
  IO001_Handle4.PortRegs->PDISC  &= (~((uint32_t)0x1U << 2));
10002622:	2104      	movs	r1, #4
  IO001_Handle2.PortRegs->IOCR4 |= (0U << 19);
  /* Configuration of Port 2 Pin 7 based on User configuration */
  /* Enable Digital Pad Input*/
  IO001_Handle3.PortRegs->PDISC  &= (~((uint32_t)0x1U << 7));
  /*configure the Digital Input characteristics in IOCR register*/
  IO001_Handle3.PortRegs->IOCR4 |= (0U << 27);
10002624:	6158      	str	r0, [r3, #20]
  /* Configuration of Port 2 Pin 2 based on User configuration */
  /* Enable Digital Pad Input*/
  IO001_Handle4.PortRegs->PDISC  &= (~((uint32_t)0x1U << 2));
10002626:	4b0e      	ldr	r3, [pc, #56]	; (10002660 <IO001_Init+0x7c>)
10002628:	6858      	ldr	r0, [r3, #4]
1000262a:	6e02      	ldr	r2, [r0, #96]	; 0x60
1000262c:	438a      	bics	r2, r1
1000262e:	6602      	str	r2, [r0, #96]	; 0x60
  /*configure the Digital Input characteristics in IOCR register*/
  IO001_Handle4.PortRegs->IOCR0 |= (0U << 19);
10002630:	6903      	ldr	r3, [r0, #16]
  /* Configuration of Port 2 Pin 1 based on User configuration */
  /* Enable Digital Pad Input*/
  IO001_Handle5.PortRegs->PDISC  &= (~((uint32_t)0x1U << 1));
10002632:	2102      	movs	r1, #2
  IO001_Handle3.PortRegs->IOCR4 |= (0U << 27);
  /* Configuration of Port 2 Pin 2 based on User configuration */
  /* Enable Digital Pad Input*/
  IO001_Handle4.PortRegs->PDISC  &= (~((uint32_t)0x1U << 2));
  /*configure the Digital Input characteristics in IOCR register*/
  IO001_Handle4.PortRegs->IOCR0 |= (0U << 19);
10002634:	6103      	str	r3, [r0, #16]
  /* Configuration of Port 2 Pin 1 based on User configuration */
  /* Enable Digital Pad Input*/
  IO001_Handle5.PortRegs->PDISC  &= (~((uint32_t)0x1U << 1));
10002636:	480b      	ldr	r0, [pc, #44]	; (10002664 <IO001_Init+0x80>)
10002638:	6843      	ldr	r3, [r0, #4]
1000263a:	6e1a      	ldr	r2, [r3, #96]	; 0x60
1000263c:	438a      	bics	r2, r1
1000263e:	661a      	str	r2, [r3, #96]	; 0x60
  /*configure the Digital Input characteristics in IOCR register*/
  IO001_Handle5.PortRegs->IOCR0 |= (0U << 11);
10002640:	6918      	ldr	r0, [r3, #16]
10002642:	6118      	str	r0, [r3, #16]
}
10002644:	4770      	bx	lr
10002646:	46c0      	nop			; (mov r8, r8)
10002648:	10004458 	.word	0x10004458
1000264c:	fffffeff 	.word	0xfffffeff
10002650:	fffffdff 	.word	0xfffffdff
10002654:	10004450 	.word	0x10004450
10002658:	10004448 	.word	0x10004448
1000265c:	10004440 	.word	0x10004440
10002660:	10004438 	.word	0x10004438
10002664:	10004430 	.word	0x10004430

10002668 <I2C003_lConfigPcrReg>:
 *
 * <b>Reentrant: No </b><BR>
 ******************************************************************************/
void I2C003_lConfigPcrReg(const I2C003_HandleType* Handle)
{
    USIC_CH_TypeDef* I2CRegs = Handle->I2CRegs;
10002668:	6803      	ldr	r3, [r0, #0]

   /* Slave Address */
   I2CRegs->PCR_IICMode |= (uint32_t)Handle->SlaveAddress;
1000266a:	8a81      	ldrh	r1, [r0, #20]
1000266c:	6bda      	ldr	r2, [r3, #60]	; 0x3c
1000266e:	430a      	orrs	r2, r1
10002670:	63da      	str	r2, [r3, #60]	; 0x3c

   if (I2C003_BITRATE >= Handle->BitRate)
10002672:	6982      	ldr	r2, [r0, #24]
10002674:	2a64      	cmp	r2, #100	; 0x64
10002676:	d801      	bhi.n	1000267c <I2C003_lConfigPcrReg+0x14>
   {
	   /* Symbol timing = 10 time quanta */
	   I2CRegs->PCR_IICMode |= \
10002678:	6bda      	ldr	r2, [r3, #60]	; 0x3c
1000267a:	e003      	b.n	10002684 <I2C003_lConfigPcrReg+0x1c>
			                    USIC_CH_PCR_IICMode_STIM_Msk);
   }
   else
   {
	   /* Symbol timing = 25 time quanta */
	 I2CRegs->PCR_IICMode |= \
1000267c:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
1000267e:	2280      	movs	r2, #128	; 0x80
10002680:	0292      	lsls	r2, r2, #10
10002682:	430a      	orrs	r2, r1
10002684:	63da      	str	r2, [r3, #60]	; 0x3c
	                  (((uint32_t)SHIFT_ONE << USIC_CH_PCR_IICMode_STIM_Pos) & \
								USIC_CH_PCR_IICMode_STIM_Msk);
   }
   if (Handle->StartCondRecvIntEn)
10002686:	1cc1      	adds	r1, r0, #3
10002688:	7fca      	ldrb	r2, [r1, #31]
1000268a:	2a00      	cmp	r2, #0
1000268c:	d004      	beq.n	10002698 <I2C003_lConfigPcrReg+0x30>
   {
	  /* Enable Start Condition Recv Interrupt*/
	 I2CRegs->PCR_IICMode |=(((uint32_t)SHIFT_ONE  << USIC_CH_PCR_CTR18_Pos) & \
1000268e:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
10002690:	2280      	movs	r2, #128	; 0x80
10002692:	02d2      	lsls	r2, r2, #11
10002694:	430a      	orrs	r2, r1
10002696:	63da      	str	r2, [r3, #60]	; 0x3c
							  USIC_CH_PCR_CTR18_Msk);
   }else{}
   if (Handle->RepStartCondRecvIntEn)
10002698:	1d01      	adds	r1, r0, #4
1000269a:	7fca      	ldrb	r2, [r1, #31]
1000269c:	2a00      	cmp	r2, #0
1000269e:	d004      	beq.n	100026aa <I2C003_lConfigPcrReg+0x42>
   {
		/* Enable Repeated Start Condition Interrupt*/
	  I2CRegs->PCR_IICMode |=(((uint32_t)SHIFT_ONE << USIC_CH_PCR_CTR19_Pos) & \
100026a0:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
100026a2:	2280      	movs	r2, #128	; 0x80
100026a4:	0312      	lsls	r2, r2, #12
100026a6:	430a      	orrs	r2, r1
100026a8:	63da      	str	r2, [r3, #60]	; 0x3c
							  USIC_CH_PCR_CTR19_Msk);
   }else{}
   if (Handle->StopCondRecvIntEn)
100026aa:	1d81      	adds	r1, r0, #6
100026ac:	7fca      	ldrb	r2, [r1, #31]
100026ae:	2a00      	cmp	r2, #0
100026b0:	d004      	beq.n	100026bc <I2C003_lConfigPcrReg+0x54>
   {
		/* Enable Stop Condition Interrupt*/
	  I2CRegs->PCR_IICMode |=(((uint32_t)SHIFT_ONE  << USIC_CH_PCR_CTR20_Pos) & \
100026b2:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
100026b4:	2280      	movs	r2, #128	; 0x80
100026b6:	0352      	lsls	r2, r2, #13
100026b8:	430a      	orrs	r2, r1
100026ba:	63da      	str	r2, [r3, #60]	; 0x3c
							  USIC_CH_PCR_CTR20_Msk);
   }else{}
   if (Handle->SlaveReadReqIntEn)
100026bc:	1d41      	adds	r1, r0, #5
100026be:	7fca      	ldrb	r2, [r1, #31]
100026c0:	2a00      	cmp	r2, #0
100026c2:	d004      	beq.n	100026ce <I2C003_lConfigPcrReg+0x66>
   {
		/* Enable a slave read request detected interrupt */
	  I2CRegs->PCR_IICMode |=(((uint32_t)SHIFT_ONE  << USIC_CH_PCR_CTR23_Pos) & \
100026c4:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
100026c6:	2280      	movs	r2, #128	; 0x80
100026c8:	0412      	lsls	r2, r2, #16
100026ca:	430a      	orrs	r2, r1
100026cc:	63da      	str	r2, [r3, #60]	; 0x3c
							   USIC_CH_PCR_CTR23_Msk);
   }else{}
   if (Handle->ErrorIntEn)
100026ce:	3007      	adds	r0, #7
100026d0:	7fc0      	ldrb	r0, [r0, #31]
100026d2:	2800      	cmp	r0, #0
100026d4:	d004      	beq.n	100026e0 <I2C003_lConfigPcrReg+0x78>
   {
		/* Enable IIC Error Interrupt */
	  I2CRegs->PCR_IICMode |=(((uint32_t)SHIFT_ONE  << USIC_CH_PCR_CTR24_Pos) & \
100026d6:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
100026d8:	2280      	movs	r2, #128	; 0x80
100026da:	0450      	lsls	r0, r2, #17
100026dc:	4308      	orrs	r0, r1
100026de:	63d8      	str	r0, [r3, #60]	; 0x3c
						  USIC_CH_PCR_CTR24_Msk);
   }else{}
}
100026e0:	4770      	bx	lr
	...

100026e4 <I2C003_lInit>:
 * @return  None <BR>
 *
 * <b>Reentrant: No </b><BR>
 ******************************************************************************/
void I2C003_lInit(const I2C003_HandleType* Handle)
{
100026e4:	b538      	push	{r3, r4, r5, lr}
 
   USIC_CH_TypeDef* I2CRegs = Handle->I2CRegs;
100026e6:	6804      	ldr	r4, [r0, #0]

   /** I2C initialisation  */
   /* Disable I2C mode before configuring all USIC registers to avoid 
    * unintended edges */ 
   I2CRegs->CCR &= ~(((uint32_t)(I2C_ENABLE  & USIC_CH_CCR_MODE_Msk)));
100026e8:	2204      	movs	r2, #4
100026ea:	6c23      	ldr	r3, [r4, #64]	; 0x40
 * @return  None <BR>
 *
 * <b>Reentrant: No </b><BR>
 ******************************************************************************/
void I2C003_lInit(const I2C003_HandleType* Handle)
{
100026ec:	1c05      	adds	r5, r0, #0
   USIC_CH_TypeDef* I2CRegs = Handle->I2CRegs;

   /** I2C initialisation  */
   /* Disable I2C mode before configuring all USIC registers to avoid 
    * unintended edges */ 
   I2CRegs->CCR &= ~(((uint32_t)(I2C_ENABLE  & USIC_CH_CCR_MODE_Msk)));
100026ee:	4393      	bics	r3, r2
100026f0:	6423      	str	r3, [r4, #64]	; 0x40

   /* Enable the USIC Channel */
   I2CRegs->KSCFG |= ((MASK_ONE & USIC_CH_KSCFG_MODEN_Msk)) | \
100026f2:	68e0      	ldr	r0, [r4, #12]
100026f4:	2103      	movs	r1, #3
100026f6:	4308      	orrs	r0, r1
100026f8:	60e0      	str	r0, [r4, #12]
                     (((uint32_t)SHIFT_ONE << USIC_CH_KSCFG_BPMODEN_Pos));
   
   /* Configuration of USIC Channel Fractional Divider */
   /* Fractional divider mode selected */
   I2CRegs->FDR |= \
100026fa:	6922      	ldr	r2, [r4, #16]
           ((((uint32_t)USIC_FRACTIONAL_DIV_SEL << USIC_CH_FDR_DM_Pos) & \
             USIC_CH_FDR_DM_Msk) | \
            (((uint32_t)Handle->Fdr_StepValue << USIC_CH_FDR_STEP_Pos) & \
100026fc:	8d29      	ldrh	r1, [r5, #40]	; 0x28
   I2CRegs->KSCFG |= ((MASK_ONE & USIC_CH_KSCFG_MODEN_Msk)) | \
                     (((uint32_t)SHIFT_ONE << USIC_CH_KSCFG_BPMODEN_Pos));
   
   /* Configuration of USIC Channel Fractional Divider */
   /* Fractional divider mode selected */
   I2CRegs->FDR |= \
100026fe:	2380      	movs	r3, #128	; 0x80
10002700:	0218      	lsls	r0, r3, #8
10002702:	4310      	orrs	r0, r2
           ((((uint32_t)USIC_FRACTIONAL_DIV_SEL << USIC_CH_FDR_DM_Pos) & \
             USIC_CH_FDR_DM_Msk) | \
            (((uint32_t)Handle->Fdr_StepValue << USIC_CH_FDR_STEP_Pos) & \
10002704:	058a      	lsls	r2, r1, #22
10002706:	0d93      	lsrs	r3, r2, #22
   I2CRegs->KSCFG |= ((MASK_ONE & USIC_CH_KSCFG_MODEN_Msk)) | \
                     (((uint32_t)SHIFT_ONE << USIC_CH_KSCFG_BPMODEN_Pos));
   
   /* Configuration of USIC Channel Fractional Divider */
   /* Fractional divider mode selected */
   I2CRegs->FDR |= \
10002708:	4318      	orrs	r0, r3
           ((((uint32_t)USIC_FRACTIONAL_DIV_SEL << USIC_CH_FDR_DM_Pos) & \
             USIC_CH_FDR_DM_Msk) | \
            (((uint32_t)Handle->Fdr_StepValue << USIC_CH_FDR_STEP_Pos) & \
            USIC_CH_FDR_STEP_Msk));
             
   if (I2C003_BITRATE >= Handle->BitRate)
1000270a:	69a9      	ldr	r1, [r5, #24]
   I2CRegs->KSCFG |= ((MASK_ONE & USIC_CH_KSCFG_MODEN_Msk)) | \
                     (((uint32_t)SHIFT_ONE << USIC_CH_KSCFG_BPMODEN_Pos));
   
   /* Configuration of USIC Channel Fractional Divider */
   /* Fractional divider mode selected */
   I2CRegs->FDR |= \
1000270c:	6120      	str	r0, [r4, #16]
1000270e:	8d6a      	ldrh	r2, [r5, #42]	; 0x2a
10002710:	4b20      	ldr	r3, [pc, #128]	; (10002794 <I2C003_lInit+0xb0>)
             
   if (I2C003_BITRATE >= Handle->BitRate)
   {  
     /* The PreDivider for CTQ, PCTQ = 0  */
     /* The Denominator for CTQ, DCTQ = 9 */
     I2CRegs->BRG |=(((uint32_t)I2C003_DCTQ1_VALUE <<  USIC_CH_BRG_DCTQ_Pos) | \
10002712:	6960      	ldr	r0, [r4, #20]
           ((((uint32_t)USIC_FRACTIONAL_DIV_SEL << USIC_CH_FDR_DM_Pos) & \
             USIC_CH_FDR_DM_Msk) | \
            (((uint32_t)Handle->Fdr_StepValue << USIC_CH_FDR_STEP_Pos) & \
            USIC_CH_FDR_STEP_Msk));
             
   if (I2C003_BITRATE >= Handle->BitRate)
10002714:	2964      	cmp	r1, #100	; 0x64
10002716:	d802      	bhi.n	1000271e <I2C003_lInit+0x3a>
   {  
     /* The PreDivider for CTQ, PCTQ = 0  */
     /* The Denominator for CTQ, DCTQ = 9 */
     I2CRegs->BRG |=(((uint32_t)I2C003_DCTQ1_VALUE <<  USIC_CH_BRG_DCTQ_Pos) | \
10002718:	2190      	movs	r1, #144	; 0x90
1000271a:	0189      	lsls	r1, r1, #6
1000271c:	e001      	b.n	10002722 <I2C003_lInit+0x3e>
   }
   else
   {
     /* The PreDivider for CTQ, PCTQ = 0  */
     /* The Denominator for CTQ, DCTQ = 24 */
     I2CRegs->BRG |= (((uint32_t)I2C003_DCTQ2_VALUE << USIC_CH_BRG_DCTQ_Pos) | \
1000271e:	21c0      	movs	r1, #192	; 0xc0
10002720:	01c9      	lsls	r1, r1, #7
                     (((uint32_t)Handle->Brg_PDivValue << USIC_CH_BRG_PDIV_Pos)\
10002722:	0412      	lsls	r2, r2, #16
   }
   else
   {
     /* The PreDivider for CTQ, PCTQ = 0  */
     /* The Denominator for CTQ, DCTQ = 24 */
     I2CRegs->BRG |= (((uint32_t)I2C003_DCTQ2_VALUE << USIC_CH_BRG_DCTQ_Pos) | \
10002724:	4301      	orrs	r1, r0
                     (((uint32_t)Handle->Brg_PDivValue << USIC_CH_BRG_PDIV_Pos)\
					   & USIC_CH_BRG_PDIV_Msk));
10002726:	4013      	ands	r3, r2
   }
   else
   {
     /* The PreDivider for CTQ, PCTQ = 0  */
     /* The Denominator for CTQ, DCTQ = 24 */
     I2CRegs->BRG |= (((uint32_t)I2C003_DCTQ2_VALUE << USIC_CH_BRG_DCTQ_Pos) | \
10002728:	430b      	orrs	r3, r1
1000272a:	6163      	str	r3, [r4, #20]
   /* Transmission Mode (TRM) = 3  */
   /* Passive Data Level (PDL) = 1 */
   /* Frame Length (FLE) = 63 (3F) */
   /* Word Length (WLE) = 7  */

   I2CRegs->SCTR |=  \
1000272c:	6b63      	ldr	r3, [r4, #52]	; 0x34
1000272e:	481a      	ldr	r0, [pc, #104]	; (10002798 <I2C003_lInit+0xb4>)

       
   /* Configuration of USIC Transmit Control/Status Register */ 
   /* TBUF Data Enable (TDEN) = 1 */
   /* TBUF Data Single Shot Mode (TDSSM) = 1 */     
   I2CRegs->TCSR |= \
10002730:	22a0      	movs	r2, #160	; 0xa0
   /* Transmission Mode (TRM) = 3  */
   /* Passive Data Level (PDL) = 1 */
   /* Frame Length (FLE) = 63 (3F) */
   /* Word Length (WLE) = 7  */

   I2CRegs->SCTR |=  \
10002732:	4303      	orrs	r3, r0
10002734:	6363      	str	r3, [r4, #52]	; 0x34

       
   /* Configuration of USIC Transmit Control/Status Register */ 
   /* TBUF Data Enable (TDEN) = 1 */
   /* TBUF Data Single Shot Mode (TDSSM) = 1 */     
   I2CRegs->TCSR |= \
10002736:	6ba1      	ldr	r1, [r4, #56]	; 0x38
10002738:	00d3      	lsls	r3, r2, #3
1000273a:	430b      	orrs	r3, r1
   /* Non-Acknowledge interrupt enabled */
   /* Arbitration Lost interrupt enabled */
   /* Slave read request interrupt enabled */
   /* Error interrupt enabled */
   /* Configuration of Protocol Control Register */ 
   I2C003_lConfigPcrReg(Handle);
1000273c:	1c28      	adds	r0, r5, #0

       
   /* Configuration of USIC Transmit Control/Status Register */ 
   /* TBUF Data Enable (TDEN) = 1 */
   /* TBUF Data Single Shot Mode (TDSSM) = 1 */     
   I2CRegs->TCSR |= \
1000273e:	63a3      	str	r3, [r4, #56]	; 0x38
   /* Non-Acknowledge interrupt enabled */
   /* Arbitration Lost interrupt enabled */
   /* Slave read request interrupt enabled */
   /* Error interrupt enabled */
   /* Configuration of Protocol Control Register */ 
   I2C003_lConfigPcrReg(Handle);
10002740:	f7ff ff92 	bl	10002668 <I2C003_lConfigPcrReg>
   
   /** FIFO Configuration */
   if (Handle->TxFifoEn)
10002744:	7f28      	ldrb	r0, [r5, #28]
10002746:	2800      	cmp	r0, #0
10002748:	d00a      	beq.n	10002760 <I2C003_lInit+0x7c>
   {
      /* Configuration of Transmitter Buffer Control Register */ 
      /* Limit for transmit FIFO interrupt generation is set based on UI */
      I2CRegs->TBCTR |= \
             ((((uint32_t)Handle->TxLimit << USIC_CH_TBCTR_LIMIT_Pos ) & \
1000274a:	7fa8      	ldrb	r0, [r5, #30]
   /** FIFO Configuration */
   if (Handle->TxFifoEn)
   {
      /* Configuration of Transmitter Buffer Control Register */ 
      /* Limit for transmit FIFO interrupt generation is set based on UI */
      I2CRegs->TBCTR |= \
1000274c:	1c23      	adds	r3, r4, #0
1000274e:	33fc      	adds	r3, #252	; 0xfc
             ((((uint32_t)Handle->TxLimit << USIC_CH_TBCTR_LIMIT_Pos ) & \
10002750:	22fc      	movs	r2, #252	; 0xfc
   /** FIFO Configuration */
   if (Handle->TxFifoEn)
   {
      /* Configuration of Transmitter Buffer Control Register */ 
      /* Limit for transmit FIFO interrupt generation is set based on UI */
      I2CRegs->TBCTR |= \
10002752:	68d9      	ldr	r1, [r3, #12]
             ((((uint32_t)Handle->TxLimit << USIC_CH_TBCTR_LIMIT_Pos ) & \
10002754:	0200      	lsls	r0, r0, #8
10002756:	0192      	lsls	r2, r2, #6
10002758:	4002      	ands	r2, r0
   /** FIFO Configuration */
   if (Handle->TxFifoEn)
   {
      /* Configuration of Transmitter Buffer Control Register */ 
      /* Limit for transmit FIFO interrupt generation is set based on UI */
      I2CRegs->TBCTR |= \
1000275a:	430a      	orrs	r2, r1
1000275c:	60da      	str	r2, [r3, #12]
1000275e:	e004      	b.n	1000276a <I2C003_lInit+0x86>
   }
   else
   {
      /* Configuration of Protocol Status Register */
	  /* TBIF is set to simplify polling*/
	  I2CRegs->PSR_IICMode |= \
10002760:	6ca1      	ldr	r1, [r4, #72]	; 0x48
10002762:	2280      	movs	r2, #128	; 0x80
10002764:	0193      	lsls	r3, r2, #6
10002766:	430b      	orrs	r3, r1
10002768:	64a3      	str	r3, [r4, #72]	; 0x48
	                    (((uint32_t)SHIFT_ONE << USIC_CH_PSR_IICMode_TBIF_Pos) \
			              & USIC_CH_PSR_IICMode_TBIF_Msk);
   }
   
   if (Handle->RxFifoEn)
1000276a:	7f6b      	ldrb	r3, [r5, #29]
1000276c:	2b00      	cmp	r3, #0
1000276e:	d00c      	beq.n	1000278a <I2C003_lInit+0xa6>
   {
      /* Configuration of Receiver Buffer Control Register */ 
      /* Limit for receive FIFO interrupt generation is set based on UI*/
      /* Filling level mode is selected */
      I2CRegs->RBCTR |= \
10002770:	1c23      	adds	r3, r4, #0
10002772:	33fc      	adds	r3, #252	; 0xfc
10002774:	6918      	ldr	r0, [r3, #16]
              ((((uint32_t)Handle->RxLimit << USIC_CH_RBCTR_LIMIT_Pos) & \
10002776:	7fed      	ldrb	r5, [r5, #31]
   if (Handle->RxFifoEn)
   {
      /* Configuration of Receiver Buffer Control Register */ 
      /* Limit for receive FIFO interrupt generation is set based on UI*/
      /* Filling level mode is selected */
      I2CRegs->RBCTR |= \
10002778:	2180      	movs	r1, #128	; 0x80
1000277a:	0549      	lsls	r1, r1, #21
              ((((uint32_t)Handle->RxLimit << USIC_CH_RBCTR_LIMIT_Pos) & \
1000277c:	22fc      	movs	r2, #252	; 0xfc
   if (Handle->RxFifoEn)
   {
      /* Configuration of Receiver Buffer Control Register */ 
      /* Limit for receive FIFO interrupt generation is set based on UI*/
      /* Filling level mode is selected */
      I2CRegs->RBCTR |= \
1000277e:	4301      	orrs	r1, r0
              ((((uint32_t)Handle->RxLimit << USIC_CH_RBCTR_LIMIT_Pos) & \
10002780:	0228      	lsls	r0, r5, #8
10002782:	0195      	lsls	r5, r2, #6
10002784:	4005      	ands	r5, r0
   if (Handle->RxFifoEn)
   {
      /* Configuration of Receiver Buffer Control Register */ 
      /* Limit for receive FIFO interrupt generation is set based on UI*/
      /* Filling level mode is selected */
      I2CRegs->RBCTR |= \
10002786:	430d      	orrs	r5, r1
10002788:	611d      	str	r5, [r3, #16]
	 			USIC_CH_RBCTR_LIMIT_Msk) | \
                (((uint32_t)SHIFT_ONE << USIC_CH_RBCTR_LOF_Pos) & \
                USIC_CH_RBCTR_LOF_Msk));
   }else{}
   
   I2CRegs->CCR |= ((I2C_ENABLE) & USIC_CH_CCR_MODE_Msk);
1000278a:	6c23      	ldr	r3, [r4, #64]	; 0x40
1000278c:	2104      	movs	r1, #4
1000278e:	430b      	orrs	r3, r1
10002790:	6423      	str	r3, [r4, #64]	; 0x40
}
10002792:	bd38      	pop	{r3, r4, r5, pc}
10002794:	03ff0000 	.word	0x03ff0000
10002798:	073f0303 	.word	0x073f0303

1000279c <I2C003_lConfigSCLPin>:
 * @return  None <BR>
 *
 * <b>Reentrant: No </b><BR>
 ******************************************************************************/ 
void I2C003_lConfigSCLPin(const I2C003_HandleType* Handle)
{
1000279c:	b510      	push	{r4, lr}
	uint32_t TempPortPin;
	
    /* set the SCL port pin to '1' */
    Handle->PinHandle.SCL_PortBase->OMR |= (uint32_t)SHIFT_ONE << \
1000279e:	6843      	ldr	r3, [r0, #4]
100027a0:	7a02      	ldrb	r2, [r0, #8]
100027a2:	2401      	movs	r4, #1
100027a4:	6859      	ldr	r1, [r3, #4]
100027a6:	4094      	lsls	r4, r2
100027a8:	1c22      	adds	r2, r4, #0
100027aa:	430a      	orrs	r2, r1
100027ac:	605a      	str	r2, [r3, #4]
   		                                      Handle->PinHandle.SCL_Pin;
	 /* Configure SCL port pin as Open-drain General-purpose output */
    TempPortPin = (uint32_t)Handle->PinHandle.SCL_Pin;
100027ae:	7a00      	ldrb	r0, [r0, #8]
    if (FIRST_NIBBLE > TempPortPin)
100027b0:	2803      	cmp	r0, #3
100027b2:	d808      	bhi.n	100027c6 <I2C003_lConfigSCLPin+0x2a>
    {
   	  Handle->PinHandle.SCL_PortBase->IOCR0 |= \
   			                ((uint32_t)I2C003_OPENDRAIN_OUT << (3U + \
							(TempPortPin * 8U)));
100027b4:	00c2      	lsls	r2, r0, #3
	 /* Configure SCL port pin as Open-drain General-purpose output */
    TempPortPin = (uint32_t)Handle->PinHandle.SCL_Pin;
    if (FIRST_NIBBLE > TempPortPin)
    {
   	  Handle->PinHandle.SCL_PortBase->IOCR0 |= \
   			                ((uint32_t)I2C003_OPENDRAIN_OUT << (3U + \
100027b6:	3203      	adds	r2, #3
100027b8:	2018      	movs	r0, #24
   		                                      Handle->PinHandle.SCL_Pin;
	 /* Configure SCL port pin as Open-drain General-purpose output */
    TempPortPin = (uint32_t)Handle->PinHandle.SCL_Pin;
    if (FIRST_NIBBLE > TempPortPin)
    {
   	  Handle->PinHandle.SCL_PortBase->IOCR0 |= \
100027ba:	6919      	ldr	r1, [r3, #16]
   			                ((uint32_t)I2C003_OPENDRAIN_OUT << (3U + \
100027bc:	4090      	lsls	r0, r2
100027be:	1c04      	adds	r4, r0, #0
   		                                      Handle->PinHandle.SCL_Pin;
	 /* Configure SCL port pin as Open-drain General-purpose output */
    TempPortPin = (uint32_t)Handle->PinHandle.SCL_Pin;
    if (FIRST_NIBBLE > TempPortPin)
    {
   	  Handle->PinHandle.SCL_PortBase->IOCR0 |= \
100027c0:	430c      	orrs	r4, r1
100027c2:	611c      	str	r4, [r3, #16]
100027c4:	e023      	b.n	1000280e <I2C003_lConfigSCLPin+0x72>
   			                ((uint32_t)I2C003_OPENDRAIN_OUT << (3U + \
							(TempPortPin * 8U)));
    }
    else if ((FIRST_NIBBLE <= TempPortPin) && (SECOND_NIBBLE > TempPortPin))
100027c6:	1f01      	subs	r1, r0, #4
100027c8:	2903      	cmp	r1, #3
100027ca:	d808      	bhi.n	100027de <I2C003_lConfigSCLPin+0x42>
    {
	  TempPortPin = TempPortPin - 4U;
	  Handle->PinHandle.SCL_PortBase->IOCR4 |= \
			                ((uint32_t)I2C003_OPENDRAIN_OUT << (3U + \
							(TempPortPin * 8U)));
100027cc:	00c9      	lsls	r1, r1, #3
    }
    else if ((FIRST_NIBBLE <= TempPortPin) && (SECOND_NIBBLE > TempPortPin))
    {
	  TempPortPin = TempPortPin - 4U;
	  Handle->PinHandle.SCL_PortBase->IOCR4 |= \
			                ((uint32_t)I2C003_OPENDRAIN_OUT << (3U + \
100027ce:	3103      	adds	r1, #3
100027d0:	2018      	movs	r0, #24
							(TempPortPin * 8U)));
    }
    else if ((FIRST_NIBBLE <= TempPortPin) && (SECOND_NIBBLE > TempPortPin))
    {
	  TempPortPin = TempPortPin - 4U;
	  Handle->PinHandle.SCL_PortBase->IOCR4 |= \
100027d2:	695a      	ldr	r2, [r3, #20]
			                ((uint32_t)I2C003_OPENDRAIN_OUT << (3U + \
100027d4:	4088      	lsls	r0, r1
100027d6:	1c04      	adds	r4, r0, #0
							(TempPortPin * 8U)));
    }
    else if ((FIRST_NIBBLE <= TempPortPin) && (SECOND_NIBBLE > TempPortPin))
    {
	  TempPortPin = TempPortPin - 4U;
	  Handle->PinHandle.SCL_PortBase->IOCR4 |= \
100027d8:	4314      	orrs	r4, r2
100027da:	615c      	str	r4, [r3, #20]
100027dc:	e017      	b.n	1000280e <I2C003_lConfigSCLPin+0x72>
			                ((uint32_t)I2C003_OPENDRAIN_OUT << (3U + \
							(TempPortPin * 8U)));
    }
    else if ((SECOND_NIBBLE <= TempPortPin) && (THIRD_NIBBLE > TempPortPin))
100027de:	1c04      	adds	r4, r0, #0
100027e0:	3c08      	subs	r4, #8
100027e2:	2c03      	cmp	r4, #3
100027e4:	d808      	bhi.n	100027f8 <I2C003_lConfigSCLPin+0x5c>
    {
 	  TempPortPin = TempPortPin - 8U;
 	  Handle->PinHandle.SCL_PortBase->IOCR8 |= \
 			                ((uint32_t)I2C003_OPENDRAIN_OUT << (3U + \
							(TempPortPin * 8U)));
100027e6:	00e1      	lsls	r1, r4, #3
    }
    else if ((SECOND_NIBBLE <= TempPortPin) && (THIRD_NIBBLE > TempPortPin))
    {
 	  TempPortPin = TempPortPin - 8U;
 	  Handle->PinHandle.SCL_PortBase->IOCR8 |= \
 			                ((uint32_t)I2C003_OPENDRAIN_OUT << (3U + \
100027e8:	3103      	adds	r1, #3
100027ea:	2018      	movs	r0, #24
							(TempPortPin * 8U)));
    }
    else if ((SECOND_NIBBLE <= TempPortPin) && (THIRD_NIBBLE > TempPortPin))
    {
 	  TempPortPin = TempPortPin - 8U;
 	  Handle->PinHandle.SCL_PortBase->IOCR8 |= \
100027ec:	699a      	ldr	r2, [r3, #24]
 			                ((uint32_t)I2C003_OPENDRAIN_OUT << (3U + \
100027ee:	4088      	lsls	r0, r1
100027f0:	1c04      	adds	r4, r0, #0
							(TempPortPin * 8U)));
    }
    else if ((SECOND_NIBBLE <= TempPortPin) && (THIRD_NIBBLE > TempPortPin))
    {
 	  TempPortPin = TempPortPin - 8U;
 	  Handle->PinHandle.SCL_PortBase->IOCR8 |= \
100027f2:	4314      	orrs	r4, r2
100027f4:	619c      	str	r4, [r3, #24]
100027f6:	e00a      	b.n	1000280e <I2C003_lConfigSCLPin+0x72>
 			                ((uint32_t)I2C003_OPENDRAIN_OUT << (3U + \
							(TempPortPin * 8U)));
    }
    else if ((THIRD_NIBBLE <= TempPortPin) && (FOURTH_NIBBLE > TempPortPin))
100027f8:	380c      	subs	r0, #12
100027fa:	2803      	cmp	r0, #3
100027fc:	d807      	bhi.n	1000280e <I2C003_lConfigSCLPin+0x72>
    {
	  TempPortPin = TempPortPin - 12U;
	  Handle->PinHandle.SCL_PortBase->IOCR12 |= \
			                ((uint32_t)I2C003_OPENDRAIN_OUT << (3U + \
							(TempPortPin * 8U)));
100027fe:	00c2      	lsls	r2, r0, #3
    }
    else if ((THIRD_NIBBLE <= TempPortPin) && (FOURTH_NIBBLE > TempPortPin))
    {
	  TempPortPin = TempPortPin - 12U;
	  Handle->PinHandle.SCL_PortBase->IOCR12 |= \
			                ((uint32_t)I2C003_OPENDRAIN_OUT << (3U + \
10002800:	3203      	adds	r2, #3
10002802:	2018      	movs	r0, #24
							(TempPortPin * 8U)));
    }
    else if ((THIRD_NIBBLE <= TempPortPin) && (FOURTH_NIBBLE > TempPortPin))
    {
	  TempPortPin = TempPortPin - 12U;
	  Handle->PinHandle.SCL_PortBase->IOCR12 |= \
10002804:	69d9      	ldr	r1, [r3, #28]
			                ((uint32_t)I2C003_OPENDRAIN_OUT << (3U + \
10002806:	4090      	lsls	r0, r2
10002808:	1c04      	adds	r4, r0, #0
							(TempPortPin * 8U)));
    }
    else if ((THIRD_NIBBLE <= TempPortPin) && (FOURTH_NIBBLE > TempPortPin))
    {
	  TempPortPin = TempPortPin - 12U;
	  Handle->PinHandle.SCL_PortBase->IOCR12 |= \
1000280a:	430c      	orrs	r4, r1
1000280c:	61dc      	str	r4, [r3, #28]
							(TempPortPin * 8U)));
    }
	else
	{}

}
1000280e:	bd10      	pop	{r4, pc}

10002810 <I2C003_lConfigSDAPin>:
 * @return  None <BR>
 *
 * <b>Reentrant: No </b><BR>
 ******************************************************************************/
void I2C003_lConfigSDAPin(const I2C003_HandleType* Handle)
{
10002810:	b510      	push	{r4, lr}
	uint32_t TempPortPin;

    /* Set SDA port pin to '1' */
    Handle->PinHandle.SDA_PortBase->OMR |= (uint32_t)SHIFT_ONE << \
10002812:	68c3      	ldr	r3, [r0, #12]
10002814:	7c02      	ldrb	r2, [r0, #16]
10002816:	2401      	movs	r4, #1
10002818:	6859      	ldr	r1, [r3, #4]
1000281a:	4094      	lsls	r4, r2
1000281c:	1c22      	adds	r2, r4, #0
1000281e:	430a      	orrs	r2, r1
10002820:	605a      	str	r2, [r3, #4]
    		                                    Handle->PinHandle.SDA_Pin;
    /* Configure SDA port pin as Open-drain General-purpose output */
    TempPortPin = (uint32_t)Handle->PinHandle.SDA_Pin;
10002822:	7c00      	ldrb	r0, [r0, #16]
    if (FIRST_NIBBLE > TempPortPin)
10002824:	2803      	cmp	r0, #3
10002826:	d808      	bhi.n	1000283a <I2C003_lConfigSDAPin+0x2a>
    {
      Handle->PinHandle.SDA_PortBase->IOCR0 |= \
    		               ((uint32_t)I2C003_OPENDRAIN_OUT << (3U + \
						   (TempPortPin * 8U)));
10002828:	00c2      	lsls	r2, r0, #3
    /* Configure SDA port pin as Open-drain General-purpose output */
    TempPortPin = (uint32_t)Handle->PinHandle.SDA_Pin;
    if (FIRST_NIBBLE > TempPortPin)
    {
      Handle->PinHandle.SDA_PortBase->IOCR0 |= \
    		               ((uint32_t)I2C003_OPENDRAIN_OUT << (3U + \
1000282a:	3203      	adds	r2, #3
1000282c:	2018      	movs	r0, #24
    		                                    Handle->PinHandle.SDA_Pin;
    /* Configure SDA port pin as Open-drain General-purpose output */
    TempPortPin = (uint32_t)Handle->PinHandle.SDA_Pin;
    if (FIRST_NIBBLE > TempPortPin)
    {
      Handle->PinHandle.SDA_PortBase->IOCR0 |= \
1000282e:	6919      	ldr	r1, [r3, #16]
    		               ((uint32_t)I2C003_OPENDRAIN_OUT << (3U + \
10002830:	4090      	lsls	r0, r2
10002832:	1c04      	adds	r4, r0, #0
    		                                    Handle->PinHandle.SDA_Pin;
    /* Configure SDA port pin as Open-drain General-purpose output */
    TempPortPin = (uint32_t)Handle->PinHandle.SDA_Pin;
    if (FIRST_NIBBLE > TempPortPin)
    {
      Handle->PinHandle.SDA_PortBase->IOCR0 |= \
10002834:	430c      	orrs	r4, r1
10002836:	611c      	str	r4, [r3, #16]
10002838:	e023      	b.n	10002882 <I2C003_lConfigSDAPin+0x72>
    		               ((uint32_t)I2C003_OPENDRAIN_OUT << (3U + \
						   (TempPortPin * 8U)));
    }
    else if ((FIRST_NIBBLE <= TempPortPin) && (SECOND_NIBBLE > TempPortPin))
1000283a:	1f01      	subs	r1, r0, #4
1000283c:	2903      	cmp	r1, #3
1000283e:	d808      	bhi.n	10002852 <I2C003_lConfigSDAPin+0x42>
    {
 	  TempPortPin = TempPortPin - 4U;
 	  Handle->PinHandle.SDA_PortBase->IOCR4 |= \
 			               ((uint32_t)I2C003_OPENDRAIN_OUT << (3U + \
						   (TempPortPin * 8U)));
10002840:	00c9      	lsls	r1, r1, #3
    }
    else if ((FIRST_NIBBLE <= TempPortPin) && (SECOND_NIBBLE > TempPortPin))
    {
 	  TempPortPin = TempPortPin - 4U;
 	  Handle->PinHandle.SDA_PortBase->IOCR4 |= \
 			               ((uint32_t)I2C003_OPENDRAIN_OUT << (3U + \
10002842:	3103      	adds	r1, #3
10002844:	2018      	movs	r0, #24
						   (TempPortPin * 8U)));
    }
    else if ((FIRST_NIBBLE <= TempPortPin) && (SECOND_NIBBLE > TempPortPin))
    {
 	  TempPortPin = TempPortPin - 4U;
 	  Handle->PinHandle.SDA_PortBase->IOCR4 |= \
10002846:	695a      	ldr	r2, [r3, #20]
 			               ((uint32_t)I2C003_OPENDRAIN_OUT << (3U + \
10002848:	4088      	lsls	r0, r1
1000284a:	1c04      	adds	r4, r0, #0
						   (TempPortPin * 8U)));
    }
    else if ((FIRST_NIBBLE <= TempPortPin) && (SECOND_NIBBLE > TempPortPin))
    {
 	  TempPortPin = TempPortPin - 4U;
 	  Handle->PinHandle.SDA_PortBase->IOCR4 |= \
1000284c:	4314      	orrs	r4, r2
1000284e:	615c      	str	r4, [r3, #20]
10002850:	e017      	b.n	10002882 <I2C003_lConfigSDAPin+0x72>
 			               ((uint32_t)I2C003_OPENDRAIN_OUT << (3U + \
						   (TempPortPin * 8U)));
    }
    else if ((SECOND_NIBBLE <= TempPortPin) && (THIRD_NIBBLE >= TempPortPin))
10002852:	1c04      	adds	r4, r0, #0
10002854:	3c08      	subs	r4, #8
10002856:	2c04      	cmp	r4, #4
10002858:	d808      	bhi.n	1000286c <I2C003_lConfigSDAPin+0x5c>
    {
      TempPortPin = TempPortPin - 8U;
      Handle->PinHandle.SDA_PortBase->IOCR8 |= \
    		               ((uint32_t)I2C003_OPENDRAIN_OUT << (3U + \
						   (TempPortPin * 8U)));
1000285a:	00e1      	lsls	r1, r4, #3
    }
    else if ((SECOND_NIBBLE <= TempPortPin) && (THIRD_NIBBLE >= TempPortPin))
    {
      TempPortPin = TempPortPin - 8U;
      Handle->PinHandle.SDA_PortBase->IOCR8 |= \
    		               ((uint32_t)I2C003_OPENDRAIN_OUT << (3U + \
1000285c:	3103      	adds	r1, #3
1000285e:	2018      	movs	r0, #24
						   (TempPortPin * 8U)));
    }
    else if ((SECOND_NIBBLE <= TempPortPin) && (THIRD_NIBBLE >= TempPortPin))
    {
      TempPortPin = TempPortPin - 8U;
      Handle->PinHandle.SDA_PortBase->IOCR8 |= \
10002860:	699a      	ldr	r2, [r3, #24]
    		               ((uint32_t)I2C003_OPENDRAIN_OUT << (3U + \
10002862:	4088      	lsls	r0, r1
10002864:	1c04      	adds	r4, r0, #0
						   (TempPortPin * 8U)));
    }
    else if ((SECOND_NIBBLE <= TempPortPin) && (THIRD_NIBBLE >= TempPortPin))
    {
      TempPortPin = TempPortPin - 8U;
      Handle->PinHandle.SDA_PortBase->IOCR8 |= \
10002866:	4314      	orrs	r4, r2
10002868:	619c      	str	r4, [r3, #24]
1000286a:	e00a      	b.n	10002882 <I2C003_lConfigSDAPin+0x72>
    		               ((uint32_t)I2C003_OPENDRAIN_OUT << (3U + \
						   (TempPortPin * 8U)));
    }
    else if ((THIRD_NIBBLE <= TempPortPin) && (FOURTH_NIBBLE >= TempPortPin))
1000286c:	380c      	subs	r0, #12
1000286e:	2804      	cmp	r0, #4
10002870:	d807      	bhi.n	10002882 <I2C003_lConfigSDAPin+0x72>
    {
 	  TempPortPin = TempPortPin - 12U;
 	  Handle->PinHandle.SDA_PortBase->IOCR12 |= \
 			               ((uint32_t)I2C003_OPENDRAIN_OUT << (3U + \
						   (TempPortPin * 8U)));
10002872:	00c2      	lsls	r2, r0, #3
    }
    else if ((THIRD_NIBBLE <= TempPortPin) && (FOURTH_NIBBLE >= TempPortPin))
    {
 	  TempPortPin = TempPortPin - 12U;
 	  Handle->PinHandle.SDA_PortBase->IOCR12 |= \
 			               ((uint32_t)I2C003_OPENDRAIN_OUT << (3U + \
10002874:	3203      	adds	r2, #3
10002876:	2018      	movs	r0, #24
						   (TempPortPin * 8U)));
    }
    else if ((THIRD_NIBBLE <= TempPortPin) && (FOURTH_NIBBLE >= TempPortPin))
    {
 	  TempPortPin = TempPortPin - 12U;
 	  Handle->PinHandle.SDA_PortBase->IOCR12 |= \
10002878:	69d9      	ldr	r1, [r3, #28]
 			               ((uint32_t)I2C003_OPENDRAIN_OUT << (3U + \
1000287a:	4090      	lsls	r0, r2
1000287c:	1c04      	adds	r4, r0, #0
						   (TempPortPin * 8U)));
    }
    else if ((THIRD_NIBBLE <= TempPortPin) && (FOURTH_NIBBLE >= TempPortPin))
    {
 	  TempPortPin = TempPortPin - 12U;
 	  Handle->PinHandle.SDA_PortBase->IOCR12 |= \
1000287e:	430c      	orrs	r4, r1
10002880:	61dc      	str	r4, [r3, #28]
						   (TempPortPin * 8U)));
    }
	else
	{}

}
10002882:	bd10      	pop	{r4, pc}

10002884 <I2C003_Init>:
   
#if ((__TARGET_DEVICE__ == XMC13) || \
     (__TARGET_DEVICE__ == XMC12) || \
     (__TARGET_DEVICE__ == XMC11))
  /* Disable the USIC0/USIC1 clock gating for XMC1000 devices */    
  SCU_GENERAL->PASSWD = 0x000000C0UL;
10002884:	4a0e      	ldr	r2, [pc, #56]	; (100028c0 <I2C003_Init+0x3c>)
 * @return  None <BR>
 *
 * <b>Reentrant: No </b><BR>
 ******************************************************************************/
void I2C003_Init(void)
{
10002886:	b510      	push	{r4, lr}
   
#if ((__TARGET_DEVICE__ == XMC13) || \
     (__TARGET_DEVICE__ == XMC12) || \
     (__TARGET_DEVICE__ == XMC11))
  /* Disable the USIC0/USIC1 clock gating for XMC1000 devices */    
  SCU_GENERAL->PASSWD = 0x000000C0UL;
10002888:	23c0      	movs	r3, #192	; 0xc0
  WR_REG(SCU_CLK->CLKCR, SCU_CLK_CLKCR_CNTADJ_Msk, \
1000288a:	4c0e      	ldr	r4, [pc, #56]	; (100028c4 <I2C003_Init+0x40>)
   
#if ((__TARGET_DEVICE__ == XMC13) || \
     (__TARGET_DEVICE__ == XMC12) || \
     (__TARGET_DEVICE__ == XMC11))
  /* Disable the USIC0/USIC1 clock gating for XMC1000 devices */    
  SCU_GENERAL->PASSWD = 0x000000C0UL;
1000288c:	6253      	str	r3, [r2, #36]	; 0x24
  WR_REG(SCU_CLK->CLKCR, SCU_CLK_CLKCR_CNTADJ_Msk, \
1000288e:	6821      	ldr	r1, [r4, #0]
10002890:	480d      	ldr	r0, [pc, #52]	; (100028c8 <I2C003_Init+0x44>)
10002892:	4301      	orrs	r1, r0
10002894:	6021      	str	r1, [r4, #0]
                                SCU_CLK_CLKCR_CNTADJ_Pos,CLK002_DELAYCNT);

#if defined(I2C003_PER0_USIC0_ENABLED)
  SET_BIT(SCU_CLK->CGATCLR0, SCU_CLK_CGATCLR0_USIC0_Pos);
10002896:	6923      	ldr	r3, [r4, #16]
10002898:	2108      	movs	r1, #8
1000289a:	430b      	orrs	r3, r1
1000289c:	6123      	str	r3, [r4, #16]
#endif
#if defined(I2C003_PER1_USIC1_ENABLED)
  SET_BIT(SCU_CLK->CGATCLR1, SCU_CLK_CGATCLR1_USIC1_Pos);
#endif
  while ((SCU_CLK->CLKCR)&(SCU_CLK_CLKCR_VDDC2LOW_Msk))
1000289e:	6820      	ldr	r0, [r4, #0]
100028a0:	0040      	lsls	r0, r0, #1
100028a2:	d4fc      	bmi.n	1000289e <I2C003_Init+0x1a>
  {
  	;
  }
  SCU_GENERAL->PASSWD = 0x000000C3UL;
100028a4:	24c3      	movs	r4, #195	; 0xc3
100028a6:	6254      	str	r4, [r2, #36]	; 0x24
#endif  
  
  for (LoopIndex = (uint32_t)0; LoopIndex < (uint32_t)I2C003_NUM_HANDLES; \
                           LoopIndex++)
  {
	I2C003_lConfigSCLPin(I2C003_HandleArray[LoopIndex]);
100028a8:	4c08      	ldr	r4, [pc, #32]	; (100028cc <I2C003_Init+0x48>)
100028aa:	6820      	ldr	r0, [r4, #0]
100028ac:	f7ff ff76 	bl	1000279c <I2C003_lConfigSCLPin>
	I2C003_lConfigSDAPin(I2C003_HandleArray[LoopIndex]);
100028b0:	6820      	ldr	r0, [r4, #0]
100028b2:	f7ff ffad 	bl	10002810 <I2C003_lConfigSDAPin>
    I2C003_lInit(I2C003_HandleArray[LoopIndex]);
100028b6:	6820      	ldr	r0, [r4, #0]
100028b8:	f7ff ff14 	bl	100026e4 <I2C003_lInit>
  }
  
}
100028bc:	bd10      	pop	{r4, pc}
100028be:	46c0      	nop			; (mov r8, r8)
100028c0:	40010000 	.word	0x40010000
100028c4:	40010300 	.word	0x40010300
100028c8:	3ff00000 	.word	0x3ff00000
100028cc:	20000678 	.word	0x20000678

100028d0 <I2C003_WriteData>:
 *
 * <b>Reentrant: NO </b><BR>
 ******************************************************************************/
bool I2C003_WriteData(const I2C003_HandleType* Handle, \
                          const I2C003_DataType* Data)
{
100028d0:	b530      	push	{r4, r5, lr}
   bool Result = (bool)FALSE;
   USIC_CH_TypeDef* I2CRegs;
  
   I2CRegs = Handle->I2CRegs;  
100028d2:	6803      	ldr	r3, [r0, #0]
 * <b>Reentrant: NO </b><BR>
 ******************************************************************************/
bool I2C003_WriteData(const I2C003_HandleType* Handle, \
                          const I2C003_DataType* Data)
{
   bool Result = (bool)FALSE;
100028d4:	2200      	movs	r2, #0
   USIC_CH_TypeDef* I2CRegs;
  
   I2CRegs = Handle->I2CRegs;  

   if (!(USIC_CH_PSR_IICMode_WTDF_Msk & I2CRegs->PSR_IICMode))
100028d6:	6c9c      	ldr	r4, [r3, #72]	; 0x48
100028d8:	07a5      	lsls	r5, r4, #30
100028da:	d41a      	bmi.n	10002912 <I2C003_WriteData+0x42>
   {
	   if(Handle->TxFifoEn)
100028dc:	7f00      	ldrb	r0, [r0, #28]
100028de:	4290      	cmp	r0, r2
100028e0:	d00d      	beq.n	100028fe <I2C003_WriteData+0x2e>
	   {
		   if(!USIC_IsTxFIFOfull(I2CRegs))
100028e2:	1c18      	adds	r0, r3, #0
100028e4:	30fc      	adds	r0, #252	; 0xfc
100028e6:	6985      	ldr	r5, [r0, #24]
100028e8:	04ec      	lsls	r4, r5, #19
100028ea:	d412      	bmi.n	10002912 <I2C003_WriteData+0x42>
		   {
			 I2CRegs->IN[0] = \
						(((uint32_t)Data->TDF_Type << 8) | Data->Payload);
100028ec:	784a      	ldrb	r2, [r1, #1]
100028ee:	7808      	ldrb	r0, [r1, #0]
100028f0:	0214      	lsls	r4, r2, #8
100028f2:	1c21      	adds	r1, r4, #0
   {
	   if(Handle->TxFifoEn)
	   {
		   if(!USIC_IsTxFIFOfull(I2CRegs))
		   {
			 I2CRegs->IN[0] = \
100028f4:	25c0      	movs	r5, #192	; 0xc0
						(((uint32_t)Data->TDF_Type << 8) | Data->Payload);
100028f6:	4301      	orrs	r1, r0
   {
	   if(Handle->TxFifoEn)
	   {
		   if(!USIC_IsTxFIFOfull(I2CRegs))
		   {
			 I2CRegs->IN[0] = \
100028f8:	006a      	lsls	r2, r5, #1
100028fa:	5099      	str	r1, [r3, r2]
100028fc:	e008      	b.n	10002910 <I2C003_WriteData+0x40>
						(((uint32_t)Data->TDF_Type << 8) | Data->Payload);
			 Result = (bool)TRUE;    
		   }
	   }else if(!(USIC_CH_TCSR_TDV_Msk & I2CRegs->TCSR))
100028fe:	6b9d      	ldr	r5, [r3, #56]	; 0x38
10002900:	062d      	lsls	r5, r5, #24
10002902:	d406      	bmi.n	10002912 <I2C003_WriteData+0x42>
	   {
	       I2CRegs->TBUF[0] = (((uint32_t)Data->TDF_Type << 8) | Data->Payload);	
10002904:	784a      	ldrb	r2, [r1, #1]
10002906:	7809      	ldrb	r1, [r1, #0]
10002908:	0214      	lsls	r4, r2, #8
1000290a:	430c      	orrs	r4, r1
1000290c:	3304      	adds	r3, #4
1000290e:	67dc      	str	r4, [r3, #124]	; 0x7c
	       Result = (bool)TRUE;   
10002910:	2201      	movs	r2, #1
	   }
   }
   
   return Result;
}
10002912:	1c10      	adds	r0, r2, #0
10002914:	bd30      	pop	{r4, r5, pc}

10002916 <I2C003_ReadData>:
 *             FALSE  : if FIFO is empty.<BR>
 *
 * <b>Reentrant: NO </b><BR>
 ******************************************************************************/
bool I2C003_ReadData(const I2C003_HandleType* Handle, uint8_t* Buffer)
{ 
10002916:	b510      	push	{r4, lr}
  bool Result = (bool)FALSE;
  USIC_CH_TypeDef* I2CRegs;
  
  I2CRegs = Handle->I2CRegs;  

  if(Handle->RxFifoEn)
10002918:	7f42      	ldrb	r2, [r0, #29]
bool I2C003_ReadData(const I2C003_HandleType* Handle, uint8_t* Buffer)
{ 
  bool Result = (bool)FALSE;
  USIC_CH_TypeDef* I2CRegs;
  
  I2CRegs = Handle->I2CRegs;  
1000291a:	6803      	ldr	r3, [r0, #0]

  if(Handle->RxFifoEn)
1000291c:	2a00      	cmp	r2, #0
1000291e:	d006      	beq.n	1000292e <I2C003_ReadData+0x18>
  {
	  if (!USIC_ubIsRxFIFOempty(I2CRegs))
10002920:	33fc      	adds	r3, #252	; 0xfc
10002922:	699c      	ldr	r4, [r3, #24]
 *
 * <b>Reentrant: NO </b><BR>
 ******************************************************************************/
bool I2C003_ReadData(const I2C003_HandleType* Handle, uint8_t* Buffer)
{ 
  bool Result = (bool)FALSE;
10002924:	2000      	movs	r0, #0
  
  I2CRegs = Handle->I2CRegs;  

  if(Handle->RxFifoEn)
  {
	  if (!USIC_ubIsRxFIFOempty(I2CRegs))
10002926:	0724      	lsls	r4, r4, #28
10002928:	d404      	bmi.n	10002934 <I2C003_ReadData+0x1e>
	  {
		*Buffer = (uint8_t)I2CRegs->OUTR;
1000292a:	6a18      	ldr	r0, [r3, #32]
1000292c:	e000      	b.n	10002930 <I2C003_ReadData+0x1a>
		Result = (bool)TRUE;
	  }
  }else
  {
	  *Buffer = (uint8_t)I2CRegs->RBUF;
1000292e:	6d58      	ldr	r0, [r3, #84]	; 0x54
10002930:	7008      	strb	r0, [r1, #0]
	  Result = (bool)TRUE;
10002932:	2001      	movs	r0, #1
  }
  return Result;
}
10002934:	bd10      	pop	{r4, pc}

10002936 <I2C003_ClearFlag>:
void I2C003_ClearFlag(const I2C003_HandleType* Handle, \
                            I2C003_FlagStatusType Flag)
{
  USIC_CH_TypeDef* I2CRegs;
  
  I2CRegs = Handle->I2CRegs;
10002936:	6803      	ldr	r3, [r0, #0]

  if (I2C003_FLAG_RIF >= Flag)
10002938:	2904      	cmp	r1, #4
1000293a:	d804      	bhi.n	10002946 <I2C003_ClearFlag+0x10>
  {
    I2CRegs->PSCR = ((uint32_t)SHIFT_ONE << (((uint32_t)Flag - \
                    (uint32_t)I2C003_FLAG_RSIF) + INDICATION_FLG_OFFSET));
1000293c:	310a      	adds	r1, #10
  
  I2CRegs = Handle->I2CRegs;

  if (I2C003_FLAG_RIF >= Flag)
  {
    I2CRegs->PSCR = ((uint32_t)SHIFT_ONE << (((uint32_t)Flag - \
1000293e:	2001      	movs	r0, #1
10002940:	4088      	lsls	r0, r1
10002942:	64d8      	str	r0, [r3, #76]	; 0x4c
10002944:	e00d      	b.n	10002962 <I2C003_ClearFlag+0x2c>
                    (uint32_t)I2C003_FLAG_RSIF) + INDICATION_FLG_OFFSET));
  }
  else if (I2C003_FLAG_NACK_RECEIVED == Flag)
  {
    I2CRegs->PSCR = ((uint32_t)SHIFT_ONE << (uint32_t)I2C003_FLAG_WRONG_TDF);
10002946:	2220      	movs	r2, #32
  if (I2C003_FLAG_RIF >= Flag)
  {
    I2CRegs->PSCR = ((uint32_t)SHIFT_ONE << (((uint32_t)Flag - \
                    (uint32_t)I2C003_FLAG_RSIF) + INDICATION_FLG_OFFSET));
  }
  else if (I2C003_FLAG_NACK_RECEIVED == Flag)
10002948:	2906      	cmp	r1, #6
1000294a:	d009      	beq.n	10002960 <I2C003_ClearFlag+0x2a>
  {
    I2CRegs->PSCR = ((uint32_t)SHIFT_ONE << (uint32_t)I2C003_FLAG_WRONG_TDF);
  }
  else if (I2C003_FLAG_WRONG_TDF == Flag)
  {
    I2CRegs->PSCR = ((uint32_t)SHIFT_ONE << (uint32_t)I2C003_FLAG_DLIF);	
1000294c:	2202      	movs	r2, #2
  }
  else if (I2C003_FLAG_NACK_RECEIVED == Flag)
  {
    I2CRegs->PSCR = ((uint32_t)SHIFT_ONE << (uint32_t)I2C003_FLAG_WRONG_TDF);
  }
  else if (I2C003_FLAG_WRONG_TDF == Flag)
1000294e:	2905      	cmp	r1, #5
10002950:	d006      	beq.n	10002960 <I2C003_ClearFlag+0x2a>
10002952:	2201      	movs	r2, #1
  {
    I2CRegs->PSCR = ((uint32_t)SHIFT_ONE << (uint32_t)I2C003_FLAG_DLIF);	
  }
  else if (I2C003_FLAG_RBERI >= Flag)
10002954:	2908      	cmp	r1, #8
10002956:	d801      	bhi.n	1000295c <I2C003_ClearFlag+0x26>
  {
    I2CRegs->PSCR = \
	     ((uint32_t)SHIFT_ONE << ((uint32_t)Flag - (uint32_t)I2C003_FLAG_SRBI));
10002958:	3907      	subs	r1, #7
1000295a:	e000      	b.n	1000295e <I2C003_ClearFlag+0x28>
  }
  else
  {
    I2CRegs->PSCR = ((uint32_t)SHIFT_ONE << (((uint32_t)Flag - \
                    (uint32_t)I2C003_FLAG_STBI) + STATUS_FLG_OFFSET));
1000295c:	3901      	subs	r1, #1
    I2CRegs->PSCR = \
	     ((uint32_t)SHIFT_ONE << ((uint32_t)Flag - (uint32_t)I2C003_FLAG_SRBI));
  }
  else
  {
    I2CRegs->PSCR = ((uint32_t)SHIFT_ONE << (((uint32_t)Flag - \
1000295e:	408a      	lsls	r2, r1
10002960:	64da      	str	r2, [r3, #76]	; 0x4c
                    (uint32_t)I2C003_FLAG_STBI) + STATUS_FLG_OFFSET));
  }
}
10002962:	4770      	bx	lr

10002964 <FLASH003_Init>:
void FLASH003_Init()
{
	const FLASH003_HandleType* Handle;
	Handle = &FLASH003_Handle0;
    /*Enabling flash Idle State*/
	Handle->FlashRegsPtr->NVMPROG = FLASH003_ECCVERRRST_IDLESET;
10002964:	4b07      	ldr	r3, [pc, #28]	; (10002984 <FLASH003_Init+0x20>)
10002966:	22c0      	movs	r2, #192	; 0xc0
10002968:	68d8      	ldr	r0, [r3, #12]
1000296a:	0191      	lsls	r1, r2, #6
1000296c:	8081      	strh	r1, [r0, #4]
    /*reset ECC2READ,ECC1READ in NVMSTATUS*/
    SET_BIT(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_RSTECC_Pos);
1000296e:	8883      	ldrh	r3, [r0, #4]
10002970:	2280      	movs	r2, #128	; 0x80
10002972:	0191      	lsls	r1, r2, #6
10002974:	4319      	orrs	r1, r3
10002976:	8081      	strh	r1, [r0, #4]
    /*reset Write protocol error in NVMSTATUS*/
    SET_BIT(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_RSTVERR_Pos);
10002978:	8883      	ldrh	r3, [r0, #4]
1000297a:	2280      	movs	r2, #128	; 0x80
1000297c:	0151      	lsls	r1, r2, #5
1000297e:	4319      	orrs	r1, r3
10002980:	8081      	strh	r1, [r0, #4]
    #if (FLASH003_ECC_INTERRUPT == FLASH003_INTR_ENABLED)
	FLASH003_RegisterCallbackEvent(FLASH003_FLECC2I,FLASH003_ECC_EVENT,0);
	NVIC_SR001_RegisterCallback(NVIC_SR001_FLECC2I,FLASH003_lEccInterrupt,0U);
	#endif
	
}
10002982:	4770      	bx	lr
10002984:	1000448c 	.word	0x1000448c

10002988 <FLASH003_ClearStatus>:
{
	const FLASH003_HandleType* Handle;
	Handle = &FLASH003_Handle0;
	/*clear error status*/
    /*reset ECC2READ,ECC1READ in NVMSTATUS*/
    SET_BIT(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_RSTECC_Pos);
10002988:	4b06      	ldr	r3, [pc, #24]	; (100029a4 <FLASH003_ClearStatus+0x1c>)
1000298a:	2280      	movs	r2, #128	; 0x80
1000298c:	68d8      	ldr	r0, [r3, #12]
1000298e:	0193      	lsls	r3, r2, #6
10002990:	8881      	ldrh	r1, [r0, #4]
    /*reset Write protocol error in NVMSTATUS*/
    SET_BIT(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_RSTVERR_Pos);
10002992:	2280      	movs	r2, #128	; 0x80
{
	const FLASH003_HandleType* Handle;
	Handle = &FLASH003_Handle0;
	/*clear error status*/
    /*reset ECC2READ,ECC1READ in NVMSTATUS*/
    SET_BIT(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_RSTECC_Pos);
10002994:	430b      	orrs	r3, r1
10002996:	8083      	strh	r3, [r0, #4]
    /*reset Write protocol error in NVMSTATUS*/
    SET_BIT(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_RSTVERR_Pos);
10002998:	8881      	ldrh	r1, [r0, #4]
1000299a:	0153      	lsls	r3, r2, #5
1000299c:	430b      	orrs	r3, r1
1000299e:	8083      	strh	r3, [r0, #4]
}
100029a0:	4770      	bx	lr
100029a2:	46c0      	nop			; (mov r8, r8)
100029a4:	1000448c 	.word	0x1000448c

100029a8 <FLASH003_lWriteBlock>:
/*
 *  The function is local to Flash app 
 *  used to write the block of data
 */
void FLASH003_lWriteBlock (uint32_t Address, const uint32_t pBuf[])
{
100029a8:	b510      	push	{r4, lr}
    uint32_t lWord_Cnt;
    const FLASH003_HandleType* Handle;
	Handle = &FLASH003_Handle0;
    /*updating the ACTION with Oneshot Write and Auto Verify*/
    WR_REG(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_ACTION_Msk,\
100029aa:	4b0e      	ldr	r3, [pc, #56]	; (100029e4 <FLASH003_lWriteBlock+0x3c>)
100029ac:	24ff      	movs	r4, #255	; 0xff
100029ae:	68da      	ldr	r2, [r3, #12]
100029b0:	8893      	ldrh	r3, [r2, #4]
100029b2:	43a3      	bics	r3, r4
100029b4:	2451      	movs	r4, #81	; 0x51
100029b6:	4323      	orrs	r3, r4
100029b8:	8093      	strh	r3, [r2, #4]
100029ba:	2300      	movs	r3, #0
    		          NVM_NVMPROG_ACTION_Pos,FLASH003_ONESHOT_WRITE_AUTOVERIFY);
    /*Writing a Block of Data*/
    for(lWord_Cnt = 0U;lWord_Cnt < FLASH003_WORD_SIZE;lWord_Cnt++)
    {
      *((uint32_t *) (Address + (FLASH003_WORD_SIZE * lWord_Cnt) )) = \
100029bc:	58cc      	ldr	r4, [r1, r3]
100029be:	501c      	str	r4, [r3, r0]
100029c0:	3304      	adds	r3, #4
	Handle = &FLASH003_Handle0;
    /*updating the ACTION with Oneshot Write and Auto Verify*/
    WR_REG(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_ACTION_Msk,\
    		          NVM_NVMPROG_ACTION_Pos,FLASH003_ONESHOT_WRITE_AUTOVERIFY);
    /*Writing a Block of Data*/
    for(lWord_Cnt = 0U;lWord_Cnt < FLASH003_WORD_SIZE;lWord_Cnt++)
100029c2:	2b10      	cmp	r3, #16
100029c4:	d1fa      	bne.n	100029bc <FLASH003_lWriteBlock+0x14>
                                                                pBuf[lWord_Cnt];
    }

    #if (FLASH003_SEQ_INTERRUPT != FLASH003_INTR_ENABLED)
    /*Polling Busy Flag until Idle State*/
    while(RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_BUSY_Msk,\
100029c6:	8810      	ldrh	r0, [r2, #0]
100029c8:	07c1      	lsls	r1, r0, #31
100029ca:	d4fc      	bmi.n	100029c6 <FLASH003_lWriteBlock+0x1e>
    		                          NVM_NVMSTATUS_BUSY_Pos) != FLASH003_RESET)
    {
      ;
    }
    /*Wait for 10us to complete the verification(need to check)*/
    WR_REG(SCU_CLK->CLKCR, SCU_CLK_CLKCR_CNTADJ_Msk, SCU_CLK_CLKCR_CNTADJ_Pos,\
100029cc:	4b06      	ldr	r3, [pc, #24]	; (100029e8 <FLASH003_lWriteBlock+0x40>)
100029ce:	4a07      	ldr	r2, [pc, #28]	; (100029ec <FLASH003_lWriteBlock+0x44>)
100029d0:	6819      	ldr	r1, [r3, #0]
100029d2:	4c07      	ldr	r4, [pc, #28]	; (100029f0 <FLASH003_lWriteBlock+0x48>)
100029d4:	400a      	ands	r2, r1
100029d6:	4322      	orrs	r2, r4
100029d8:	601a      	str	r2, [r3, #0]
                                                            FLASH003_DELAY);
    while (SCU_CLK->CLKCR&(SCU_CLK_CLKCR_VDDC2LOW_Msk))
100029da:	6818      	ldr	r0, [r3, #0]
100029dc:	0044      	lsls	r4, r0, #1
100029de:	d4fc      	bmi.n	100029da <FLASH003_lWriteBlock+0x32>
    {
      ;
    }
    #endif
}
100029e0:	bd10      	pop	{r4, pc}
100029e2:	46c0      	nop			; (mov r8, r8)
100029e4:	1000448c 	.word	0x1000448c
100029e8:	40010300 	.word	0x40010300
100029ec:	c00fffff 	.word	0xc00fffff
100029f0:	2aa00000 	.word	0x2aa00000

100029f4 <FLASH003_WriteMultipleBlocks>:
 *  The function programs Multiple No_of_Blocks of the Flash using
 *  WriteMultipleBlocks command
 */
status_t FLASH003_WriteMultipleBlocks(uint32_t Address,const uint32_t pBuf[],\
                                                          uint32_t No_of_Blocks)
{
100029f4:	b5f0      	push	{r4, r5, r6, r7, lr}
      Handle = &FLASH003_Handle0;
      status = FLASH003_IN_PROGRESS;
      /*calculation of the last byte address*/
      final_blk_end_add = (uint32_t)((uint32_t)Address + \
                    (uint32_t)(No_of_Blocks*FLASH003_BLOCK_SIZE)) - 1U;
      rd1 = RD_REG(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_ACTION_Msk,\
100029f6:	4b1b      	ldr	r3, [pc, #108]	; (10002a64 <FLASH003_WriteMultipleBlocks+0x70>)
 *  The function programs Multiple No_of_Blocks of the Flash using
 *  WriteMultipleBlocks command
 */
status_t FLASH003_WriteMultipleBlocks(uint32_t Address,const uint32_t pBuf[],\
                                                          uint32_t No_of_Blocks)
{
100029f8:	1c04      	adds	r4, r0, #0
      Handle = &FLASH003_Handle0;
      status = FLASH003_IN_PROGRESS;
      /*calculation of the last byte address*/
      final_blk_end_add = (uint32_t)((uint32_t)Address + \
                    (uint32_t)(No_of_Blocks*FLASH003_BLOCK_SIZE)) - 1U;
      rd1 = RD_REG(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_ACTION_Msk,\
100029fa:	68d8      	ldr	r0, [r3, #12]
 *  The function programs Multiple No_of_Blocks of the Flash using
 *  WriteMultipleBlocks command
 */
status_t FLASH003_WriteMultipleBlocks(uint32_t Address,const uint32_t pBuf[],\
                                                          uint32_t No_of_Blocks)
{
100029fc:	b085      	sub	sp, #20
      Handle = &FLASH003_Handle0;
      status = FLASH003_IN_PROGRESS;
      /*calculation of the last byte address*/
      final_blk_end_add = (uint32_t)((uint32_t)Address + \
                    (uint32_t)(No_of_Blocks*FLASH003_BLOCK_SIZE)) - 1U;
      rd1 = RD_REG(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_ACTION_Msk,\
100029fe:	9001      	str	r0, [sp, #4]
 *  The function programs Multiple No_of_Blocks of the Flash using
 *  WriteMultipleBlocks command
 */
status_t FLASH003_WriteMultipleBlocks(uint32_t Address,const uint32_t pBuf[],\
                                                          uint32_t No_of_Blocks)
{
10002a00:	9102      	str	r1, [sp, #8]
10002a02:	1c17      	adds	r7, r2, #0
      rd2 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_BUSY_Msk,\
    		                                            NVM_NVMSTATUS_BUSY_Pos);
      rd3 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_SLEEP_Msk,\
    		                                           NVM_NVMSTATUS_SLEEP_Pos);
      /*validate the Address for Range and Block Alignment*/
      if((Address < Handle->kStart_Address) || (Address > Handle->kEnd_Address)\
10002a04:	685d      	ldr	r5, [r3, #4]
      Handle = &FLASH003_Handle0;
      status = FLASH003_IN_PROGRESS;
      /*calculation of the last byte address*/
      final_blk_end_add = (uint32_t)((uint32_t)Address + \
                    (uint32_t)(No_of_Blocks*FLASH003_BLOCK_SIZE)) - 1U;
      rd1 = RD_REG(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_ACTION_Msk,\
10002a06:	8882      	ldrh	r2, [r0, #4]
    		                                            NVM_NVMPROG_ACTION_Pos);
      rd2 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_BUSY_Msk,\
10002a08:	8806      	ldrh	r6, [r0, #0]
    		                                            NVM_NVMSTATUS_BUSY_Pos);
      rd3 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_SLEEP_Msk,\
10002a0a:	8801      	ldrh	r1, [r0, #0]
      /*validate the Address for Range and Block Alignment*/
      if((Address < Handle->kStart_Address) || (Address > Handle->kEnd_Address)\
    		                  || (final_blk_end_add > Handle->kEnd_Address) || \
                                 ((Address & FLASH003_BLOCK_ALIGN_CHECK) != 0U))
      {
        status = FLASH003_INVALID_ADDRESS;
10002a0c:	2001      	movs	r0, #1
                    (uint32_t)(No_of_Blocks*FLASH003_BLOCK_SIZE)) - 1U;
      rd1 = RD_REG(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_ACTION_Msk,\
    		                                            NVM_NVMPROG_ACTION_Pos);
      rd2 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_BUSY_Msk,\
    		                                            NVM_NVMSTATUS_BUSY_Pos);
      rd3 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_SLEEP_Msk,\
10002a0e:	468c      	mov	ip, r1
    		                                           NVM_NVMSTATUS_SLEEP_Pos);
      /*validate the Address for Range and Block Alignment*/
      if((Address < Handle->kStart_Address) || (Address > Handle->kEnd_Address)\
10002a10:	42ac      	cmp	r4, r5
10002a12:	d325      	bcc.n	10002a60 <FLASH003_WriteMultipleBlocks+0x6c>
10002a14:	689b      	ldr	r3, [r3, #8]
10002a16:	429c      	cmp	r4, r3
10002a18:	d822      	bhi.n	10002a60 <FLASH003_WriteMultipleBlocks+0x6c>
      DynamicHandle->FLASH003_global_status = FLASH003_IN_PROGRESS;
    #endif
      Handle = &FLASH003_Handle0;
      status = FLASH003_IN_PROGRESS;
      /*calculation of the last byte address*/
      final_blk_end_add = (uint32_t)((uint32_t)Address + \
10002a1a:	1e65      	subs	r5, r4, #1
                    (uint32_t)(No_of_Blocks*FLASH003_BLOCK_SIZE)) - 1U;
10002a1c:	0139      	lsls	r1, r7, #4
      DynamicHandle->FLASH003_global_status = FLASH003_IN_PROGRESS;
    #endif
      Handle = &FLASH003_Handle0;
      status = FLASH003_IN_PROGRESS;
      /*calculation of the last byte address*/
      final_blk_end_add = (uint32_t)((uint32_t)Address + \
10002a1e:	186d      	adds	r5, r5, r1
    		                                            NVM_NVMSTATUS_BUSY_Pos);
      rd3 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_SLEEP_Msk,\
    		                                           NVM_NVMSTATUS_SLEEP_Pos);
      /*validate the Address for Range and Block Alignment*/
      if((Address < Handle->kStart_Address) || (Address > Handle->kEnd_Address)\
    		                  || (final_blk_end_add > Handle->kEnd_Address) || \
10002a20:	429d      	cmp	r5, r3
10002a22:	d81d      	bhi.n	10002a60 <FLASH003_WriteMultipleBlocks+0x6c>
10002a24:	0723      	lsls	r3, r4, #28
10002a26:	d11b      	bne.n	10002a60 <FLASH003_WriteMultipleBlocks+0x6c>
      /*calculation of the last byte address*/
      final_blk_end_add = (uint32_t)((uint32_t)Address + \
                    (uint32_t)(No_of_Blocks*FLASH003_BLOCK_SIZE)) - 1U;
      rd1 = RD_REG(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_ACTION_Msk,\
    		                                            NVM_NVMPROG_ACTION_Pos);
      rd2 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_BUSY_Msk,\
10002a28:	4006      	ands	r6, r0
      Handle = &FLASH003_Handle0;
      status = FLASH003_IN_PROGRESS;
      /*calculation of the last byte address*/
      final_blk_end_add = (uint32_t)((uint32_t)Address + \
                    (uint32_t)(No_of_Blocks*FLASH003_BLOCK_SIZE)) - 1U;
      rd1 = RD_REG(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_ACTION_Msk,\
10002a2a:	b2d0      	uxtb	r0, r2
    		                                            NVM_NVMPROG_ACTION_Pos);
      rd2 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_BUSY_Msk,\
    		                                            NVM_NVMSTATUS_BUSY_Pos);
      rd3 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_SLEEP_Msk,\
10002a2c:	4662      	mov	r2, ip
10002a2e:	0793      	lsls	r3, r2, #30
		#if (FLASH003_SEQ_INTERRUPT == FLASH003_INTR_ENABLED)
            DynamicHandle->FLASH003_global_status = FLASH003_IDLE;
        #endif
      }
      /*Checking for the status of Flash for Idle and Sleep Mode*/
      else if((rd1 == FLASH003_RESET) && (rd2 == FLASH003_RESET) && \
10002a30:	4306      	orrs	r6, r0
                    (uint32_t)(No_of_Blocks*FLASH003_BLOCK_SIZE)) - 1U;
      rd1 = RD_REG(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_ACTION_Msk,\
    		                                            NVM_NVMPROG_ACTION_Pos);
      rd2 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_BUSY_Msk,\
    		                                            NVM_NVMSTATUS_BUSY_Pos);
      rd3 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_SLEEP_Msk,\
10002a32:	0fd9      	lsrs	r1, r3, #31
		#if (FLASH003_SEQ_INTERRUPT == FLASH003_INTR_ENABLED)
            DynamicHandle->FLASH003_global_status = FLASH003_IDLE;
        #endif
      }
      /*Checking for the status of Flash for Idle and Sleep Mode*/
      else if((rd1 == FLASH003_RESET) && (rd2 == FLASH003_RESET) && \
10002a34:	430e      	orrs	r6, r1
10002a36:	d001      	beq.n	10002a3c <FLASH003_WriteMultipleBlocks+0x48>
          }
        }
      }
      else
      {
        status = FLASH003_ERROR;
10002a38:	2002      	movs	r0, #2
10002a3a:	e011      	b.n	10002a60 <FLASH003_WriteMultipleBlocks+0x6c>
		#if (FLASH003_SEQ_INTERRUPT == FLASH003_INTR_ENABLED)
            DynamicHandle->FLASH003_global_status = FLASH003_IDLE;
        #endif
      }
      /*Checking for the status of Flash for Idle and Sleep Mode*/
      else if((rd1 == FLASH003_RESET) && (rd2 == FLASH003_RESET) && \
10002a3c:	1c25      	adds	r5, r4, #0
10002a3e:	2003      	movs	r0, #3
             (rd3 == FLASH003_RESET))
      {
        for(lBlk_Cnt = 0U;lBlk_Cnt < (uint32_t)No_of_Blocks;lBlk_Cnt++)
10002a40:	42be      	cmp	r6, r7
10002a42:	d00d      	beq.n	10002a60 <FLASH003_WriteMultipleBlocks+0x6c>

/*
 *  The function programs Multiple No_of_Blocks of the Flash using
 *  WriteMultipleBlocks command
 */
status_t FLASH003_WriteMultipleBlocks(uint32_t Address,const uint32_t pBuf[],\
10002a44:	9802      	ldr	r0, [sp, #8]
10002a46:	1b02      	subs	r2, r0, r4
10002a48:	1951      	adds	r1, r2, r5
        for(lBlk_Cnt = 0U;lBlk_Cnt < (uint32_t)No_of_Blocks;lBlk_Cnt++)
        {
          /*Updating the Address for each Block*/
          lAddress = Address+(FLASH003_BLOCK_SIZE*lBlk_Cnt);
          /*Calling Write Block API*/
          FLASH003_lWriteBlock (lAddress, pBuf+(FLASH003_WORD_SIZE*lBlk_Cnt));
10002a4a:	1c28      	adds	r0, r5, #0
10002a4c:	f7ff ffac 	bl	100029a8 <FLASH003_lWriteBlock>
          /*Checking for verification flag for any writing errors*/
          if(RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_VERR_Msk,\
10002a50:	9b01      	ldr	r3, [sp, #4]
10002a52:	3510      	adds	r5, #16
10002a54:	8819      	ldrh	r1, [r3, #0]
10002a56:	0708      	lsls	r0, r1, #28
10002a58:	0f80      	lsrs	r0, r0, #30
10002a5a:	d1ed      	bne.n	10002a38 <FLASH003_WriteMultipleBlocks+0x44>
      }
      /*Checking for the status of Flash for Idle and Sleep Mode*/
      else if((rd1 == FLASH003_RESET) && (rd2 == FLASH003_RESET) && \
             (rd3 == FLASH003_RESET))
      {
        for(lBlk_Cnt = 0U;lBlk_Cnt < (uint32_t)No_of_Blocks;lBlk_Cnt++)
10002a5c:	3601      	adds	r6, #1
10002a5e:	e7ef      	b.n	10002a40 <FLASH003_WriteMultipleBlocks+0x4c>
            DynamicHandle->FLASH003_global_status = FLASH003_IDLE;
        #endif
      }
    }
    return (uint32_t)status;
}
10002a60:	b005      	add	sp, #20
10002a62:	bdf0      	pop	{r4, r5, r6, r7, pc}
10002a64:	1000448c 	.word	0x1000448c

10002a68 <FLASH003_ErasePage>:
      status = FLASH003_IN_PROGRESS;
      lstatus = FLASH003_NVM_E_FAIL;
	  Handle = &FLASH003_Handle0;
	
      /*validate the Address Range*/
      if((Address < Handle->kStart_Address) || (Address > Handle->kEnd_Address))
10002a68:	4b0f      	ldr	r3, [pc, #60]	; (10002aa8 <FLASH003_ErasePage+0x40>)
/*
 *  The function uses the ROM api to Erase 
 *  the one page of data
 */
status_t FLASH003_ErasePage (uint32_t Address)
{
10002a6a:	b513      	push	{r0, r1, r4, lr}
      status = FLASH003_IN_PROGRESS;
      lstatus = FLASH003_NVM_E_FAIL;
	  Handle = &FLASH003_Handle0;
	
      /*validate the Address Range*/
      if((Address < Handle->kStart_Address) || (Address > Handle->kEnd_Address))
10002a6c:	685a      	ldr	r2, [r3, #4]
      {
      	 status = FLASH003_INVALID_ADDRESS;
10002a6e:	2401      	movs	r4, #1
      status = FLASH003_IN_PROGRESS;
      lstatus = FLASH003_NVM_E_FAIL;
	  Handle = &FLASH003_Handle0;
	
      /*validate the Address Range*/
      if((Address < Handle->kStart_Address) || (Address > Handle->kEnd_Address))
10002a70:	4290      	cmp	r0, r2
10002a72:	d317      	bcc.n	10002aa4 <FLASH003_ErasePage+0x3c>
10002a74:	6899      	ldr	r1, [r3, #8]
10002a76:	4288      	cmp	r0, r1
10002a78:	d814      	bhi.n	10002aa4 <FLASH003_ErasePage+0x3c>
  		 #endif
      }
      else
      {
		  /*Calling ROM API to Erase a Page*/
		  lstatus = FLASH003_NvmErasePage((uint32_t *)Address);
10002a7a:	2380      	movs	r3, #128	; 0x80
10002a7c:	40a3      	lsls	r3, r4
10002a7e:	681a      	ldr	r2, [r3, #0]
10002a80:	4790      	blx	r2
		  /*Mapping different status returned by ROM Api to Standard Return*/
		  if(lstatus == FLASH003_NVM_PASS)
10002a82:	2180      	movs	r1, #128	; 0x80
10002a84:	024b      	lsls	r3, r1, #9
10002a86:	4298      	cmp	r0, r3
10002a88:	d00b      	beq.n	10002aa2 <FLASH003_ErasePage+0x3a>
		  {
			status = FLASH003_COMPLETE;
		  }
		  else if((lstatus == FLASH003_NVM_E_FAIL) ||
10002a8a:	4a08      	ldr	r2, [pc, #32]	; (10002aac <FLASH003_ErasePage+0x44>)
10002a8c:	4290      	cmp	r0, r2
10002a8e:	d101      	bne.n	10002a94 <FLASH003_ErasePage+0x2c>
				 (lstatus == FLASH003_NVM_E_NVM_FAIL) || \
				 (lstatus == FLASH003_NVM_E_VERIFY))
		  {
			status = FLASH003_ERROR;
10002a90:	2402      	movs	r4, #2
10002a92:	e007      	b.n	10002aa4 <FLASH003_ErasePage+0x3c>
		  /*Mapping different status returned by ROM Api to Standard Return*/
		  if(lstatus == FLASH003_NVM_PASS)
		  {
			status = FLASH003_COMPLETE;
		  }
		  else if((lstatus == FLASH003_NVM_E_FAIL) ||
10002a94:	4906      	ldr	r1, [pc, #24]	; (10002ab0 <FLASH003_ErasePage+0x48>)
10002a96:	4288      	cmp	r0, r1
10002a98:	d0fa      	beq.n	10002a90 <FLASH003_ErasePage+0x28>
				 (lstatus == FLASH003_NVM_E_NVM_FAIL) || \
10002a9a:	4b06      	ldr	r3, [pc, #24]	; (10002ab4 <FLASH003_ErasePage+0x4c>)
10002a9c:	4298      	cmp	r0, r3
10002a9e:	d101      	bne.n	10002aa4 <FLASH003_ErasePage+0x3c>
10002aa0:	e7f6      	b.n	10002a90 <FLASH003_ErasePage+0x28>
		  /*Calling ROM API to Erase a Page*/
		  lstatus = FLASH003_NvmErasePage((uint32_t *)Address);
		  /*Mapping different status returned by ROM Api to Standard Return*/
		  if(lstatus == FLASH003_NVM_PASS)
		  {
			status = FLASH003_COMPLETE;
10002aa2:	2400      	movs	r4, #0
			#endif
		  }
      }
    }
    return (uint32_t)status;
}
10002aa4:	1c20      	adds	r0, r4, #0
10002aa6:	bd16      	pop	{r1, r2, r4, pc}
10002aa8:	1000448c 	.word	0x1000448c
10002aac:	80010001 	.word	0x80010001
10002ab0:	80010005 	.word	0x80010005
10002ab4:	80010006 	.word	0x80010006

10002ab8 <FLASH003_ReadBytes>:
 * This function used to read the No_of_bytes
 * from the specified address
 */
status_t FLASH003_ReadBytes(uint32_t Address, uint8_t buf[],\
                                                        uint32_t No_of_bytes)
{
10002ab8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    status = FLASH003_IN_PROGRESS;
    /*calculation of the last byte address*/
    final_add_location = (uint32_t)((uint32_t)Address + \
                                      (uint32_t)No_of_bytes) - 1U;

    rd1 = RD_REG(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_ACTION_Msk,\
10002aba:	4d1a      	ldr	r5, [pc, #104]	; (10002b24 <FLASH003_ReadBytes+0x6c>)
 * This function used to read the No_of_bytes
 * from the specified address
 */
status_t FLASH003_ReadBytes(uint32_t Address, uint8_t buf[],\
                                                        uint32_t No_of_bytes)
{
10002abc:	1c03      	adds	r3, r0, #0
    status = FLASH003_IN_PROGRESS;
    /*calculation of the last byte address*/
    final_add_location = (uint32_t)((uint32_t)Address + \
                                      (uint32_t)No_of_bytes) - 1U;

    rd1 = RD_REG(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_ACTION_Msk,\
10002abe:	68ec      	ldr	r4, [r5, #12]
10002ac0:	88a6      	ldrh	r6, [r4, #4]
    		                                            NVM_NVMPROG_ACTION_Pos);
    rd2 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_BUSY_Msk,\
10002ac2:	8827      	ldrh	r7, [r4, #0]
    status = FLASH003_IN_PROGRESS;
    /*calculation of the last byte address*/
    final_add_location = (uint32_t)((uint32_t)Address + \
                                      (uint32_t)No_of_bytes) - 1U;

    rd1 = RD_REG(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_ACTION_Msk,\
10002ac4:	46b4      	mov	ip, r6
    rd2 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_BUSY_Msk,\
    		                                            NVM_NVMSTATUS_BUSY_Pos);
    rd3 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_SLEEP_Msk,\
    		                                           NVM_NVMSTATUS_SLEEP_Pos);
    /*validate the Address for Range and Block Alignment*/
    if ((Address < Handle->kStart_Address) || (Address > Handle->kEnd_Address)\
10002ac6:	686e      	ldr	r6, [r5, #4]

    rd1 = RD_REG(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_ACTION_Msk,\
    		                                            NVM_NVMPROG_ACTION_Pos);
    rd2 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_BUSY_Msk,\
    		                                            NVM_NVMSTATUS_BUSY_Pos);
    rd3 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_SLEEP_Msk,\
10002ac8:	8820      	ldrh	r0, [r4, #0]
    		                                           NVM_NVMSTATUS_SLEEP_Pos);
    /*validate the Address for Range and Block Alignment*/
    if ((Address < Handle->kStart_Address) || (Address > Handle->kEnd_Address)\
10002aca:	9600      	str	r6, [sp, #0]
10002acc:	9e00      	ldr	r6, [sp, #0]

    rd1 = RD_REG(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_ACTION_Msk,\
    		                                            NVM_NVMPROG_ACTION_Pos);
    rd2 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_BUSY_Msk,\
    		                                            NVM_NVMSTATUS_BUSY_Pos);
    rd3 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_SLEEP_Msk,\
10002ace:	9001      	str	r0, [sp, #4]
    		                                           NVM_NVMSTATUS_SLEEP_Pos);
    /*validate the Address for Range and Block Alignment*/
    if ((Address < Handle->kStart_Address) || (Address > Handle->kEnd_Address)\
    		                     || (final_add_location > Handle->kEnd_Address))
    {
      status = FLASH003_INVALID_ADDRESS;
10002ad0:	2001      	movs	r0, #1
    rd2 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_BUSY_Msk,\
    		                                            NVM_NVMSTATUS_BUSY_Pos);
    rd3 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_SLEEP_Msk,\
    		                                           NVM_NVMSTATUS_SLEEP_Pos);
    /*validate the Address for Range and Block Alignment*/
    if ((Address < Handle->kStart_Address) || (Address > Handle->kEnd_Address)\
10002ad2:	42b3      	cmp	r3, r6
10002ad4:	d324      	bcc.n	10002b20 <FLASH003_ReadBytes+0x68>
10002ad6:	68ad      	ldr	r5, [r5, #8]
10002ad8:	9500      	str	r5, [sp, #0]
10002ada:	42ab      	cmp	r3, r5
10002adc:	d820      	bhi.n	10002b20 <FLASH003_ReadBytes+0x68>
     *of the flash or not.
     */
    uint32_t final_add_location;
    status = FLASH003_IN_PROGRESS;
    /*calculation of the last byte address*/
    final_add_location = (uint32_t)((uint32_t)Address + \
10002ade:	1e5e      	subs	r6, r3, #1
10002ae0:	18b5      	adds	r5, r6, r2
    		                                            NVM_NVMSTATUS_BUSY_Pos);
    rd3 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_SLEEP_Msk,\
    		                                           NVM_NVMSTATUS_SLEEP_Pos);
    /*validate the Address for Range and Block Alignment*/
    if ((Address < Handle->kStart_Address) || (Address > Handle->kEnd_Address)\
    		                     || (final_add_location > Handle->kEnd_Address))
10002ae2:	9e00      	ldr	r6, [sp, #0]
10002ae4:	42b5      	cmp	r5, r6
10002ae6:	d81b      	bhi.n	10002b20 <FLASH003_ReadBytes+0x68>
    final_add_location = (uint32_t)((uint32_t)Address + \
                                      (uint32_t)No_of_bytes) - 1U;

    rd1 = RD_REG(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_ACTION_Msk,\
    		                                            NVM_NVMPROG_ACTION_Pos);
    rd2 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_BUSY_Msk,\
10002ae8:	4007      	ands	r7, r0
    		                                            NVM_NVMSTATUS_BUSY_Pos);
    rd3 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_SLEEP_Msk,\
10002aea:	9e01      	ldr	r6, [sp, #4]
    status = FLASH003_IN_PROGRESS;
    /*calculation of the last byte address*/
    final_add_location = (uint32_t)((uint32_t)Address + \
                                      (uint32_t)No_of_bytes) - 1U;

    rd1 = RD_REG(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_ACTION_Msk,\
10002aec:	4660      	mov	r0, ip
10002aee:	b2c5      	uxtb	r5, r0
    		                                            NVM_NVMPROG_ACTION_Pos);
    rd2 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_BUSY_Msk,\
    		                                            NVM_NVMSTATUS_BUSY_Pos);
    rd3 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_SLEEP_Msk,\
10002af0:	2002      	movs	r0, #2
10002af2:	4006      	ands	r6, r0
    		                     || (final_add_location > Handle->kEnd_Address))
    {
      status = FLASH003_INVALID_ADDRESS;
    }
    /*Checking for the status of Flash for Idle and Sleep Mode*/
    else if((rd1 == FLASH003_RESET) && (rd2 == FLASH003_RESET) && \
10002af4:	432f      	orrs	r7, r5

    rd1 = RD_REG(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_ACTION_Msk,\
    		                                            NVM_NVMPROG_ACTION_Pos);
    rd2 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_BUSY_Msk,\
    		                                            NVM_NVMSTATUS_BUSY_Pos);
    rd3 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_SLEEP_Msk,\
10002af6:	0875      	lsrs	r5, r6, #1
    		                     || (final_add_location > Handle->kEnd_Address))
    {
      status = FLASH003_INVALID_ADDRESS;
    }
    /*Checking for the status of Flash for Idle and Sleep Mode*/
    else if((rd1 == FLASH003_RESET) && (rd2 == FLASH003_RESET) && \
10002af8:	432f      	orrs	r7, r5
10002afa:	d111      	bne.n	10002b20 <FLASH003_ReadBytes+0x68>
}
/*
 * This function used to read the No_of_bytes
 * from the specified address
 */
status_t FLASH003_ReadBytes(uint32_t Address, uint8_t buf[],\
10002afc:	18d7      	adds	r7, r2, r3
10002afe:	1c1d      	adds	r5, r3, #0
10002b00:	2003      	movs	r0, #3
    /*Checking for the status of Flash for Idle and Sleep Mode*/
    else if((rd1 == FLASH003_RESET) && (rd2 == FLASH003_RESET) && \
           (rd3 == FLASH003_RESET))
    {
      /* reads no of bytes specified*/  
      for(lByte_Cnt = 0U;lByte_Cnt < (uint32_t)No_of_bytes;lByte_Cnt++)
10002b02:	42bd      	cmp	r5, r7
10002b04:	d005      	beq.n	10002b12 <FLASH003_ReadBytes+0x5a>
      {
        /* reads one byte*/
        *(buf + lByte_Cnt) = *((uint8_t*)Address + lByte_Cnt);
10002b06:	782e      	ldrb	r6, [r5, #0]
}
/*
 * This function used to read the No_of_bytes
 * from the specified address
 */
status_t FLASH003_ReadBytes(uint32_t Address, uint8_t buf[],\
10002b08:	1ac8      	subs	r0, r1, r3
    {
      /* reads no of bytes specified*/  
      for(lByte_Cnt = 0U;lByte_Cnt < (uint32_t)No_of_bytes;lByte_Cnt++)
      {
        /* reads one byte*/
        *(buf + lByte_Cnt) = *((uint8_t*)Address + lByte_Cnt);
10002b0a:	5546      	strb	r6, [r0, r5]
10002b0c:	3501      	adds	r5, #1
        status = FLASH003_COMPLETE;
10002b0e:	2000      	movs	r0, #0
10002b10:	e7f7      	b.n	10002b02 <FLASH003_ReadBytes+0x4a>
      }
      rd1 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_ECC1READ_Msk,\
10002b12:	8823      	ldrh	r3, [r4, #0]
    		                                        NVM_NVMSTATUS_ECC1READ_Pos);
      rd2 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_ECC2READ_Msk,\
10002b14:	8822      	ldrh	r2, [r4, #0]
      {
        /* reads one byte*/
        *(buf + lByte_Cnt) = *((uint8_t*)Address + lByte_Cnt);
        status = FLASH003_COMPLETE;
      }
      rd1 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_ECC1READ_Msk,\
10002b16:	06dc      	lsls	r4, r3, #27
    		                                        NVM_NVMSTATUS_ECC1READ_Pos);
      rd2 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_ECC2READ_Msk,\
10002b18:	0691      	lsls	r1, r2, #26
      {
        /* reads one byte*/
        *(buf + lByte_Cnt) = *((uint8_t*)Address + lByte_Cnt);
        status = FLASH003_COMPLETE;
      }
      rd1 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_ECC1READ_Msk,\
10002b1a:	430c      	orrs	r4, r1
    		                                        NVM_NVMSTATUS_ECC1READ_Pos);
      rd2 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_ECC2READ_Msk,\
    		                                        NVM_NVMSTATUS_ECC2READ_Pos);
      /*Checking for ECC error flags*/
      if((rd1 != FLASH003_RESET) || (rd2 != FLASH003_RESET))
10002b1c:	d500      	bpl.n	10002b20 <FLASH003_ReadBytes+0x68>
      {
        status = FLASH003_ERROR;
10002b1e:	2002      	movs	r0, #2
    else
    {
      status = FLASH003_ERROR;
    }
  return (uint32_t)status;
}
10002b20:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
10002b22:	46c0      	nop			; (mov r8, r8)
10002b24:	1000448c 	.word	0x1000448c

10002b28 <USIC0_0_IRQHandler>:
    }
}
#endif

void DMX512RD01_UART_isr(void) /* Generated after every slot */
{
10002b28:	b538      	push	{r3, r4, r5, lr}
	if((DMX512RD01_Handle0.UsicRegPtr->TRBSR & USIC_CH_TRBSR_SRBI_Msk) == USIC_CH_TRBSR_SRBI_Msk)
10002b2a:	4b1d      	ldr	r3, [pc, #116]	; (10002ba0 <USIC0_0_IRQHandler+0x78>)
10002b2c:	2101      	movs	r1, #1
10002b2e:	6818      	ldr	r0, [r3, #0]
10002b30:	4a1c      	ldr	r2, [pc, #112]	; (10002ba4 <USIC0_0_IRQHandler+0x7c>)
10002b32:	1c03      	adds	r3, r0, #0
10002b34:	33fc      	adds	r3, #252	; 0xfc
10002b36:	699c      	ldr	r4, [r3, #24]
10002b38:	420c      	tst	r4, r1
10002b3a:	d005      	beq.n	10002b48 <USIC0_0_IRQHandler+0x20>
	{ /* Recieve a byte */
		ReadByte = DMX512RD01_Handle0.UsicRegPtr->OUTR;
		DMX512RD01_Handle0.UsicRegPtr->TRBSCR = USIC_CH_TRBSCR_CSRBI_Msk;
	    buf_index++;
10002b3c:	6854      	ldr	r4, [r2, #4]

void DMX512RD01_UART_isr(void) /* Generated after every slot */
{
	if((DMX512RD01_Handle0.UsicRegPtr->TRBSR & USIC_CH_TRBSR_SRBI_Msk) == USIC_CH_TRBSR_SRBI_Msk)
	{ /* Recieve a byte */
		ReadByte = DMX512RD01_Handle0.UsicRegPtr->OUTR;
10002b3e:	6a1d      	ldr	r5, [r3, #32]
		DMX512RD01_Handle0.UsicRegPtr->TRBSCR = USIC_CH_TRBSCR_CSRBI_Msk;
	    buf_index++;
10002b40:	3401      	adds	r4, #1

void DMX512RD01_UART_isr(void) /* Generated after every slot */
{
	if((DMX512RD01_Handle0.UsicRegPtr->TRBSR & USIC_CH_TRBSR_SRBI_Msk) == USIC_CH_TRBSR_SRBI_Msk)
	{ /* Recieve a byte */
		ReadByte = DMX512RD01_Handle0.UsicRegPtr->OUTR;
10002b42:	6015      	str	r5, [r2, #0]
		DMX512RD01_Handle0.UsicRegPtr->TRBSCR = USIC_CH_TRBSCR_CSRBI_Msk;
	    buf_index++;
10002b44:	6054      	str	r4, [r2, #4]
void DMX512RD01_UART_isr(void) /* Generated after every slot */
{
	if((DMX512RD01_Handle0.UsicRegPtr->TRBSR & USIC_CH_TRBSR_SRBI_Msk) == USIC_CH_TRBSR_SRBI_Msk)
	{ /* Recieve a byte */
		ReadByte = DMX512RD01_Handle0.UsicRegPtr->OUTR;
		DMX512RD01_Handle0.UsicRegPtr->TRBSCR = USIC_CH_TRBSCR_CSRBI_Msk;
10002b46:	61d9      	str	r1, [r3, #28]
	    buf_index++;
	}
#ifndef DMX512RD01_ACC_BREAK_DETECT
	if ((DMX512RD01_Handle0.UsicRegPtr->PSR_ASCMode & USIC_CH_PSR_ASCMode_SBD_Msk) == USIC_CH_PSR_ASCMode_SBD_Msk)
10002b48:	6c85      	ldr	r5, [r0, #72]	; 0x48
10002b4a:	4917      	ldr	r1, [pc, #92]	; (10002ba8 <USIC0_0_IRQHandler+0x80>)
10002b4c:	076d      	lsls	r5, r5, #29
10002b4e:	d510      	bpl.n	10002b72 <USIC0_0_IRQHandler+0x4a>
    {/* check if SBD occured */
		DMX512RD01_Handle0.UsicRegPtr->PSCR =  DMX512RD01_USIC_CLR_STATUS;
10002b50:	4c16      	ldr	r4, [pc, #88]	; (10002bac <USIC0_0_IRQHandler+0x84>)
        buf_index=0;
        DMX512RD01_buffer_ptr = DMX512RD01_buffer;
10002b52:	4d17      	ldr	r5, [pc, #92]	; (10002bb0 <USIC0_0_IRQHandler+0x88>)
	    buf_index++;
	}
#ifndef DMX512RD01_ACC_BREAK_DETECT
	if ((DMX512RD01_Handle0.UsicRegPtr->PSR_ASCMode & USIC_CH_PSR_ASCMode_SBD_Msk) == USIC_CH_PSR_ASCMode_SBD_Msk)
    {/* check if SBD occured */
		DMX512RD01_Handle0.UsicRegPtr->PSCR =  DMX512RD01_USIC_CLR_STATUS;
10002b54:	64c4      	str	r4, [r0, #76]	; 0x4c
        buf_index=0;
10002b56:	2000      	movs	r0, #0
10002b58:	6050      	str	r0, [r2, #4]
        DMX512RD01_buffer_ptr = DMX512RD01_buffer;
10002b5a:	600d      	str	r5, [r1, #0]
        while((DMX512RD01_Handle0.UsicRegPtr->TRBSR & USIC_CH_TRBSR_REMPTY_Msk) != USIC_CH_TRBSR_REMPTY_Msk)
10002b5c:	699c      	ldr	r4, [r3, #24]
10002b5e:	0724      	lsls	r4, r4, #28
10002b60:	d402      	bmi.n	10002b68 <USIC0_0_IRQHandler+0x40>
        {
           ReadByte = DMX512RD01_Handle0.UsicRegPtr->OUTR;
10002b62:	6a18      	ldr	r0, [r3, #32]
10002b64:	6010      	str	r0, [r2, #0]
10002b66:	e7f9      	b.n	10002b5c <USIC0_0_IRQHandler+0x34>
        }
        /* Enable USIC Standard Receive Buffer interrupt */
        DMX512RD01_Handle0.UsicRegPtr->RBCTR |= ((uint32_t)USIC_CH_RBCTR_SRBIEN_Msk);
10002b68:	691d      	ldr	r5, [r3, #16]
10002b6a:	2080      	movs	r0, #128	; 0x80
10002b6c:	05c4      	lsls	r4, r0, #23
10002b6e:	432c      	orrs	r4, r5
10002b70:	611c      	str	r4, [r3, #16]
    }
#endif
	if ((buf_index-1) >= start_slot_num)
10002b72:	6854      	ldr	r4, [r2, #4]
10002b74:	6848      	ldr	r0, [r1, #4]
10002b76:	1e65      	subs	r5, r4, #1
10002b78:	4285      	cmp	r5, r0
10002b7a:	d30f      	bcc.n	10002b9c <USIC0_0_IRQHandler+0x74>
	{
        if ((buf_index-1) < (start_slot_num + DMX512RD01_NUM_SLOTS))
10002b7c:	3006      	adds	r0, #6
10002b7e:	4285      	cmp	r5, r0
10002b80:	d20c      	bcs.n	10002b9c <USIC0_0_IRQHandler+0x74>
        { /* If its valid byte, store it. */
            *DMX512RD01_buffer_ptr = (ReadByte & 0xFFU);	/* Read only 8 data */
10002b82:	6812      	ldr	r2, [r2, #0]
10002b84:	b2d5      	uxtb	r5, r2
10002b86:	680a      	ldr	r2, [r1, #0]
10002b88:	c220      	stmia	r2!, {r5}
            DMX512RD01_buffer_ptr++;
10002b8a:	600a      	str	r2, [r1, #0]
            if(buf_index == (start_slot_num + DMX512RD01_NUM_SLOTS))
10002b8c:	4284      	cmp	r4, r0
10002b8e:	d105      	bne.n	10002b9c <USIC0_0_IRQHandler+0x74>
            {
            	/* Disable USIC Standard Receive Buffer interrupt */
            	DMX512RD01_Handle0.UsicRegPtr->RBCTR &= (~(uint32_t)USIC_CH_RBCTR_SRBIEN_Msk);
10002b90:	6919      	ldr	r1, [r3, #16]
10002b92:	4c08      	ldr	r4, [pc, #32]	; (10002bb4 <USIC0_0_IRQHandler+0x8c>)
10002b94:	400c      	ands	r4, r1
10002b96:	611c      	str	r4, [r3, #16]
#ifdef DMX512RD01_CALLBACK_DEFINED
       DMX512RD01_CallBack();
10002b98:	f7fe fbbe 	bl	10001318 <DMX512RD01_CallBack>
    }
    else
    {
    	/* Nothing to do */
    }
}
10002b9c:	bd38      	pop	{r3, r4, r5, pc}
10002b9e:	46c0      	nop			; (mov r8, r8)
10002ba0:	1000449c 	.word	0x1000449c
10002ba4:	20000580 	.word	0x20000580
10002ba8:	2000067c 	.word	0x2000067c
10002bac:	0001ffff 	.word	0x0001ffff
10002bb0:	20000614 	.word	0x20000614
10002bb4:	bfffffff 	.word	0xbfffffff

10002bb8 <DMX512RD01_ConfigStartSlotNo>:
*******************************************************************************/
DMX512RD01_STAT DMX512RD01_ConfigStartSlotNo(uint32_t slot_num)
{
	DMX512RD01_STAT status = DMX512RD01_ERROR;

	if ((slot_num >= 1) && (slot_num <= 512))
10002bb8:	4b07      	ldr	r3, [pc, #28]	; (10002bd8 <DMX512RD01_ConfigStartSlotNo+0x20>)
10002bba:	1e42      	subs	r2, r0, #1
10002bbc:	429a      	cmp	r2, r3
10002bbe:	d808      	bhi.n	10002bd2 <DMX512RD01_ConfigStartSlotNo+0x1a>
	{
		if ((slot_num + DMX512RD01_NUM_SLOTS) <= 512)
10002bc0:	2280      	movs	r2, #128	; 0x80
10002bc2:	1d81      	adds	r1, r0, #6
10002bc4:	0093      	lsls	r3, r2, #2
10002bc6:	4299      	cmp	r1, r3
10002bc8:	d803      	bhi.n	10002bd2 <DMX512RD01_ConfigStartSlotNo+0x1a>
		{
			status = DMX512RD01_SUCCESS;
			start_slot_num = slot_num;
10002bca:	4904      	ldr	r1, [pc, #16]	; (10002bdc <DMX512RD01_ConfigStartSlotNo+0x24>)
10002bcc:	6048      	str	r0, [r1, #4]

	if ((slot_num >= 1) && (slot_num <= 512))
	{
		if ((slot_num + DMX512RD01_NUM_SLOTS) <= 512)
		{
			status = DMX512RD01_SUCCESS;
10002bce:	2000      	movs	r0, #0
10002bd0:	e001      	b.n	10002bd6 <DMX512RD01_ConfigStartSlotNo+0x1e>
/******************************************************************************
**    Public Functions                                                       **
*******************************************************************************/
DMX512RD01_STAT DMX512RD01_ConfigStartSlotNo(uint32_t slot_num)
{
	DMX512RD01_STAT status = DMX512RD01_ERROR;
10002bd2:	2001      	movs	r0, #1
10002bd4:	4240      	negs	r0, r0
	else
	{ /* MISRA Check */
	}

	return status;
}
10002bd6:	4770      	bx	lr
10002bd8:	000001ff 	.word	0x000001ff
10002bdc:	2000067c 	.word	0x2000067c

10002be0 <DMX512RD01_Init>:
	  CCU4_GLOBAL_TypeDef* CapBaseReg = DMX512RD01_Handle0.CaptureBasePtr;
	  CCU4_CC4_TypeDef* CapSliceReg = DMX512RD01_Handle0.CaptureRegPtr;
#endif
	 /* USIC Configuration */
	  /* Disable the USIC0 clock gating */
	  SCU_GENERAL->PASSWD = 0x000000C0UL;
10002be0:	4920      	ldr	r1, [pc, #128]	; (10002c64 <DMX512RD01_Init+0x84>)
10002be2:	22c0      	movs	r2, #192	; 0xc0

	return status;
}

void DMX512RD01_Init(void)
{
10002be4:	b510      	push	{r4, lr}
	  CCU4_GLOBAL_TypeDef* CapBaseReg = DMX512RD01_Handle0.CaptureBasePtr;
	  CCU4_CC4_TypeDef* CapSliceReg = DMX512RD01_Handle0.CaptureRegPtr;
#endif
	 /* USIC Configuration */
	  /* Disable the USIC0 clock gating */
	  SCU_GENERAL->PASSWD = 0x000000C0UL;
10002be6:	624a      	str	r2, [r1, #36]	; 0x24
	  SET_BIT(SCU_CLK->CGATCLR0, SCU_CLK_CGATCLR0_USIC0_Pos);
10002be8:	4a1f      	ldr	r2, [pc, #124]	; (10002c68 <DMX512RD01_Init+0x88>)
	return status;
}

void DMX512RD01_Init(void)
{
	  USIC_CH_TypeDef* UartRegs = DMX512RD01_Handle0.UsicRegPtr;
10002bea:	4b20      	ldr	r3, [pc, #128]	; (10002c6c <DMX512RD01_Init+0x8c>)
	  CCU4_CC4_TypeDef* CapSliceReg = DMX512RD01_Handle0.CaptureRegPtr;
#endif
	 /* USIC Configuration */
	  /* Disable the USIC0 clock gating */
	  SCU_GENERAL->PASSWD = 0x000000C0UL;
	  SET_BIT(SCU_CLK->CGATCLR0, SCU_CLK_CGATCLR0_USIC0_Pos);
10002bec:	6910      	ldr	r0, [r2, #16]
10002bee:	2408      	movs	r4, #8
10002bf0:	4320      	orrs	r0, r4
	return status;
}

void DMX512RD01_Init(void)
{
	  USIC_CH_TypeDef* UartRegs = DMX512RD01_Handle0.UsicRegPtr;
10002bf2:	681b      	ldr	r3, [r3, #0]
	  CCU4_CC4_TypeDef* CapSliceReg = DMX512RD01_Handle0.CaptureRegPtr;
#endif
	 /* USIC Configuration */
	  /* Disable the USIC0 clock gating */
	  SCU_GENERAL->PASSWD = 0x000000C0UL;
	  SET_BIT(SCU_CLK->CGATCLR0, SCU_CLK_CGATCLR0_USIC0_Pos);
10002bf4:	6110      	str	r0, [r2, #16]
	  while ((SCU_CLK->CLKCR)&(SCU_CLK_CLKCR_VDDC2LOW_Msk))
10002bf6:	6810      	ldr	r0, [r2, #0]
10002bf8:	0044      	lsls	r4, r0, #1
10002bfa:	d4fc      	bmi.n	10002bf6 <DMX512RD01_Init+0x16>
	  {
	    ;
	  }
	  SCU_GENERAL->PASSWD = 0x000000C3UL;
10002bfc:	22c3      	movs	r2, #195	; 0xc3
10002bfe:	624a      	str	r2, [r1, #36]	; 0x24
	  /* Disable UART mode before configuring all USIC registers to avoid unintended edges */
	  UartRegs->CCR &= ~( ((uint32_t)(DMX512RD01_USIC_UART  & USIC_CH_CCR_MODE_Msk)));
10002c00:	6c19      	ldr	r1, [r3, #64]	; 0x40
10002c02:	2202      	movs	r2, #2
10002c04:	4391      	bics	r1, r2
10002c06:	6419      	str	r1, [r3, #64]	; 0x40
	  /* Enable the USIC Channel */
	  UartRegs->KSCFG |= ((((uint32_t)USIC_CH_KSCFG_MODEN_Msk)) | \
10002c08:	68dc      	ldr	r4, [r3, #12]
10002c0a:	2003      	movs	r0, #3
10002c0c:	4304      	orrs	r4, r0
10002c0e:	60dc      	str	r4, [r3, #12]
	     (((uint32_t)USIC_CH_KSCFG_BPMODEN_Msk)));
	  /* Configuration of USIC Channel Fractional Divider */
	  UartRegs->FDR |= (((uint32_t)DMX512RD01_USIC_FRACDIV_MODE << USIC_CH_FDR_DM_Pos) \
10002c10:	691c      	ldr	r4, [r3, #16]
10002c12:	2180      	movs	r1, #128	; 0x80
10002c14:	0208      	lsls	r0, r1, #8
10002c16:	4320      	orrs	r0, r4
10002c18:	6118      	str	r0, [r3, #16]
	                                                 & USIC_CH_FDR_DM_Msk);
	  /* Step value */
	  UartRegs->FDR |= ((DMX512RD01_USIC_BGR_STEP) & USIC_CH_FDR_STEP_Msk);
10002c1a:	691c      	ldr	r4, [r3, #16]
10002c1c:	2150      	movs	r1, #80	; 0x50
10002c1e:	430c      	orrs	r4, r1
10002c20:	611c      	str	r4, [r3, #16]

	  /* The PreDivider for CTQ, PCTQ = 0  */
	  /* The Denominator for CTQ, DCTQ = 16 */
	  UartRegs->BRG |= \
10002c22:	6958      	ldr	r0, [r3, #20]
10002c24:	2490      	movs	r4, #144	; 0x90
10002c26:	01a1      	lsls	r1, r4, #6
10002c28:	4301      	orrs	r1, r0
10002c2a:	6159      	str	r1, [r3, #20]

	  /* Configuration of USIC Shift Control */
	  /* Transmit/Receive LSB first is selected  */
	  /* Transmission Mode (TRM) = 1  */
	  /* Passive Data Level (PDL) = 1 */
	  UartRegs->SCTR |= ((((uint32_t)DMX512RD01_USIC_PASSIVELEV << USIC_CH_SCTR_PDL_Pos) & \
10002c2c:	6b58      	ldr	r0, [r3, #52]	; 0x34
10002c2e:	2481      	movs	r4, #129	; 0x81
10002c30:	0061      	lsls	r1, r4, #1
10002c32:	4301      	orrs	r1, r0
10002c34:	6359      	str	r1, [r3, #52]	; 0x34
	    USIC_CH_SCTR_PDL_Msk ) | \
	    (((uint32_t)DMX512RD01_USIC_DATATRANS_ACTIVE << USIC_CH_SCTR_TRM_Pos ) &   USIC_CH_SCTR_TRM_Msk ));
	  /* Set Word Length (WLE) & Frame Length (FLE) */
	  UartRegs->SCTR |= ((((uint32_t)DMX512RD01_USIC_FLE_WLE  << USIC_CH_SCTR_FLE_Pos) & \
10002c36:	6b5c      	ldr	r4, [r3, #52]	; 0x34
10002c38:	480d      	ldr	r0, [pc, #52]	; (10002c70 <DMX512RD01_Init+0x90>)
10002c3a:	4304      	orrs	r4, r0
10002c3c:	635c      	str	r4, [r3, #52]	; 0x34
	  /* Configuration of Protocol Control Register */
	  /* Sample Mode (SMD) = 1 */
	  /* 1 Stop bit is selected */
	  /* Sample Point (SP) as configured */
	  /* Pulse Length (PL) = 0 */
	  UartRegs->PCR_ASCMode |= ((((uint32_t)DMX512RD01_USIC_3SAMPLES & USIC_CH_PCR_ASCMode_SMD_Msk)) |\
10002c3e:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
10002c40:	4c0c      	ldr	r4, [pc, #48]	; (10002c74 <DMX512RD01_Init+0x94>)
	    (((uint32_t)(DMX512RD01_USIC_BGR_SP) << USIC_CH_PCR_ASCMode_SP_Pos) & \
	    USIC_CH_PCR_ASCMode_SP_Msk));

	  /* Configuration of Transmitter Buffer Control Register */
	  /* Configuration of Receiver Buffer Control Register */
	  UartRegs->RBCTR |= ((((uint32_t)DMX512RD01_USIC_RXLIMIT  << \
10002c42:	2080      	movs	r0, #128	; 0x80
	  /* Configuration of Protocol Control Register */
	  /* Sample Mode (SMD) = 1 */
	  /* 1 Stop bit is selected */
	  /* Sample Point (SP) as configured */
	  /* Pulse Length (PL) = 0 */
	  UartRegs->PCR_ASCMode |= ((((uint32_t)DMX512RD01_USIC_3SAMPLES & USIC_CH_PCR_ASCMode_SMD_Msk)) |\
10002c44:	4321      	orrs	r1, r4
10002c46:	63d9      	str	r1, [r3, #60]	; 0x3c
	    (((uint32_t)(DMX512RD01_USIC_BGR_SP) << USIC_CH_PCR_ASCMode_SP_Pos) & \
	    USIC_CH_PCR_ASCMode_SP_Msk));

	  /* Configuration of Transmitter Buffer Control Register */
	  /* Configuration of Receiver Buffer Control Register */
	  UartRegs->RBCTR |= ((((uint32_t)DMX512RD01_USIC_RXLIMIT  << \
10002c48:	1c19      	adds	r1, r3, #0
10002c4a:	31fc      	adds	r1, #252	; 0xfc
10002c4c:	690c      	ldr	r4, [r1, #16]
10002c4e:	0540      	lsls	r0, r0, #21
10002c50:	4320      	orrs	r0, r4
10002c52:	6108      	str	r0, [r1, #16]
		                    (((uint32_t)DMX512RD01_USIC_LOF << USIC_CH_RBCTR_LOF_Pos) & \
	                       USIC_CH_RBCTR_LOF_Msk));

	  /* Configuration of Channel Control Register */
	  /* parity generation is disabled*/
	  UartRegs->CCR |= (((uint32_t)(DMX512RD01_USIC_UART  & USIC_CH_CCR_MODE_Msk)) | \
10002c54:	6c19      	ldr	r1, [r3, #64]	; 0x40
	                    (((uint32_t)DMX512RD01_USIC_NOPARITY  << USIC_CH_CCR_PM_Pos) & \
	                     USIC_CH_CCR_PM_Msk));

     /* Configuration of Sync. BREAK Detection */
	 /* Enable interrupt at SBD */
	 UartRegs->PCR_ASCMode |=  USIC_CH_PCR_ASCMode_SBIEN_Msk;
10002c56:	2408      	movs	r4, #8
		                    (((uint32_t)DMX512RD01_USIC_LOF << USIC_CH_RBCTR_LOF_Pos) & \
	                       USIC_CH_RBCTR_LOF_Msk));

	  /* Configuration of Channel Control Register */
	  /* parity generation is disabled*/
	  UartRegs->CCR |= (((uint32_t)(DMX512RD01_USIC_UART  & USIC_CH_CCR_MODE_Msk)) | \
10002c58:	430a      	orrs	r2, r1
10002c5a:	641a      	str	r2, [r3, #64]	; 0x40
	                    (((uint32_t)DMX512RD01_USIC_NOPARITY  << USIC_CH_CCR_PM_Pos) & \
	                     USIC_CH_CCR_PM_Msk));

     /* Configuration of Sync. BREAK Detection */
	 /* Enable interrupt at SBD */
	 UartRegs->PCR_ASCMode |=  USIC_CH_PCR_ASCMode_SBIEN_Msk;
10002c5c:	6bda      	ldr	r2, [r3, #60]	; 0x3c
10002c5e:	4322      	orrs	r2, r4
10002c60:	63da      	str	r2, [r3, #60]	; 0x3c

    /*Slice Timer Run Set Set Timer Run Bit*/
    WR_REG(CapSliceReg->TCSET, CCU4_CC4_TCSET_TRBS_Msk,CCU4_CC4_TCSET_TRBS_Pos, 1);
#endif

}
10002c62:	bd10      	pop	{r4, pc}
10002c64:	40010000 	.word	0x40010000
10002c68:	40010300 	.word	0x40010300
10002c6c:	1000449c 	.word	0x1000449c
10002c70:	07070000 	.word	0x07070000
10002c74:	00000603 	.word	0x00000603

10002c78 <DAVE_Init>:
// @Parameters    None
//
//****************************************************************************

void DAVE_Init(void)
{
10002c78:	b508      	push	{r3, lr}

//****************************************************************************
// @Initialization of APPs Init Functions
//****************************************************************************
	//  MUX configurations
	DAVE_MUX_PreInit(); 
10002c7a:	f000 f941 	bl	10002f00 <DAVE_MUX_PreInit>
	//  Initialization of app 'CLK002'		     
	CLK002_Init();
10002c7e:	f000 f98d 	bl	10002f9c <CLK002_Init>
	 
	//  Initialization of app 'BCCUGLOBAL'		     
	BCCUGLOBAL_Init();
10002c82:	f000 fa31 	bl	100030e8 <BCCUGLOBAL_Init>
	 
	//  Initialization of app 'BCCUDIM01'		     
	BCCUDIM01_Init();
10002c86:	f000 fa8d 	bl	100031a4 <BCCUDIM01_Init>
	 
	//  Initialization of app 'BCCUCH01'		     
	BCCUCH01_Init();
10002c8a:	f000 fabb 	bl	10003204 <BCCUCH01_Init>
	 
	//  Initialization of app 'COLORLAMP01'		     
	COLORLAMP01_Init();
10002c8e:	f000 f93f 	bl	10002f10 <COLORLAMP01_Init>
	 
	//  Initialization of app 'CCU4GLOBAL'		     
	CCU4GLOBAL_Init();
10002c92:	f000 f9ef 	bl	10003074 <CCU4GLOBAL_Init>
	 
	//  Initialization of app 'PWMSP003'		     
	PWMSP003_Init();
10002c96:	f7ff fb7f 	bl	10002398 <PWMSP003_Init>
	 
	//  Initialization of app 'IO002'		     
	IO002_Init();
10002c9a:	f7ff fc09 	bl	100024b0 <IO002_Init>
	 
	//  Initialization of app 'IO001'		     
	IO001_Init();
10002c9e:	f7ff fca1 	bl	100025e4 <IO001_Init>
	 
	//  Initialization of app 'ANACMPGLOB01'		     
	ANACMPGLOB01_Init();
10002ca2:	f000 fb49 	bl	10003338 <ANACMPGLOB01_Init>
	 
	//  Initialization of app 'ANACMP01'		     
	ANACMP01_Init();
10002ca6:	f000 fbc5 	bl	10003434 <ANACMP01_Init>
	 
	//  Initialization of app 'NVIC002'		     
	NVIC002_Init();
10002caa:	f7ff fbab 	bl	10002404 <NVIC002_Init>
	 
	//  Initialization of app 'DMX512RD01'		     
	DMX512RD01_Init();
10002cae:	f7ff ff97 	bl	10002be0 <DMX512RD01_Init>
	 
	//  Initialization of app 'IO004'		     
	IO004_Init();
10002cb2:	f7ff fbed 	bl	10002490 <IO004_Init>
	 
	//  Initialization of app 'I2C003'		     
	I2C003_Init();
10002cb6:	f7ff fde5 	bl	10002884 <I2C003_Init>
	 
	//  Initialization of app 'FLASH003'		     
	FLASH003_Init();
10002cba:	f7ff fe53 	bl	10002964 <FLASH003_Init>
	
      
	//  MUX configurations
	DAVE_MUX_Init();	
10002cbe:	f000 f801 	bl	10002cc4 <DAVE_MUX_Init>
} //  End of function DAVE_Init
10002cc2:	bd08      	pop	{r3, pc}

10002cc4 <DAVE_MUX_Init>:
** Description      : This is the Mux configuration                           **
**                                                                            **
*******************************************************************************/
           
void DAVE_MUX_Init(void)
{  
10002cc4:	b5f0      	push	{r4, r5, r6, r7, lr}
           
   /* Disable mode before configuring all USIC registers to avoid unintended edges */   
      /* Variable to store the CCR_MODE values for various USIC channels */ 
      uint32_t UsicCcrMode[6] = {0};
           
    UsicCcrMode[0] |= (uint32_t) RD_REG(USIC0_CH0->CCR, USIC_CH_CCR_MODE_Msk, USIC_CH_CCR_MODE_Pos);
10002cc6:	2190      	movs	r1, #144	; 0x90
10002cc8:	05c9      	lsls	r1, r1, #23
10002cca:	6c08      	ldr	r0, [r1, #64]	; 0x40
    WR_REG(USIC0_CH0->CCR, USIC_CH_CCR_MODE_Msk, USIC_CH_CCR_MODE_Pos,0);  
10002ccc:	6c0b      	ldr	r3, [r1, #64]	; 0x40
10002cce:	220f      	movs	r2, #15
** Description      : This is the Mux configuration                           **
**                                                                            **
*******************************************************************************/
           
void DAVE_MUX_Init(void)
{  
10002cd0:	b085      	sub	sp, #20
   /* Disable mode before configuring all USIC registers to avoid unintended edges */   
      /* Variable to store the CCR_MODE values for various USIC channels */ 
      uint32_t UsicCcrMode[6] = {0};
           
    UsicCcrMode[0] |= (uint32_t) RD_REG(USIC0_CH0->CCR, USIC_CH_CCR_MODE_Msk, USIC_CH_CCR_MODE_Pos);
    WR_REG(USIC0_CH0->CCR, USIC_CH_CCR_MODE_Msk, USIC_CH_CCR_MODE_Pos,0);  
10002cd2:	4393      	bics	r3, r2
           
   /* Disable mode before configuring all USIC registers to avoid unintended edges */   
      /* Variable to store the CCR_MODE values for various USIC channels */ 
      uint32_t UsicCcrMode[6] = {0};
           
    UsicCcrMode[0] |= (uint32_t) RD_REG(USIC0_CH0->CCR, USIC_CH_CCR_MODE_Msk, USIC_CH_CCR_MODE_Pos);
10002cd4:	9002      	str	r0, [sp, #8]
    WR_REG(USIC0_CH0->CCR, USIC_CH_CCR_MODE_Msk, USIC_CH_CCR_MODE_Pos,0);  
10002cd6:	640b      	str	r3, [r1, #64]	; 0x40
                        
    UsicCcrMode[1] |= (uint32_t) RD_REG(USIC0_CH1->CCR, USIC_CH_CCR_MODE_Msk, USIC_CH_CCR_MODE_Pos); 
10002cd8:	4b72      	ldr	r3, [pc, #456]	; (10002ea4 <DAVE_MUX_Init+0x1e0>)
    WR_REG(USIC0_CH1->CCR, USIC_CH_CCR_MODE_Msk, USIC_CH_CCR_MODE_Pos,0);   
                 
      
    						
   /*USIC 0 Channel 0 Mux Related SFR/Bitfields Configurations*/ 						         
 WR_REG(USIC0_CH0->DX0CR, USIC_CH_DX0CR_DSEL_Msk, USIC_CH_DX0CR_DSEL_Pos,4); 
10002cda:	2604      	movs	r6, #4
      uint32_t UsicCcrMode[6] = {0};
           
    UsicCcrMode[0] |= (uint32_t) RD_REG(USIC0_CH0->CCR, USIC_CH_CCR_MODE_Msk, USIC_CH_CCR_MODE_Pos);
    WR_REG(USIC0_CH0->CCR, USIC_CH_CCR_MODE_Msk, USIC_CH_CCR_MODE_Pos,0);  
                        
    UsicCcrMode[1] |= (uint32_t) RD_REG(USIC0_CH1->CCR, USIC_CH_CCR_MODE_Msk, USIC_CH_CCR_MODE_Pos); 
10002cdc:	6c1c      	ldr	r4, [r3, #64]	; 0x40
    WR_REG(USIC0_CH1->CCR, USIC_CH_CCR_MODE_Msk, USIC_CH_CCR_MODE_Pos,0);   
10002cde:	6c1d      	ldr	r5, [r3, #64]	; 0x40
      uint32_t UsicCcrMode[6] = {0};
           
    UsicCcrMode[0] |= (uint32_t) RD_REG(USIC0_CH0->CCR, USIC_CH_CCR_MODE_Msk, USIC_CH_CCR_MODE_Pos);
    WR_REG(USIC0_CH0->CCR, USIC_CH_CCR_MODE_Msk, USIC_CH_CCR_MODE_Pos,0);  
                        
    UsicCcrMode[1] |= (uint32_t) RD_REG(USIC0_CH1->CCR, USIC_CH_CCR_MODE_Msk, USIC_CH_CCR_MODE_Pos); 
10002ce0:	9403      	str	r4, [sp, #12]
    WR_REG(USIC0_CH1->CCR, USIC_CH_CCR_MODE_Msk, USIC_CH_CCR_MODE_Pos,0);   
10002ce2:	4395      	bics	r5, r2
10002ce4:	641d      	str	r5, [r3, #64]	; 0x40
                 
      
    						
   /*USIC 0 Channel 0 Mux Related SFR/Bitfields Configurations*/ 						         
 WR_REG(USIC0_CH0->DX0CR, USIC_CH_DX0CR_DSEL_Msk, USIC_CH_DX0CR_DSEL_Pos,4); 
10002ce6:	69cf      	ldr	r7, [r1, #28]
10002ce8:	2507      	movs	r5, #7
10002cea:	43af      	bics	r7, r5
10002cec:	4337      	orrs	r7, r6
  			  					 				 				 		       				              				  					    					 					   				  					 				 				       				  					    
 //Standard receive buffer event is enabled.                 
 WR_REG(USIC0_CH0->RBCTR, USIC_CH_RBCTR_SRBIEN_Msk, USIC_CH_RBCTR_SRBIEN_Pos,1);  
10002cee:	1c08      	adds	r0, r1, #0
    WR_REG(USIC0_CH1->CCR, USIC_CH_CCR_MODE_Msk, USIC_CH_CCR_MODE_Pos,0);   
                 
      
    						
   /*USIC 0 Channel 0 Mux Related SFR/Bitfields Configurations*/ 						         
 WR_REG(USIC0_CH0->DX0CR, USIC_CH_DX0CR_DSEL_Msk, USIC_CH_DX0CR_DSEL_Pos,4); 
10002cf0:	61cf      	str	r7, [r1, #28]
  			  					 				 				 		       				              				  					    					 					   				  					 				 				       				  					    
 //Standard receive buffer event is enabled.                 
 WR_REG(USIC0_CH0->RBCTR, USIC_CH_RBCTR_SRBIEN_Msk, USIC_CH_RBCTR_SRBIEN_Pos,1);  
10002cf2:	30fc      	adds	r0, #252	; 0xfc
10002cf4:	6904      	ldr	r4, [r0, #16]
10002cf6:	2780      	movs	r7, #128	; 0x80
10002cf8:	05fe      	lsls	r6, r7, #23
10002cfa:	4334      	orrs	r4, r6
10002cfc:	6104      	str	r4, [r0, #16]
 					 									 					 					  									      					              					  						    					      
                 
   // Data Pointer & Buffer Size for Transmitter Buffer Control  
 WR_REG(USIC0_CH0->TBCTR, USIC_CH_TBCTR_DPTRSIZE_Msk, USIC_CH_TBCTR_DPTRSIZE_Pos,0x01000006);		/*    DPTR = 6,  SIZE = 1 */ 
10002cfe:	68c7      	ldr	r7, [r0, #12]
10002d00:	4c69      	ldr	r4, [pc, #420]	; (10002ea8 <DAVE_MUX_Init+0x1e4>)
10002d02:	4e6a      	ldr	r6, [pc, #424]	; (10002eac <DAVE_MUX_Init+0x1e8>)
10002d04:	4027      	ands	r7, r4
10002d06:	4337      	orrs	r7, r6
10002d08:	60c7      	str	r7, [r0, #12]
           
  // Data Pointer & Buffer Size for Receiver Buffer Control  
 WR_REG(USIC0_CH0->RBCTR, USIC_CH_RBCTR_DPTRSIZE_Msk, USIC_CH_RBCTR_DPTRSIZE_Pos,0x01000004);		/*    DPTR = 4,  SIZE = 1 */ 
10002d0a:	6907      	ldr	r7, [r0, #16]
10002d0c:	4027      	ands	r7, r4
10002d0e:	9701      	str	r7, [sp, #4]
10002d10:	9e01      	ldr	r6, [sp, #4]
10002d12:	4f67      	ldr	r7, [pc, #412]	; (10002eb0 <DAVE_MUX_Init+0x1ec>)
10002d14:	433e      	orrs	r6, r7
10002d16:	6106      	str	r6, [r0, #16]
 						
   /*USIC 0 Channel 1 Mux Related SFR/Bitfields Configurations*/ 						         
 WR_REG(USIC0_CH1->DX0CR, USIC_CH_DX0CR_DSEL_Msk, USIC_CH_DX0CR_DSEL_Pos,5); 
10002d18:	69d8      	ldr	r0, [r3, #28]
10002d1a:	2705      	movs	r7, #5
10002d1c:	43a8      	bics	r0, r5
10002d1e:	4338      	orrs	r0, r7
10002d20:	61d8      	str	r0, [r3, #28]
  			                  
 WR_REG(USIC0_CH1->DX1CR, USIC_CH_DX1CR_DSEL_Msk, USIC_CH_DX1CR_DSEL_Pos,4);  
10002d22:	6a1e      	ldr	r6, [r3, #32]
  					 				 				 		       				              				  					    					 					   				  					 				 				       				  					    
 //Standard receive buffer event is enabled.                 
 WR_REG(USIC0_CH1->RBCTR, USIC_CH_RBCTR_SRBIEN_Msk, USIC_CH_RBCTR_SRBIEN_Pos,1);  
10002d24:	1c18      	adds	r0, r3, #0
 WR_REG(USIC0_CH0->RBCTR, USIC_CH_RBCTR_DPTRSIZE_Msk, USIC_CH_RBCTR_DPTRSIZE_Pos,0x01000004);		/*    DPTR = 4,  SIZE = 1 */ 
 						
   /*USIC 0 Channel 1 Mux Related SFR/Bitfields Configurations*/ 						         
 WR_REG(USIC0_CH1->DX0CR, USIC_CH_DX0CR_DSEL_Msk, USIC_CH_DX0CR_DSEL_Pos,5); 
  			                  
 WR_REG(USIC0_CH1->DX1CR, USIC_CH_DX1CR_DSEL_Msk, USIC_CH_DX1CR_DSEL_Pos,4);  
10002d26:	43ae      	bics	r6, r5
10002d28:	2504      	movs	r5, #4
10002d2a:	432e      	orrs	r6, r5
10002d2c:	621e      	str	r6, [r3, #32]
  					 				 				 		       				              				  					    					 					   				  					 				 				       				  					    
 //Standard receive buffer event is enabled.                 
 WR_REG(USIC0_CH1->RBCTR, USIC_CH_RBCTR_SRBIEN_Msk, USIC_CH_RBCTR_SRBIEN_Pos,1);  
10002d2e:	30fc      	adds	r0, #252	; 0xfc
10002d30:	6907      	ldr	r7, [r0, #16]
10002d32:	2680      	movs	r6, #128	; 0x80
10002d34:	05f5      	lsls	r5, r6, #23
10002d36:	433d      	orrs	r5, r7
10002d38:	6105      	str	r5, [r0, #16]
 					 									 					 					  									         
 //Interrupt node 2 is selected for Protocol specific event             
 WR_REG(USIC0_CH1->INPR, USIC_CH_INPR_PINP_Msk, USIC_CH_INPR_PINP_Pos,2);  
10002d3a:	699e      	ldr	r6, [r3, #24]
10002d3c:	4d5d      	ldr	r5, [pc, #372]	; (10002eb4 <DAVE_MUX_Init+0x1f0>)
10002d3e:	2780      	movs	r7, #128	; 0x80
10002d40:	402e      	ands	r6, r5
10002d42:	02bf      	lsls	r7, r7, #10
10002d44:	433e      	orrs	r6, r7
10002d46:	619e      	str	r6, [r3, #24]
 					              					  						       
 //Interrupt node 1 is selected for Standard receive buffer event                 
 WR_REG(USIC0_CH1->RBCTR, USIC_CH_RBCTR_SRBINP_Msk, USIC_CH_RBCTR_SRBINP_Pos,1);  
10002d48:	6906      	ldr	r6, [r0, #16]
10002d4a:	2780      	movs	r7, #128	; 0x80
10002d4c:	4035      	ands	r5, r6
10002d4e:	027e      	lsls	r6, r7, #9
10002d50:	4335      	orrs	r5, r6
10002d52:	6105      	str	r5, [r0, #16]
 					      
                 
   // Data Pointer & Buffer Size for Transmitter Buffer Control  
 WR_REG(USIC0_CH1->TBCTR, USIC_CH_TBCTR_DPTRSIZE_Msk, USIC_CH_TBCTR_DPTRSIZE_Pos,0x01000002);		/*    DPTR = 2,  SIZE = 1 */ 
10002d54:	68c5      	ldr	r5, [r0, #12]
10002d56:	4f58      	ldr	r7, [pc, #352]	; (10002eb8 <DAVE_MUX_Init+0x1f4>)
10002d58:	4025      	ands	r5, r4
10002d5a:	433d      	orrs	r5, r7
10002d5c:	60c5      	str	r5, [r0, #12]
         
  // Data Pointer & Buffer Size for Receiver Buffer Control  
 WR_REG(USIC0_CH1->RBCTR, USIC_CH_RBCTR_DPTRSIZE_Msk, USIC_CH_RBCTR_DPTRSIZE_Pos,0x01000000);		/*    DPTR = 0,  SIZE = 1 */ 
10002d5e:	6906      	ldr	r6, [r0, #16]
10002d60:	2580      	movs	r5, #128	; 0x80
10002d62:	046f      	lsls	r7, r5, #17
10002d64:	4034      	ands	r4, r6
10002d66:	433c      	orrs	r4, r7
10002d68:	6104      	str	r4, [r0, #16]
   /*USIC 2 Channel 1 Mux Related SFR/Bitfields Configurations*/ 									  					 				 				 		       				              				  					    					 					   				  					 				 				       				  										 									 					 					  									      					              					  						    					      
         
  
  /* Enable mode after configuring all USIC registers to avoid unintended edges */  
            
   WR_REG(USIC0_CH0->CCR, USIC_CH_CCR_MODE_Msk, USIC_CH_CCR_MODE_Pos,UsicCcrMode[0]); 
10002d6a:	6c08      	ldr	r0, [r1, #64]	; 0x40
10002d6c:	9c02      	ldr	r4, [sp, #8]
10002d6e:	4390      	bics	r0, r2
10002d70:	4014      	ands	r4, r2
10002d72:	4320      	orrs	r0, r4
10002d74:	6408      	str	r0, [r1, #64]	; 0x40
         
   WR_REG(USIC0_CH1->CCR, USIC_CH_CCR_MODE_Msk, USIC_CH_CCR_MODE_Pos,UsicCcrMode[1]);   
10002d76:	6c19      	ldr	r1, [r3, #64]	; 0x40
10002d78:	9e03      	ldr	r6, [sp, #12]
10002d7a:	4391      	bics	r1, r2
10002d7c:	4016      	ands	r6, r2
10002d7e:	4331      	orrs	r1, r6
10002d80:	6419      	str	r1, [r3, #64]	; 0x40
                                                     
        //********* Capture/Compare Unit 4 (CAPCOM4) CONFIGURATIONS ************************* 
                       
    // Configuring CCU40 CC41INS - Input Selector Configuration

    WR_REG(CCU40_CC41->INS, CCU4_CC4_INS_EV0IS_Msk, CCU4_CC4_INS_EV0IS_Pos, CCU4xINyB);                   
10002d82:	4b4e      	ldr	r3, [pc, #312]	; (10002ebc <DAVE_MUX_Init+0x1f8>)
10002d84:	2701      	movs	r7, #1
10002d86:	681d      	ldr	r5, [r3, #0]

    WR_REG(CCU40_CC41->INS, CCU4_CC4_INS_EV1IS_Msk, CCU4_CC4_INS_EV1IS_Pos, CCU4xINyB);                   
10002d88:	20f0      	movs	r0, #240	; 0xf0
                                                     
        //********* Capture/Compare Unit 4 (CAPCOM4) CONFIGURATIONS ************************* 
                       
    // Configuring CCU40 CC41INS - Input Selector Configuration

    WR_REG(CCU40_CC41->INS, CCU4_CC4_INS_EV0IS_Msk, CCU4_CC4_INS_EV0IS_Pos, CCU4xINyB);                   
10002d8a:	4395      	bics	r5, r2
10002d8c:	433d      	orrs	r5, r7
10002d8e:	601d      	str	r5, [r3, #0]

    WR_REG(CCU40_CC41->INS, CCU4_CC4_INS_EV1IS_Msk, CCU4_CC4_INS_EV1IS_Pos, CCU4xINyB);                   
10002d90:	681c      	ldr	r4, [r3, #0]
10002d92:	2110      	movs	r1, #16
10002d94:	4384      	bics	r4, r0
                       
    // Configuring CCU40 CC42INS - Input Selector Configuration

    WR_REG(CCU40_CC42->INS, CCU4_CC4_INS_EV0IS_Msk, CCU4_CC4_INS_EV0IS_Pos, CCU4xINyB);                   
10002d96:	4e4a      	ldr	r6, [pc, #296]	; (10002ec0 <DAVE_MUX_Init+0x1fc>)
                       
    // Configuring CCU40 CC41INS - Input Selector Configuration

    WR_REG(CCU40_CC41->INS, CCU4_CC4_INS_EV0IS_Msk, CCU4_CC4_INS_EV0IS_Pos, CCU4xINyB);                   

    WR_REG(CCU40_CC41->INS, CCU4_CC4_INS_EV1IS_Msk, CCU4_CC4_INS_EV1IS_Pos, CCU4xINyB);                   
10002d98:	430c      	orrs	r4, r1
10002d9a:	601c      	str	r4, [r3, #0]
                       
    // Configuring CCU40 CC42INS - Input Selector Configuration

    WR_REG(CCU40_CC42->INS, CCU4_CC4_INS_EV0IS_Msk, CCU4_CC4_INS_EV0IS_Pos, CCU4xINyB);                   
10002d9c:	6833      	ldr	r3, [r6, #0]

    WR_REG(CCU40_CC42->INS, CCU4_CC4_INS_EV1IS_Msk, CCU4_CC4_INS_EV1IS_Pos, CCU4xINyB);                   
                       
    // Configuring CCU40 CC43INS - Input Selector Configuration

    WR_REG(CCU40_CC43->INS, CCU4_CC4_INS_EV0IS_Msk, CCU4_CC4_INS_EV0IS_Pos, CCU4xINyB);                   
10002d9e:	4c49      	ldr	r4, [pc, #292]	; (10002ec4 <DAVE_MUX_Init+0x200>)

    WR_REG(CCU40_CC41->INS, CCU4_CC4_INS_EV1IS_Msk, CCU4_CC4_INS_EV1IS_Pos, CCU4xINyB);                   
                       
    // Configuring CCU40 CC42INS - Input Selector Configuration

    WR_REG(CCU40_CC42->INS, CCU4_CC4_INS_EV0IS_Msk, CCU4_CC4_INS_EV0IS_Pos, CCU4xINyB);                   
10002da0:	4393      	bics	r3, r2
10002da2:	433b      	orrs	r3, r7
10002da4:	6033      	str	r3, [r6, #0]

    WR_REG(CCU40_CC42->INS, CCU4_CC4_INS_EV1IS_Msk, CCU4_CC4_INS_EV1IS_Pos, CCU4xINyB);                   
10002da6:	6835      	ldr	r5, [r6, #0]
   	 
            	         
                                                 

/*        PORT Macro definitions for IOCR_OE, IOCR_PCR & HWSEL_HW     */                                      
  WR_REG(PORT0->IOCR0, PORT_IOCR_PC0_OE_Msk, PORT_IOCR_PC0_OE_Pos, PORT_IOCR_OE1);                /*    P0.0 : PORT0_IOCR0_PC0_OE */					   
10002da8:	4b47      	ldr	r3, [pc, #284]	; (10002ec8 <DAVE_MUX_Init+0x204>)
                       
    // Configuring CCU40 CC42INS - Input Selector Configuration

    WR_REG(CCU40_CC42->INS, CCU4_CC4_INS_EV0IS_Msk, CCU4_CC4_INS_EV0IS_Pos, CCU4xINyB);                   

    WR_REG(CCU40_CC42->INS, CCU4_CC4_INS_EV1IS_Msk, CCU4_CC4_INS_EV1IS_Pos, CCU4xINyB);                   
10002daa:	4385      	bics	r5, r0
10002dac:	430d      	orrs	r5, r1
10002dae:	6035      	str	r5, [r6, #0]
                       
    // Configuring CCU40 CC43INS - Input Selector Configuration

    WR_REG(CCU40_CC43->INS, CCU4_CC4_INS_EV0IS_Msk, CCU4_CC4_INS_EV0IS_Pos, CCU4xINyB);                   
10002db0:	6826      	ldr	r6, [r4, #0]
10002db2:	4396      	bics	r6, r2
10002db4:	4337      	orrs	r7, r6
10002db6:	6027      	str	r7, [r4, #0]

    WR_REG(CCU40_CC43->INS, CCU4_CC4_INS_EV1IS_Msk, CCU4_CC4_INS_EV1IS_Pos, CCU4xINyB);                   
10002db8:	6827      	ldr	r7, [r4, #0]
/*        PORT Macro definitions for IOCR_OE, IOCR_PCR & HWSEL_HW     */                                      
  WR_REG(PORT0->IOCR0, PORT_IOCR_PC0_OE_Msk, PORT_IOCR_PC0_OE_Pos, PORT_IOCR_OE1);                /*    P0.0 : PORT0_IOCR0_PC0_OE */					   
					                         
  WR_REG(PORT0->IOCR4, 0xb8U, PORT_IOCR_PC0_PCR_Pos, 0x11U);                /*P0.4 : PORT0_IOCR4_PC4_PCR and PORT0_IOCR4_PC4_OE */					   
					                         
  WR_REG(PORT0->IOCR4, 0xb800U, PORT_IOCR_PC1_PCR_Pos, 0x16U);                /*P0.5 : PORT0_IOCR4_PC5_PCR and PORT0_IOCR4_PC5_OE */					   
10002dba:	22b0      	movs	r2, #176	; 0xb0
                       
    // Configuring CCU40 CC43INS - Input Selector Configuration

    WR_REG(CCU40_CC43->INS, CCU4_CC4_INS_EV0IS_Msk, CCU4_CC4_INS_EV0IS_Pos, CCU4xINyB);                   

    WR_REG(CCU40_CC43->INS, CCU4_CC4_INS_EV1IS_Msk, CCU4_CC4_INS_EV1IS_Pos, CCU4xINyB);                   
10002dbc:	4387      	bics	r7, r0
10002dbe:	4339      	orrs	r1, r7
10002dc0:	6021      	str	r1, [r4, #0]
   	 
            	         
                                                 

/*        PORT Macro definitions for IOCR_OE, IOCR_PCR & HWSEL_HW     */                                      
  WR_REG(PORT0->IOCR0, PORT_IOCR_PC0_OE_Msk, PORT_IOCR_PC0_OE_Pos, PORT_IOCR_OE1);                /*    P0.0 : PORT0_IOCR0_PC0_OE */					   
10002dc2:	6918      	ldr	r0, [r3, #16]
10002dc4:	2180      	movs	r1, #128	; 0x80
10002dc6:	4308      	orrs	r0, r1
10002dc8:	6118      	str	r0, [r3, #16]
					                         
  WR_REG(PORT0->IOCR4, 0xb8U, PORT_IOCR_PC0_PCR_Pos, 0x11U);                /*P0.4 : PORT0_IOCR4_PC4_PCR and PORT0_IOCR4_PC4_OE */					   
10002dca:	695d      	ldr	r5, [r3, #20]
10002dcc:	27b8      	movs	r7, #184	; 0xb8
10002dce:	2488      	movs	r4, #136	; 0x88
10002dd0:	43bd      	bics	r5, r7
10002dd2:	4325      	orrs	r5, r4
10002dd4:	615d      	str	r5, [r3, #20]
					                         
  WR_REG(PORT0->IOCR4, 0xb800U, PORT_IOCR_PC1_PCR_Pos, 0x16U);                /*P0.5 : PORT0_IOCR4_PC5_PCR and PORT0_IOCR4_PC5_OE */					   
10002dd6:	695e      	ldr	r6, [r3, #20]
10002dd8:	483c      	ldr	r0, [pc, #240]	; (10002ecc <DAVE_MUX_Init+0x208>)
10002dda:	0211      	lsls	r1, r2, #8
10002ddc:	4006      	ands	r6, r0
10002dde:	430e      	orrs	r6, r1
10002de0:	615e      	str	r6, [r3, #20]
					                         
  WR_REG(PORT0->IOCR4, 0xb80000U, PORT_IOCR_PC2_PCR_Pos, 0x11U);                /*P0.6 : PORT0_IOCR4_PC6_PCR and PORT0_IOCR4_PC6_OE */					   
10002de2:	695d      	ldr	r5, [r3, #20]
10002de4:	4a3a      	ldr	r2, [pc, #232]	; (10002ed0 <DAVE_MUX_Init+0x20c>)
10002de6:	0421      	lsls	r1, r4, #16
10002de8:	4015      	ands	r5, r2
10002dea:	430d      	orrs	r5, r1
10002dec:	615d      	str	r5, [r3, #20]
					                         
  WR_REG(PORT0->IOCR8, 0xb80000U, PORT_IOCR_PC2_PCR_Pos, 0x14U);                /*P0.10 : PORT0_IOCR8_PC10_PCR and PORT0_IOCR8_PC10_OE */					   
10002dee:	699d      	ldr	r5, [r3, #24]
10002df0:	26a0      	movs	r6, #160	; 0xa0
10002df2:	0431      	lsls	r1, r6, #16
10002df4:	4015      	ands	r5, r2
10002df6:	430d      	orrs	r5, r1
10002df8:	619d      	str	r5, [r3, #24]
					                         
  WR_REG(PORT0->IOCR12, 0xb8U, PORT_IOCR_PC0_PCR_Pos, 0x11U);                /*P0.12 : PORT0_IOCR12_PC12_PCR and PORT0_IOCR12_PC12_OE */					   
10002dfa:	69dd      	ldr	r5, [r3, #28]
10002dfc:	43bd      	bics	r5, r7
10002dfe:	432c      	orrs	r4, r5
10002e00:	61dc      	str	r4, [r3, #28]
					                         
  WR_REG(PORT0->IOCR12, PORT_IOCR_PC1_OE_Msk, PORT_IOCR_PC1_OE_Pos, PORT_IOCR_OE1);                /*    P0.13 : PORT0_IOCR12_PC13_OE */					   
10002e02:	69de      	ldr	r6, [r3, #28]
10002e04:	2480      	movs	r4, #128	; 0x80
10002e06:	0221      	lsls	r1, r4, #8
10002e08:	4331      	orrs	r1, r6
10002e0a:	61d9      	str	r1, [r3, #28]
					                         
  WR_REG(PORT1->IOCR0, 0xb8U, PORT_IOCR_PC0_PCR_Pos, 0x16U);                /*P1.0 : PORT1_IOCR0_PC0_PCR and PORT1_IOCR0_PC0_OE */					   
10002e0c:	4b31      	ldr	r3, [pc, #196]	; (10002ed4 <DAVE_MUX_Init+0x210>)
10002e0e:	26b0      	movs	r6, #176	; 0xb0
10002e10:	691d      	ldr	r5, [r3, #16]
					                         
  WR_REG(PORT1->IOCR0, 0xb800U, PORT_IOCR_PC1_PCR_Pos, 0x12U);                /*P1.1 : PORT1_IOCR0_PC1_PCR and PORT1_IOCR0_PC1_OE */					   
10002e12:	2190      	movs	r1, #144	; 0x90
					                         
  WR_REG(PORT0->IOCR12, 0xb8U, PORT_IOCR_PC0_PCR_Pos, 0x11U);                /*P0.12 : PORT0_IOCR12_PC12_PCR and PORT0_IOCR12_PC12_OE */					   
					                         
  WR_REG(PORT0->IOCR12, PORT_IOCR_PC1_OE_Msk, PORT_IOCR_PC1_OE_Pos, PORT_IOCR_OE1);                /*    P0.13 : PORT0_IOCR12_PC13_OE */					   
					                         
  WR_REG(PORT1->IOCR0, 0xb8U, PORT_IOCR_PC0_PCR_Pos, 0x16U);                /*P1.0 : PORT1_IOCR0_PC0_PCR and PORT1_IOCR0_PC0_OE */					   
10002e14:	43bd      	bics	r5, r7
10002e16:	1c2f      	adds	r7, r5, #0
10002e18:	4337      	orrs	r7, r6
10002e1a:	611f      	str	r7, [r3, #16]
					                         
  WR_REG(PORT1->IOCR0, 0xb800U, PORT_IOCR_PC1_PCR_Pos, 0x12U);                /*P1.1 : PORT1_IOCR0_PC1_PCR and PORT1_IOCR0_PC1_OE */					   
10002e1c:	691c      	ldr	r4, [r3, #16]
10002e1e:	020d      	lsls	r5, r1, #8
10002e20:	4020      	ands	r0, r4
10002e22:	4328      	orrs	r0, r5
10002e24:	6118      	str	r0, [r3, #16]
					                         
  WR_REG(PORT1->IOCR0, 0xb80000U, PORT_IOCR_PC2_PCR_Pos, 0x12U);                /*P1.2 : PORT1_IOCR0_PC2_PCR and PORT1_IOCR0_PC2_OE */					   
10002e26:	6918      	ldr	r0, [r3, #16]
10002e28:	2790      	movs	r7, #144	; 0x90
10002e2a:	043c      	lsls	r4, r7, #16
10002e2c:	4002      	ands	r2, r0
10002e2e:	4322      	orrs	r2, r4
10002e30:	611a      	str	r2, [r3, #16]
					                         
  WR_REG(PORT1->IOCR0, 0xb8000000U, PORT_IOCR_PC3_PCR_Pos, 0x12U);                /*P1.3 : PORT1_IOCR0_PC3_PCR and PORT1_IOCR0_PC3_OE */					   
10002e32:	6919      	ldr	r1, [r3, #16]
10002e34:	4a28      	ldr	r2, [pc, #160]	; (10002ed8 <DAVE_MUX_Init+0x214>)
10002e36:	2590      	movs	r5, #144	; 0x90
10002e38:	0628      	lsls	r0, r5, #24
10002e3a:	4011      	ands	r1, r2
10002e3c:	4301      	orrs	r1, r0
10002e3e:	6119      	str	r1, [r3, #16]
					  
           
  WR_REG(PORT2->PDISC, PORT2_PDISC_PDIS10_Msk, PORT2_PDISC_PDIS10_Pos, PORT_PDISC_PDIS0);            /*    P2.10 : PORT2_PDISC_PDIS10 */                       
10002e40:	4b26      	ldr	r3, [pc, #152]	; (10002edc <DAVE_MUX_Init+0x218>)
10002e42:	4c27      	ldr	r4, [pc, #156]	; (10002ee0 <DAVE_MUX_Init+0x21c>)
10002e44:	6e1f      	ldr	r7, [r3, #96]	; 0x60
  WR_REG(PORT2->IOCR8, 0xb80000U, PORT_IOCR_PC2_PCR_Pos, 0x17U);                /*P2.10 : PORT2_IOCR8_PC10_PCR and PORT2_IOCR8_PC10_OE */					   
10002e46:	21b8      	movs	r1, #184	; 0xb8
  WR_REG(PORT1->IOCR0, 0xb80000U, PORT_IOCR_PC2_PCR_Pos, 0x12U);                /*P1.2 : PORT1_IOCR0_PC2_PCR and PORT1_IOCR0_PC2_OE */					   
					                         
  WR_REG(PORT1->IOCR0, 0xb8000000U, PORT_IOCR_PC3_PCR_Pos, 0x12U);                /*P1.3 : PORT1_IOCR0_PC3_PCR and PORT1_IOCR0_PC3_OE */					   
					  
           
  WR_REG(PORT2->PDISC, PORT2_PDISC_PDIS10_Msk, PORT2_PDISC_PDIS10_Pos, PORT_PDISC_PDIS0);            /*    P2.10 : PORT2_PDISC_PDIS10 */                       
10002e48:	403c      	ands	r4, r7
10002e4a:	661c      	str	r4, [r3, #96]	; 0x60
  WR_REG(PORT2->IOCR8, 0xb80000U, PORT_IOCR_PC2_PCR_Pos, 0x17U);                /*P2.10 : PORT2_IOCR8_PC10_PCR and PORT2_IOCR8_PC10_OE */					   
10002e4c:	699d      	ldr	r5, [r3, #24]
10002e4e:	0408      	lsls	r0, r1, #16
10002e50:	4328      	orrs	r0, r5
10002e52:	6198      	str	r0, [r3, #24]
					  
           
  WR_REG(PORT2->PDISC, PORT2_PDISC_PDIS11_Msk, PORT2_PDISC_PDIS11_Pos, PORT_PDISC_PDIS0);            /*    P2.11 : PORT2_PDISC_PDIS11 */                       
10002e54:	6e1f      	ldr	r7, [r3, #96]	; 0x60
10002e56:	4c23      	ldr	r4, [pc, #140]	; (10002ee4 <DAVE_MUX_Init+0x220>)
  WR_REG(PORT2->IOCR8, 0xb8000000U, PORT_IOCR_PC3_PCR_Pos, 0x16U);                /*P2.11 : PORT2_IOCR8_PC11_PCR and PORT2_IOCR8_PC11_OE */					   
10002e58:	0631      	lsls	r1, r6, #24
           
  WR_REG(PORT2->PDISC, PORT2_PDISC_PDIS10_Msk, PORT2_PDISC_PDIS10_Pos, PORT_PDISC_PDIS0);            /*    P2.10 : PORT2_PDISC_PDIS10 */                       
  WR_REG(PORT2->IOCR8, 0xb80000U, PORT_IOCR_PC2_PCR_Pos, 0x17U);                /*P2.10 : PORT2_IOCR8_PC10_PCR and PORT2_IOCR8_PC10_OE */					   
					  
           
  WR_REG(PORT2->PDISC, PORT2_PDISC_PDIS11_Msk, PORT2_PDISC_PDIS11_Pos, PORT_PDISC_PDIS0);            /*    P2.11 : PORT2_PDISC_PDIS11 */                       
10002e5a:	403c      	ands	r4, r7
10002e5c:	661c      	str	r4, [r3, #96]	; 0x60
  WR_REG(PORT2->IOCR8, 0xb8000000U, PORT_IOCR_PC3_PCR_Pos, 0x16U);                /*P2.11 : PORT2_IOCR8_PC11_PCR and PORT2_IOCR8_PC11_OE */					   
10002e5e:	699d      	ldr	r5, [r3, #24]
                                             
/*        BCCU Macro definitions:         */ 

  WR_REG(BCCU0_CH0->CHCONFIG, BCCU_CH_CHCONFIG_DSEL_Msk, BCCU_CH_CHCONFIG_DSEL_Pos, 7);                /*    BCCU_CHCONFIG0_DSEL */

  WR_REG(BCCU0_CH2->CHCONFIG, BCCU_CH_CHCONFIG_DSEL_Msk, BCCU_CH_CHCONFIG_DSEL_Pos, 7);                /*    BCCU_CHCONFIG2_DSEL */
10002e60:	4f21      	ldr	r7, [pc, #132]	; (10002ee8 <DAVE_MUX_Init+0x224>)
  WR_REG(PORT2->PDISC, PORT2_PDISC_PDIS10_Msk, PORT2_PDISC_PDIS10_Pos, PORT_PDISC_PDIS0);            /*    P2.10 : PORT2_PDISC_PDIS10 */                       
  WR_REG(PORT2->IOCR8, 0xb80000U, PORT_IOCR_PC2_PCR_Pos, 0x17U);                /*P2.10 : PORT2_IOCR8_PC10_PCR and PORT2_IOCR8_PC10_OE */					   
					  
           
  WR_REG(PORT2->PDISC, PORT2_PDISC_PDIS11_Msk, PORT2_PDISC_PDIS11_Pos, PORT_PDISC_PDIS0);            /*    P2.11 : PORT2_PDISC_PDIS11 */                       
  WR_REG(PORT2->IOCR8, 0xb8000000U, PORT_IOCR_PC3_PCR_Pos, 0x16U);                /*P2.11 : PORT2_IOCR8_PC11_PCR and PORT2_IOCR8_PC11_OE */					   
10002e62:	402a      	ands	r2, r5
10002e64:	430a      	orrs	r2, r1
10002e66:	619a      	str	r2, [r3, #24]
   	 
            	         
                                             
/*        BCCU Macro definitions:         */ 

  WR_REG(BCCU0_CH0->CHCONFIG, BCCU_CH_CHCONFIG_DSEL_Msk, BCCU_CH_CHCONFIG_DSEL_Pos, 7);                /*    BCCU_CHCONFIG0_DSEL */
10002e68:	4a20      	ldr	r2, [pc, #128]	; (10002eec <DAVE_MUX_Init+0x228>)
10002e6a:	2370      	movs	r3, #112	; 0x70
10002e6c:	6890      	ldr	r0, [r2, #8]

  WR_REG(BCCU0_CH2->CHCONFIG, BCCU_CH_CHCONFIG_DSEL_Msk, BCCU_CH_CHCONFIG_DSEL_Pos, 7);                /*    BCCU_CHCONFIG2_DSEL */

  WR_REG(BCCU0_CH3->CHCONFIG, BCCU_CH_CHCONFIG_DSEL_Msk, BCCU_CH_CHCONFIG_DSEL_Pos, 2);                /*    BCCU_CHCONFIG3_DSEL */
10002e6e:	4d20      	ldr	r5, [pc, #128]	; (10002ef0 <DAVE_MUX_Init+0x22c>)
   	 
            	         
                                             
/*        BCCU Macro definitions:         */ 

  WR_REG(BCCU0_CH0->CHCONFIG, BCCU_CH_CHCONFIG_DSEL_Msk, BCCU_CH_CHCONFIG_DSEL_Pos, 7);                /*    BCCU_CHCONFIG0_DSEL */
10002e70:	4318      	orrs	r0, r3
10002e72:	6090      	str	r0, [r2, #8]

  WR_REG(BCCU0_CH2->CHCONFIG, BCCU_CH_CHCONFIG_DSEL_Msk, BCCU_CH_CHCONFIG_DSEL_Pos, 7);                /*    BCCU_CHCONFIG2_DSEL */
10002e74:	68bc      	ldr	r4, [r7, #8]

  WR_REG(BCCU0_CH3->CHCONFIG, BCCU_CH_CHCONFIG_DSEL_Msk, BCCU_CH_CHCONFIG_DSEL_Pos, 2);                /*    BCCU_CHCONFIG3_DSEL */
10002e76:	2220      	movs	r2, #32
                                             
/*        BCCU Macro definitions:         */ 

  WR_REG(BCCU0_CH0->CHCONFIG, BCCU_CH_CHCONFIG_DSEL_Msk, BCCU_CH_CHCONFIG_DSEL_Pos, 7);                /*    BCCU_CHCONFIG0_DSEL */

  WR_REG(BCCU0_CH2->CHCONFIG, BCCU_CH_CHCONFIG_DSEL_Msk, BCCU_CH_CHCONFIG_DSEL_Pos, 7);                /*    BCCU_CHCONFIG2_DSEL */
10002e78:	431c      	orrs	r4, r3
10002e7a:	60bc      	str	r4, [r7, #8]

  WR_REG(BCCU0_CH3->CHCONFIG, BCCU_CH_CHCONFIG_DSEL_Msk, BCCU_CH_CHCONFIG_DSEL_Pos, 2);                /*    BCCU_CHCONFIG3_DSEL */
10002e7c:	68ae      	ldr	r6, [r5, #8]

  WR_REG(BCCU0_CH4->CHCONFIG, BCCU_CH_CHCONFIG_DSEL_Msk, BCCU_CH_CHCONFIG_DSEL_Pos, 2);                /*    BCCU_CHCONFIG4_DSEL */
10002e7e:	491d      	ldr	r1, [pc, #116]	; (10002ef4 <DAVE_MUX_Init+0x230>)

  WR_REG(BCCU0_CH0->CHCONFIG, BCCU_CH_CHCONFIG_DSEL_Msk, BCCU_CH_CHCONFIG_DSEL_Pos, 7);                /*    BCCU_CHCONFIG0_DSEL */

  WR_REG(BCCU0_CH2->CHCONFIG, BCCU_CH_CHCONFIG_DSEL_Msk, BCCU_CH_CHCONFIG_DSEL_Pos, 7);                /*    BCCU_CHCONFIG2_DSEL */

  WR_REG(BCCU0_CH3->CHCONFIG, BCCU_CH_CHCONFIG_DSEL_Msk, BCCU_CH_CHCONFIG_DSEL_Pos, 2);                /*    BCCU_CHCONFIG3_DSEL */
10002e80:	439e      	bics	r6, r3
10002e82:	4316      	orrs	r6, r2
10002e84:	60ae      	str	r6, [r5, #8]

  WR_REG(BCCU0_CH4->CHCONFIG, BCCU_CH_CHCONFIG_DSEL_Msk, BCCU_CH_CHCONFIG_DSEL_Pos, 2);                /*    BCCU_CHCONFIG4_DSEL */
10002e86:	6888      	ldr	r0, [r1, #8]

  WR_REG(BCCU0_CH5->CHCONFIG, BCCU_CH_CHCONFIG_DSEL_Msk, BCCU_CH_CHCONFIG_DSEL_Pos, 2);                /*    BCCU_CHCONFIG5_DSEL */
10002e88:	4f1b      	ldr	r7, [pc, #108]	; (10002ef8 <DAVE_MUX_Init+0x234>)

  WR_REG(BCCU0_CH2->CHCONFIG, BCCU_CH_CHCONFIG_DSEL_Msk, BCCU_CH_CHCONFIG_DSEL_Pos, 7);                /*    BCCU_CHCONFIG2_DSEL */

  WR_REG(BCCU0_CH3->CHCONFIG, BCCU_CH_CHCONFIG_DSEL_Msk, BCCU_CH_CHCONFIG_DSEL_Pos, 2);                /*    BCCU_CHCONFIG3_DSEL */

  WR_REG(BCCU0_CH4->CHCONFIG, BCCU_CH_CHCONFIG_DSEL_Msk, BCCU_CH_CHCONFIG_DSEL_Pos, 2);                /*    BCCU_CHCONFIG4_DSEL */
10002e8a:	4398      	bics	r0, r3
10002e8c:	4310      	orrs	r0, r2
10002e8e:	6088      	str	r0, [r1, #8]

  WR_REG(BCCU0_CH5->CHCONFIG, BCCU_CH_CHCONFIG_DSEL_Msk, BCCU_CH_CHCONFIG_DSEL_Pos, 2);                /*    BCCU_CHCONFIG5_DSEL */
10002e90:	68bc      	ldr	r4, [r7, #8]

  WR_REG(BCCU0_CH6->CHCONFIG, BCCU_CH_CHCONFIG_DSEL_Msk, BCCU_CH_CHCONFIG_DSEL_Pos, 7);                /*    BCCU_CHCONFIG6_DSEL */        
10002e92:	4d1a      	ldr	r5, [pc, #104]	; (10002efc <DAVE_MUX_Init+0x238>)

  WR_REG(BCCU0_CH3->CHCONFIG, BCCU_CH_CHCONFIG_DSEL_Msk, BCCU_CH_CHCONFIG_DSEL_Pos, 2);                /*    BCCU_CHCONFIG3_DSEL */

  WR_REG(BCCU0_CH4->CHCONFIG, BCCU_CH_CHCONFIG_DSEL_Msk, BCCU_CH_CHCONFIG_DSEL_Pos, 2);                /*    BCCU_CHCONFIG4_DSEL */

  WR_REG(BCCU0_CH5->CHCONFIG, BCCU_CH_CHCONFIG_DSEL_Msk, BCCU_CH_CHCONFIG_DSEL_Pos, 2);                /*    BCCU_CHCONFIG5_DSEL */
10002e94:	439c      	bics	r4, r3
10002e96:	4322      	orrs	r2, r4
10002e98:	60ba      	str	r2, [r7, #8]

  WR_REG(BCCU0_CH6->CHCONFIG, BCCU_CH_CHCONFIG_DSEL_Msk, BCCU_CH_CHCONFIG_DSEL_Pos, 7);                /*    BCCU_CHCONFIG6_DSEL */        
10002e9a:	68ae      	ldr	r6, [r5, #8]
10002e9c:	4333      	orrs	r3, r6
10002e9e:	60ab      	str	r3, [r5, #8]
}
10002ea0:	b005      	add	sp, #20
10002ea2:	bdf0      	pop	{r4, r5, r6, r7, pc}
10002ea4:	48000200 	.word	0x48000200
10002ea8:	f8ffffc0 	.word	0xf8ffffc0
10002eac:	01000006 	.word	0x01000006
10002eb0:	01000004 	.word	0x01000004
10002eb4:	fff8ffff 	.word	0xfff8ffff
10002eb8:	01000002 	.word	0x01000002
10002ebc:	48040200 	.word	0x48040200
10002ec0:	48040300 	.word	0x48040300
10002ec4:	48040400 	.word	0x48040400
10002ec8:	40040000 	.word	0x40040000
10002ecc:	ffff47ff 	.word	0xffff47ff
10002ed0:	ff47ffff 	.word	0xff47ffff
10002ed4:	40040100 	.word	0x40040100
10002ed8:	47ffffff 	.word	0x47ffffff
10002edc:	40040200 	.word	0x40040200
10002ee0:	fffffbff 	.word	0xfffffbff
10002ee4:	fffff7ff 	.word	0xfffff7ff
10002ee8:	50030064 	.word	0x50030064
10002eec:	5003003c 	.word	0x5003003c
10002ef0:	50030078 	.word	0x50030078
10002ef4:	5003008c 	.word	0x5003008c
10002ef8:	500300a0 	.word	0x500300a0
10002efc:	500300b4 	.word	0x500300b4

10002f00 <DAVE_MUX_PreInit>:
void DAVE_MUX_PreInit(void)
{                    

/*        PORT Macro definitions for IOCR_OE, IOCR_PCR & HWSEL_HW     */               
           
  WR_REG(PORT2->PDISC, PORT2_PDISC_PDIS0_Msk, PORT2_PDISC_PDIS0_Pos, PORT_PDISC_PDIS0);            /*    P2.0 : PORT2_PDISC_PDIS0 */        
10002f00:	4b02      	ldr	r3, [pc, #8]	; (10002f0c <DAVE_MUX_PreInit+0xc>)
10002f02:	2101      	movs	r1, #1
10002f04:	6e1a      	ldr	r2, [r3, #96]	; 0x60
10002f06:	438a      	bics	r2, r1
10002f08:	661a      	str	r2, [r3, #96]	; 0x60
}
10002f0a:	4770      	bx	lr
10002f0c:	40040200 	.word	0x40040200

10002f10 <COLORLAMP01_Init>:
*******************************************************************************/
//This function is called by DAVESupport App
void COLORLAMP01_Init(void)
{
	
}
10002f10:	4770      	bx	lr

10002f12 <COLORLAMP01_SetColor>:
}

/* Set the target Color */
void COLORLAMP01_SetColor(const COLORLAMP01_ConfigHandleType *Handle,
                          COLORLAMP01_ColorHandleType *HandleColor)
{
10002f12:	b538      	push	{r3, r4, r5, lr}
10002f14:	1c04      	adds	r4, r0, #0

  if(Handle->ChannelRed != NULL) {
10002f16:	6800      	ldr	r0, [r0, #0]
}

/* Set the target Color */
void COLORLAMP01_SetColor(const COLORLAMP01_ConfigHandleType *Handle,
                          COLORLAMP01_ColorHandleType *HandleColor)
{
10002f18:	1c0d      	adds	r5, r1, #0

  if(Handle->ChannelRed != NULL) {
10002f1a:	2800      	cmp	r0, #0
10002f1c:	d006      	beq.n	10002f2c <COLORLAMP01_SetColor+0x1a>

    BCCUCH01_SetIntensity((Handle->ChannelRed), (HandleColor->Intensity_Red));
10002f1e:	6809      	ldr	r1, [r1, #0]
10002f20:	f000 f9f5 	bl	1000330e <BCCUCH01_SetIntensity>

    BCCUCH01_SetLinearWalkPrescaler((Handle->ChannelRed), 
10002f24:	6820      	ldr	r0, [r4, #0]
10002f26:	69a9      	ldr	r1, [r5, #24]
10002f28:	f000 f9f8 	bl	1000331c <BCCUCH01_SetLinearWalkPrescaler>
                               (HandleColor->LinearWalkPrescaler));
  }

  if(Handle->ChannelGreen != NULL) {
10002f2c:	6860      	ldr	r0, [r4, #4]
10002f2e:	2800      	cmp	r0, #0
10002f30:	d006      	beq.n	10002f40 <COLORLAMP01_SetColor+0x2e>

    BCCUCH01_SetIntensity((Handle->ChannelGreen), 
10002f32:	6869      	ldr	r1, [r5, #4]
10002f34:	f000 f9eb 	bl	1000330e <BCCUCH01_SetIntensity>
                          (HandleColor->Intensity_Green));

    BCCUCH01_SetLinearWalkPrescaler((Handle->ChannelGreen), 
10002f38:	6860      	ldr	r0, [r4, #4]
10002f3a:	69a9      	ldr	r1, [r5, #24]
10002f3c:	f000 f9ee 	bl	1000331c <BCCUCH01_SetLinearWalkPrescaler>
                               (HandleColor->LinearWalkPrescaler));
  }

  if(Handle->ChannelBlue != NULL) {
10002f40:	68a0      	ldr	r0, [r4, #8]
10002f42:	2800      	cmp	r0, #0
10002f44:	d006      	beq.n	10002f54 <COLORLAMP01_SetColor+0x42>

    BCCUCH01_SetIntensity((Handle->ChannelBlue), (HandleColor->Intensity_Blue));
10002f46:	68a9      	ldr	r1, [r5, #8]
10002f48:	f000 f9e1 	bl	1000330e <BCCUCH01_SetIntensity>

    BCCUCH01_SetLinearWalkPrescaler((Handle->ChannelBlue), 
10002f4c:	68a0      	ldr	r0, [r4, #8]
10002f4e:	69a9      	ldr	r1, [r5, #24]
10002f50:	f000 f9e4 	bl	1000331c <BCCUCH01_SetLinearWalkPrescaler>
                               (HandleColor->LinearWalkPrescaler));
  }

  if(Handle->ChannelWhite != NULL) {
10002f54:	68e0      	ldr	r0, [r4, #12]
10002f56:	2800      	cmp	r0, #0
10002f58:	d006      	beq.n	10002f68 <COLORLAMP01_SetColor+0x56>

    BCCUCH01_SetIntensity((Handle->ChannelWhite), 
10002f5a:	68e9      	ldr	r1, [r5, #12]
10002f5c:	f000 f9d7 	bl	1000330e <BCCUCH01_SetIntensity>
                          (HandleColor->Intensity_White));

    BCCUCH01_SetLinearWalkPrescaler((Handle->ChannelWhite), 
10002f60:	68e0      	ldr	r0, [r4, #12]
10002f62:	69a9      	ldr	r1, [r5, #24]
10002f64:	f000 f9da 	bl	1000331c <BCCUCH01_SetLinearWalkPrescaler>
                               (HandleColor->LinearWalkPrescaler));
  }

  if(Handle->ChannelAmber != NULL) {
10002f68:	6920      	ldr	r0, [r4, #16]
10002f6a:	2800      	cmp	r0, #0
10002f6c:	d006      	beq.n	10002f7c <COLORLAMP01_SetColor+0x6a>

    BCCUCH01_SetIntensity((Handle->ChannelAmber), 
10002f6e:	6929      	ldr	r1, [r5, #16]
10002f70:	f000 f9cd 	bl	1000330e <BCCUCH01_SetIntensity>
                          (HandleColor->Intensity_Amber));

    BCCUCH01_SetLinearWalkPrescaler((Handle->ChannelAmber), 
10002f74:	6920      	ldr	r0, [r4, #16]
10002f76:	69a9      	ldr	r1, [r5, #24]
10002f78:	f000 f9d0 	bl	1000331c <BCCUCH01_SetLinearWalkPrescaler>
                               (HandleColor->LinearWalkPrescaler));
  }

  if(Handle->ChannelFree != NULL) {
10002f7c:	6960      	ldr	r0, [r4, #20]
10002f7e:	2800      	cmp	r0, #0
10002f80:	d006      	beq.n	10002f90 <COLORLAMP01_SetColor+0x7e>

    BCCUCH01_SetIntensity((Handle->ChannelFree), 
10002f82:	6969      	ldr	r1, [r5, #20]
10002f84:	f000 f9c3 	bl	1000330e <BCCUCH01_SetIntensity>
                           (HandleColor->Intensity_Free));

    BCCUCH01_SetLinearWalkPrescaler((Handle->ChannelFree), 
10002f88:	69a9      	ldr	r1, [r5, #24]
10002f8a:	6960      	ldr	r0, [r4, #20]
10002f8c:	f000 f9c6 	bl	1000331c <BCCUCH01_SetLinearWalkPrescaler>
                               (HandleColor->LinearWalkPrescaler));
  }
    
  BCCUCH01_StartLinearWalk(Handle->BCCUGlobal, Handle->ChannelMask);
10002f90:	6a20      	ldr	r0, [r4, #32]
10002f92:	69a1      	ldr	r1, [r4, #24]
10002f94:	f000 f9b0 	bl	100032f8 <BCCUCH01_StartLinearWalk>

}
10002f98:	bd38      	pop	{r3, r4, r5, pc}
	...

10002f9c <CLK002_Init>:
  * @note   -
  * @param  None
  * @retval None
  */
void CLK002_Init(void)
{
10002f9c:	b570      	push	{r4, r5, r6, lr}
    /* Open the lock that protects privileged bits. */
    SCU_GENERAL->PASSWD = CLK002_DIRECT_ACCESS_ALLOW;
10002f9e:	4c31      	ldr	r4, [pc, #196]	; (10003064 <CLK002_Init+0xc8>)
10002fa0:	23c0      	movs	r3, #192	; 0xc0
10002fa2:	6263      	str	r3, [r4, #36]	; 0x24

    /* Loop until protection is removed. */
    while(((SCU_GENERAL->PASSWD)&SCU_GENERAL_PASSWD_PROTS_Msk))
10002fa4:	6a60      	ldr	r0, [r4, #36]	; 0x24
10002fa6:	0740      	lsls	r0, r0, #29
10002fa8:	d4fc      	bmi.n	10002fa4 <CLK002_Init+0x8>
    {
	    ;
    }

    /* Update PCLK selection mux. */
    SCU_CLK->CLKCR|=(((uint32_t)CLK002_CLKCR_PCLKSEL<<\
10002faa:	4b2f      	ldr	r3, [pc, #188]	; (10003068 <CLK002_Init+0xcc>)
10002fac:	2280      	movs	r2, #128	; 0x80
10002fae:	6819      	ldr	r1, [r3, #0]
10002fb0:	0255      	lsls	r5, r2, #9
10002fb2:	430d      	orrs	r5, r1
10002fb4:	601d      	str	r5, [r3, #0]
{
 /*  Find out current and target value of idiv */
 uint32_t lCurrIdiv= (uint32_t) 0;      /* Current idiv. */
 uint32_t lTargetidiv= (uint32_t) 0;    /* Target idiv. */
 uint32_t lCLKCR;
 lCurrIdiv = (((SCU_CLK->CLKCR)&SCU_CLK_CLKCR_IDIV_Msk)>>SCU_CLK_CLKCR_IDIV_Pos);
10002fb6:	681e      	ldr	r6, [r3, #0]
 lTargetidiv = CLK002_CLKCR_IDIV;

 /* Update FDIV here, unconditionally. */

  lCLKCR = SCU_CLK->CLKCR;
10002fb8:	681a      	ldr	r2, [r3, #0]
  WR_REG(lCLKCR, SCU_CLK_CLKCR_FDIV_Msk, SCU_CLK_CLKCR_FDIV_Pos,CLK002_CLKCR_FDIV);
10002fba:	21ff      	movs	r1, #255	; 0xff
10002fbc:	438a      	bics	r2, r1
  SCU_CLK->CLKCR = lCLKCR;
10002fbe:	601a      	str	r2, [r3, #0]

     /* Delay, till frequency stable, appox. 15us. */


  WR_REG(SCU_CLK->CLKCR, SCU_CLK_CLKCR_CNTADJ_Msk, SCU_CLK_CLKCR_CNTADJ_Pos,CLK002_DELAYCNT);
10002fc0:	681d      	ldr	r5, [r3, #0]
10002fc2:	4a2a      	ldr	r2, [pc, #168]	; (1000306c <CLK002_Init+0xd0>)
{
 /*  Find out current and target value of idiv */
 uint32_t lCurrIdiv= (uint32_t) 0;      /* Current idiv. */
 uint32_t lTargetidiv= (uint32_t) 0;    /* Target idiv. */
 uint32_t lCLKCR;
 lCurrIdiv = (((SCU_CLK->CLKCR)&SCU_CLK_CLKCR_IDIV_Msk)>>SCU_CLK_CLKCR_IDIV_Pos);
10002fc4:	0430      	lsls	r0, r6, #16
  SCU_CLK->CLKCR = lCLKCR;

     /* Delay, till frequency stable, appox. 15us. */


  WR_REG(SCU_CLK->CLKCR, SCU_CLK_CLKCR_CNTADJ_Msk, SCU_CLK_CLKCR_CNTADJ_Pos,CLK002_DELAYCNT);
10002fc6:	4315      	orrs	r5, r2
{
 /*  Find out current and target value of idiv */
 uint32_t lCurrIdiv= (uint32_t) 0;      /* Current idiv. */
 uint32_t lTargetidiv= (uint32_t) 0;    /* Target idiv. */
 uint32_t lCLKCR;
 lCurrIdiv = (((SCU_CLK->CLKCR)&SCU_CLK_CLKCR_IDIV_Msk)>>SCU_CLK_CLKCR_IDIV_Pos);
10002fc8:	0e06      	lsrs	r6, r0, #24
  SCU_CLK->CLKCR = lCLKCR;

     /* Delay, till frequency stable, appox. 15us. */


  WR_REG(SCU_CLK->CLKCR, SCU_CLK_CLKCR_CNTADJ_Msk, SCU_CLK_CLKCR_CNTADJ_Pos,CLK002_DELAYCNT);
10002fca:	601d      	str	r5, [r3, #0]
  while (SCU_CLK->CLKCR&(SCU_CLK_CLKCR_VDDC2LOW_Msk))
10002fcc:	6818      	ldr	r0, [r3, #0]
10002fce:	4d26      	ldr	r5, [pc, #152]	; (10003068 <CLK002_Init+0xcc>)
10002fd0:	0040      	lsls	r0, r0, #1
10002fd2:	d4fb      	bmi.n	10002fcc <CLK002_Init+0x30>
    ;
  }


    /* Find out current value of direction in which idiv has to update. */
 if (lCurrIdiv==lTargetidiv)
10002fd4:	2e01      	cmp	r6, #1
10002fd6:	d104      	bne.n	10002fe2 <CLK002_Init+0x46>
	             (uint32_t)SCU_CLK_CLKCR_PCLKSEL_Pos)&SCU_CLK_CLKCR_PCLKSEL_Msk);

    CLK002_lDivUpdate();

    /*Close the lock opened above. */
    SCU_GENERAL->PASSWD = CLK002_DIRECT_ACCESS_DISALLOW;
10002fd8:	23c3      	movs	r3, #195	; 0xc3
10002fda:	6263      	str	r3, [r4, #36]	; 0x24

    /* Update the clock variable */
    SystemCoreClockUpdate();
10002fdc:	f7fe ff18 	bl	10001e10 <SystemCoreClockUpdate>
}
10002fe0:	bd70      	pop	{r4, r5, r6, pc}
10002fe2:	21ff      	movs	r1, #255	; 0xff
10002fe4:	0208      	lsls	r0, r1, #8
static void     CLK002_lFrequencyDownScaling()
{
    uint32_t CurrIdiv;
    uint32_t TargetIdiv;
    uint32_t lCLKCR;
    CurrIdiv = (((SCU_CLK->CLKCR)&SCU_CLK_CLKCR_IDIV_Msk)>>SCU_CLK_CLKCR_IDIV_Pos);
10002fe6:	682d      	ldr	r5, [r5, #0]
10002fe8:	4921      	ldr	r1, [pc, #132]	; (10003070 <CLK002_Init+0xd4>)
    /* Find out current value of direction in which idiv has to update. */
 if (lCurrIdiv==lTargetidiv)
  {
   /*No change in IDIV. */
  }
 else if(lCurrIdiv < lTargetidiv)
10002fea:	2e00      	cmp	r6, #0
10002fec:	d118      	bne.n	10003020 <CLK002_Init+0x84>
    uint32_t lCLKCR;
    CurrIdiv = (((SCU_CLK->CLKCR)&SCU_CLK_CLKCR_IDIV_Msk)>>SCU_CLK_CLKCR_IDIV_Pos);
    TargetIdiv = CLK002_CLKCR_IDIV;
    while(1)
    {
        if((CurrIdiv * 4UL) < TargetIdiv )
10002fee:	4205      	tst	r5, r0
10002ff0:	d109      	bne.n	10003006 <CLK002_Init+0x6a>
        {
            CurrIdiv  = CurrIdiv << 2;   /* Multiply by 4. */
            /* Program interim value of IDIV */
            lCLKCR = SCU_CLK->CLKCR;
10002ff2:	681c      	ldr	r4, [r3, #0]
            WR_REG(lCLKCR, SCU_CLK_CLKCR_IDIV_Msk, SCU_CLK_CLKCR_IDIV_Pos,CurrIdiv);
10002ff4:	400c      	ands	r4, r1
            SCU_CLK->CLKCR = lCLKCR;
10002ff6:	601c      	str	r4, [r3, #0]
            /* Wait till frequency stable. */
            WR_REG(SCU_CLK->CLKCR, SCU_CLK_CLKCR_CNTADJ_Msk, SCU_CLK_CLKCR_CNTADJ_Pos,CLK002_DELAYCNT);
10002ff8:	6818      	ldr	r0, [r3, #0]
10002ffa:	4310      	orrs	r0, r2
10002ffc:	6018      	str	r0, [r3, #0]
            while (SCU_CLK->CLKCR&(SCU_CLK_CLKCR_VDDC2LOW_Msk))
10002ffe:	681d      	ldr	r5, [r3, #0]
10003000:	006c      	lsls	r4, r5, #1
10003002:	d4fc      	bmi.n	10002ffe <CLK002_Init+0x62>
10003004:	e7f5      	b.n	10002ff2 <CLK002_Init+0x56>
            }
        }
        else
        {
            /* Program TargetIDiv into IDIV bitfield of CLKCR */
            lCLKCR = SCU_CLK->CLKCR;
10003006:	6818      	ldr	r0, [r3, #0]
            WR_REG(lCLKCR, SCU_CLK_CLKCR_IDIV_Msk, SCU_CLK_CLKCR_IDIV_Pos,TargetIdiv);
10003008:	2580      	movs	r5, #128	; 0x80
1000300a:	4001      	ands	r1, r0
1000300c:	006e      	lsls	r6, r5, #1
1000300e:	4331      	orrs	r1, r6
            SCU_CLK->CLKCR = lCLKCR;
10003010:	6019      	str	r1, [r3, #0]
            /* Wait till frequency stable. */
           
            WR_REG(SCU_CLK->CLKCR, SCU_CLK_CLKCR_CNTADJ_Msk, SCU_CLK_CLKCR_CNTADJ_Pos,CLK002_DELAYCNT);
10003012:	6819      	ldr	r1, [r3, #0]
10003014:	430a      	orrs	r2, r1
10003016:	601a      	str	r2, [r3, #0]
            while (SCU_CLK->CLKCR&(SCU_CLK_CLKCR_VDDC2LOW_Msk))
10003018:	681a      	ldr	r2, [r3, #0]
1000301a:	0056      	lsls	r6, r2, #1
1000301c:	d4fc      	bmi.n	10003018 <CLK002_Init+0x7c>
1000301e:	e7db      	b.n	10002fd8 <CLK002_Init+0x3c>
static void     CLK002_lFrequencyUpScaling()
{
  uint32_t CurrIdiv;
  uint32_t TargetIdiv;
  uint32_t lCLKCR;
  CurrIdiv = (((SCU_CLK->CLKCR)&SCU_CLK_CLKCR_IDIV_Msk)>>SCU_CLK_CLKCR_IDIV_Pos);
10003020:	4028      	ands	r0, r5
10003022:	0a00      	lsrs	r0, r0, #8
  TargetIdiv = CLK002_CLKCR_IDIV;
  while(1)
  {
    if(CurrIdiv > (TargetIdiv * 4UL))
10003024:	2804      	cmp	r0, #4
10003026:	d910      	bls.n	1000304a <CLK002_Init+0xae>
    {
        CurrIdiv = (CurrIdiv & 0xFFFFFFFCU) + 4U;
10003028:	2603      	movs	r6, #3
1000302a:	43b0      	bics	r0, r6
1000302c:	3004      	adds	r0, #4
        CurrIdiv  = CurrIdiv >> 2;   /* Divide by 4. */
        /* Program interim value of IDIV. */

        lCLKCR = SCU_CLK->CLKCR;
1000302e:	681d      	ldr	r5, [r3, #0]
  while(1)
  {
    if(CurrIdiv > (TargetIdiv * 4UL))
    {
        CurrIdiv = (CurrIdiv & 0xFFFFFFFCU) + 4U;
        CurrIdiv  = CurrIdiv >> 2;   /* Divide by 4. */
10003030:	0880      	lsrs	r0, r0, #2
        /* Program interim value of IDIV. */

        lCLKCR = SCU_CLK->CLKCR;
        WR_REG(lCLKCR, SCU_CLK_CLKCR_IDIV_Msk, SCU_CLK_CLKCR_IDIV_Pos,CurrIdiv);
10003032:	0606      	lsls	r6, r0, #24
10003034:	400d      	ands	r5, r1
10003036:	0c36      	lsrs	r6, r6, #16
10003038:	4335      	orrs	r5, r6
        SCU_CLK->CLKCR = lCLKCR;
1000303a:	601d      	str	r5, [r3, #0]

        /* Wait till frequency stable. */
        WR_REG(SCU_CLK->CLKCR, SCU_CLK_CLKCR_CNTADJ_Msk, SCU_CLK_CLKCR_CNTADJ_Pos,CLK002_DELAYCNT);
1000303c:	681d      	ldr	r5, [r3, #0]
1000303e:	4315      	orrs	r5, r2
10003040:	601d      	str	r5, [r3, #0]
        while (SCU_CLK->CLKCR&(SCU_CLK_CLKCR_VDDC2LOW_Msk))
10003042:	681e      	ldr	r6, [r3, #0]
10003044:	0076      	lsls	r6, r6, #1
10003046:	d4fc      	bmi.n	10003042 <CLK002_Init+0xa6>
10003048:	e7ec      	b.n	10003024 <CLK002_Init+0x88>
        }
    }
    else
    {
        /* Program TargetIDiv into IDIV bitfield of CLKCR. */
        lCLKCR = SCU_CLK->CLKCR;
1000304a:	681e      	ldr	r6, [r3, #0]
        WR_REG(lCLKCR, SCU_CLK_CLKCR_IDIV_Msk, SCU_CLK_CLKCR_IDIV_Pos,TargetIdiv);
1000304c:	2080      	movs	r0, #128	; 0x80
1000304e:	4031      	ands	r1, r6
10003050:	0045      	lsls	r5, r0, #1
10003052:	4329      	orrs	r1, r5
        SCU_CLK->CLKCR = lCLKCR;
10003054:	6019      	str	r1, [r3, #0]
        /* Wait till frequency stable. */
        WR_REG(SCU_CLK->CLKCR, SCU_CLK_CLKCR_CNTADJ_Msk, SCU_CLK_CLKCR_CNTADJ_Pos,CLK002_DELAYCNT);
10003056:	6819      	ldr	r1, [r3, #0]
10003058:	430a      	orrs	r2, r1
1000305a:	601a      	str	r2, [r3, #0]
        while (SCU_CLK->CLKCR&(SCU_CLK_CLKCR_VDDC2LOW_Msk))
1000305c:	681a      	ldr	r2, [r3, #0]
1000305e:	0050      	lsls	r0, r2, #1
10003060:	d4fc      	bmi.n	1000305c <CLK002_Init+0xc0>
10003062:	e7b9      	b.n	10002fd8 <CLK002_Init+0x3c>
10003064:	40010000 	.word	0x40010000
10003068:	40010300 	.word	0x40010300
1000306c:	3ff00000 	.word	0x3ff00000
10003070:	ffff00ff 	.word	0xffff00ff

10003074 <CCU4GLOBAL_Init>:
/**
 * @cond INTERNAL_DOCS
 */

void CCU4GLOBAL_Init(void)
{
10003074:	b570      	push	{r4, r5, r6, lr}
  static uint32_t CCU4InitCalled = (uint32_t)0U;
  uint32_t Count = 0U;
  
  if(CCU4InitCalled == (uint32_t)0U)
10003076:	4c15      	ldr	r4, [pc, #84]	; (100030cc <CCU4GLOBAL_Init+0x58>)
10003078:	6823      	ldr	r3, [r4, #0]
1000307a:	2b00      	cmp	r3, #0
1000307c:	d125      	bne.n	100030ca <CCU4GLOBAL_Init+0x56>
	#if (UC_FAMILY == XMC4)     
		CLK001_Init();     
	#endif		
	
	#if (UC_FAMILY == XMC1)    
		CLK002_Init();
1000307e:	f7ff ff8d 	bl	10002f9c <CLK002_Init>
	#endif
    
    for (Count = 0U; Count<(uint32_t)CCU4GLOBAL_NUM_INSTANCES; Count++)
    {
  	  CCU4Global_lInit(CCU4Global_HandleArray[Count]);
10003082:	4813      	ldr	r0, [pc, #76]	; (100030d0 <CCU4GLOBAL_Init+0x5c>)
10003084:	6802      	ldr	r2, [r0, #0]
  }
}

static void CCU4Global_lInit(const CCU4Global_HandleType * Handle)
{
    if( Handle->KernelNumber <= 2 )
10003086:	6851      	ldr	r1, [r2, #4]
10003088:	2902      	cmp	r1, #2
1000308a:	d816      	bhi.n	100030ba <CCU4GLOBAL_Init+0x46>
	{
		/* Disables the gating for CCU4 kernel */      
		/*This is applicable for XMC4400,XMC4200 and XMC1xxx Devices*/
		#if (UC_FAMILY == XMC1 )
			if (!((uint32_t)SCU_CLK->CGATCLR0 & Handle->ClockGating))
1000308c:	4b11      	ldr	r3, [pc, #68]	; (100030d4 <CCU4GLOBAL_Init+0x60>)
1000308e:	6890      	ldr	r0, [r2, #8]
10003090:	691d      	ldr	r5, [r3, #16]
10003092:	4205      	tst	r5, r0
10003094:	d111      	bne.n	100030ba <CCU4GLOBAL_Init+0x46>
			{ 
				SCU_GENERAL->PASSWD = 0x000000C0UL;
10003096:	4910      	ldr	r1, [pc, #64]	; (100030d8 <CCU4GLOBAL_Init+0x64>)
10003098:	26c0      	movs	r6, #192	; 0xc0
1000309a:	624e      	str	r6, [r1, #36]	; 0x24
				WR_REG(SCU_CLK->CLKCR, SCU_CLK_CLKCR_CNTADJ_Msk, 
1000309c:	681d      	ldr	r5, [r3, #0]
1000309e:	4e0f      	ldr	r6, [pc, #60]	; (100030dc <CCU4GLOBAL_Init+0x68>)
100030a0:	4335      	orrs	r5, r6
100030a2:	601d      	str	r5, [r3, #0]
					   SCU_CLK_CLKCR_CNTADJ_Pos,CCU4GLOBAL_DELAYCNT);
				
				SET_BIT(SCU_CLK->CGATCLR0, Handle->ClockGating);
100030a4:	2601      	movs	r6, #1
100030a6:	691d      	ldr	r5, [r3, #16]
100030a8:	4086      	lsls	r6, r0
100030aa:	1c30      	adds	r0, r6, #0
100030ac:	4328      	orrs	r0, r5
100030ae:	6118      	str	r0, [r3, #16]
				while ((uint32_t)SCU_CLK->CLKCR & 
100030b0:	681d      	ldr	r5, [r3, #0]
100030b2:	006d      	lsls	r5, r5, #1
100030b4:	d4fc      	bmi.n	100030b0 <CCU4GLOBAL_Init+0x3c>
					   (uint32_t)SCU_CLK_CLKCR_VDDC2LOW_Msk)
				{
					;
				}
				SCU_GENERAL->PASSWD = 0x000000C3UL;
100030b6:	23c3      	movs	r3, #195	; 0xc3
100030b8:	624b      	str	r3, [r1, #36]	; 0x24
		RESET001_DeassertReset(Handle->PeripheralReset);
	#endif    

		
    /* Sets Run bit of the Prescalar */
    SET_BIT(Handle->CC4yKernRegsPtr->GIDLC,CCU4_GIDLC_SPRB_Pos);
100030ba:	6816      	ldr	r6, [r2, #0]
100030bc:	2280      	movs	r2, #128	; 0x80
100030be:	68f1      	ldr	r1, [r6, #12]
100030c0:	0050      	lsls	r0, r2, #1
100030c2:	4308      	orrs	r0, r1
    for (Count = 0U; Count<(uint32_t)CCU4GLOBAL_NUM_INSTANCES; Count++)
    {
  	  CCU4Global_lInit(CCU4Global_HandleArray[Count]);
    }

    CCU4InitCalled = (uint32_t)1;
100030c4:	2501      	movs	r5, #1
		RESET001_DeassertReset(Handle->PeripheralReset);
	#endif    

		
    /* Sets Run bit of the Prescalar */
    SET_BIT(Handle->CC4yKernRegsPtr->GIDLC,CCU4_GIDLC_SPRB_Pos);
100030c6:	60f0      	str	r0, [r6, #12]
    for (Count = 0U; Count<(uint32_t)CCU4GLOBAL_NUM_INSTANCES; Count++)
    {
  	  CCU4Global_lInit(CCU4Global_HandleArray[Count]);
    }

    CCU4InitCalled = (uint32_t)1;
100030c8:	6025      	str	r5, [r4, #0]
  }
}
100030ca:	bd70      	pop	{r4, r5, r6, pc}
100030cc:	20000588 	.word	0x20000588
100030d0:	20000684 	.word	0x20000684
100030d4:	40010300 	.word	0x40010300
100030d8:	40010000 	.word	0x40010000
100030dc:	3ff00000 	.word	0x3ff00000

100030e0 <GET_CHANNEL_DIM_MASK>:
*******************************************************************************/


inline uint32_t GET_CHANNEL_DIM_MASK(uint32_t Number)
{
	return ((uint32_t)1 << (uint32_t)Number);
100030e0:	2301      	movs	r3, #1
100030e2:	4083      	lsls	r3, r0
100030e4:	1c18      	adds	r0, r3, #0
}
100030e6:	4770      	bx	lr

100030e8 <BCCUGLOBAL_Init>:
static void BCCUGLOBAL_lGUIInit(const BCCUGlobal_HandleType* Handle)
{
  BCCU_Type* BCCURegs = Handle->BCCURegs;

  /* Open the lock to write protected bits */
  SCU_GENERAL->PASSWD = 0x000000C0UL;
100030e8:	4817      	ldr	r0, [pc, #92]	; (10003148 <BCCUGLOBAL_Init+0x60>)
100030ea:	21c0      	movs	r1, #192	; 0xc0
}


//This function is called by DAVESupport App
void BCCUGLOBAL_Init(void)
{
100030ec:	b530      	push	{r4, r5, lr}
static void BCCUGLOBAL_lGUIInit(const BCCUGlobal_HandleType* Handle)
{
  BCCU_Type* BCCURegs = Handle->BCCURegs;

  /* Open the lock to write protected bits */
  SCU_GENERAL->PASSWD = 0x000000C0UL;
100030ee:	6241      	str	r1, [r0, #36]	; 0x24
  /* Disable the BCCU0 clock gating */
  SET_BIT(SCU_CLK->CGATCLR0, SCU_CLK_CGATCLR0_BCCU0_Pos);
100030f0:	4916      	ldr	r1, [pc, #88]	; (1000314c <BCCUGLOBAL_Init+0x64>)
/*******************************************************************************
**                      Private Function Definitions                          **
*******************************************************************************/
static void BCCUGLOBAL_lGUIInit(const BCCUGlobal_HandleType* Handle)
{
  BCCU_Type* BCCURegs = Handle->BCCURegs;
100030f2:	4b17      	ldr	r3, [pc, #92]	; (10003150 <BCCUGLOBAL_Init+0x68>)

  /* Open the lock to write protected bits */
  SCU_GENERAL->PASSWD = 0x000000C0UL;
  /* Disable the BCCU0 clock gating */
  SET_BIT(SCU_CLK->CGATCLR0, SCU_CLK_CGATCLR0_BCCU0_Pos);
100030f4:	690c      	ldr	r4, [r1, #16]
100030f6:	2510      	movs	r5, #16
100030f8:	432c      	orrs	r4, r5
/*******************************************************************************
**                      Private Function Definitions                          **
*******************************************************************************/
static void BCCUGLOBAL_lGUIInit(const BCCUGlobal_HandleType* Handle)
{
  BCCU_Type* BCCURegs = Handle->BCCURegs;
100030fa:	681a      	ldr	r2, [r3, #0]

  /* Open the lock to write protected bits */
  SCU_GENERAL->PASSWD = 0x000000C0UL;
  /* Disable the BCCU0 clock gating */
  SET_BIT(SCU_CLK->CGATCLR0, SCU_CLK_CGATCLR0_BCCU0_Pos);
100030fc:	610c      	str	r4, [r1, #16]
  /* Wait for VDDC to stabilise */
  while ((uint32_t)SCU_CLK->CLKCR & (uint32_t)SCU_CLK_CLKCR_VDDC2LOW_Msk)
100030fe:	680c      	ldr	r4, [r1, #0]
10003100:	0065      	lsls	r5, r4, #1
10003102:	d4fc      	bmi.n	100030fe <BCCUGLOBAL_Init+0x16>
  {
  	    ;
  }
  /*Close the lock to stop access protected bits */
  SCU_GENERAL->PASSWD = 0x000000C3UL;
10003104:	21c3      	movs	r1, #195	; 0xc3
10003106:	6241      	str	r1, [r0, #36]	; 0x24
  
  /* FCLK, BCLK, DCLK configuration */
  BCCURegs->GLOBCLK = ((Handle->FastClk_PS) | ((uint32_t)(Handle->BitClk_Div) << 
    BCCU_GLOBCLK_BCS_Pos) | ((uint32_t)(Handle->DimClk_PS) << BCCU_GLOBCLK_DCLK_PS_Pos));
10003108:	891c      	ldrh	r4, [r3, #8]
  }
  /*Close the lock to stop access protected bits */
  SCU_GENERAL->PASSWD = 0x000000C3UL;
  
  /* FCLK, BCLK, DCLK configuration */
  BCCURegs->GLOBCLK = ((Handle->FastClk_PS) | ((uint32_t)(Handle->BitClk_Div) << 
1000310a:	7998      	ldrb	r0, [r3, #6]
    BCCU_GLOBCLK_BCS_Pos) | ((uint32_t)(Handle->DimClk_PS) << BCCU_GLOBCLK_DCLK_PS_Pos));
1000310c:	0421      	lsls	r1, r4, #16
  }
  /*Close the lock to stop access protected bits */
  SCU_GENERAL->PASSWD = 0x000000C3UL;
  
  /* FCLK, BCLK, DCLK configuration */
  BCCURegs->GLOBCLK = ((Handle->FastClk_PS) | ((uint32_t)(Handle->BitClk_Div) << 
1000310e:	03c5      	lsls	r5, r0, #15
10003110:	8898      	ldrh	r0, [r3, #4]
10003112:	4329      	orrs	r1, r5
    BCCU_GLOBCLK_BCS_Pos) | ((uint32_t)(Handle->DimClk_PS) << BCCU_GLOBCLK_DCLK_PS_Pos));
10003114:	4301      	orrs	r1, r0
  }
  /*Close the lock to stop access protected bits */
  SCU_GENERAL->PASSWD = 0x000000C3UL;
  
  /* FCLK, BCLK, DCLK configuration */
  BCCURegs->GLOBCLK = ((Handle->FastClk_PS) | ((uint32_t)(Handle->BitClk_Div) << 
10003116:	6051      	str	r1, [r2, #4]
    BCCU_GLOBCLK_BCS_Pos) | ((uint32_t)(Handle->DimClk_PS) << BCCU_GLOBCLK_DCLK_PS_Pos));
  
  /* Trigger & Trap Configuration */
  BCCURegs->GLOBCON |= ((Handle->TriggerMode) | 
10003118:	6815      	ldr	r5, [r2, #0]
1000311a:	7a9c      	ldrb	r4, [r3, #10]
    ((uint32_t)(Handle->TriggerDelay) << BCCU_GLOBCON_TRDEL_Pos) | 
1000311c:	7ad9      	ldrb	r1, [r3, #11]
  /* FCLK, BCLK, DCLK configuration */
  BCCURegs->GLOBCLK = ((Handle->FastClk_PS) | ((uint32_t)(Handle->BitClk_Div) << 
    BCCU_GLOBCLK_BCS_Pos) | ((uint32_t)(Handle->DimClk_PS) << BCCU_GLOBCLK_DCLK_PS_Pos));
  
  /* Trigger & Trap Configuration */
  BCCURegs->GLOBCON |= ((Handle->TriggerMode) | 
1000311e:	4325      	orrs	r5, r4
    ((uint32_t)(Handle->TriggerDelay) << BCCU_GLOBCON_TRDEL_Pos) | 
    ((uint32_t)(Handle->TrapEdge) << BCCU_GLOBCON_TRAPED_Pos));
10003120:	7b9c      	ldrb	r4, [r3, #14]
  BCCURegs->GLOBCLK = ((Handle->FastClk_PS) | ((uint32_t)(Handle->BitClk_Div) << 
    BCCU_GLOBCLK_BCS_Pos) | ((uint32_t)(Handle->DimClk_PS) << BCCU_GLOBCLK_DCLK_PS_Pos));
  
  /* Trigger & Trap Configuration */
  BCCURegs->GLOBCON |= ((Handle->TriggerMode) | 
    ((uint32_t)(Handle->TriggerDelay) << BCCU_GLOBCON_TRDEL_Pos) | 
10003122:	0088      	lsls	r0, r1, #2
10003124:	4305      	orrs	r5, r0
    ((uint32_t)(Handle->TrapEdge) << BCCU_GLOBCON_TRAPED_Pos));
10003126:	02a1      	lsls	r1, r4, #10
  /* FCLK, BCLK, DCLK configuration */
  BCCURegs->GLOBCLK = ((Handle->FastClk_PS) | ((uint32_t)(Handle->BitClk_Div) << 
    BCCU_GLOBCLK_BCS_Pos) | ((uint32_t)(Handle->DimClk_PS) << BCCU_GLOBCLK_DCLK_PS_Pos));
  
  /* Trigger & Trap Configuration */
  BCCURegs->GLOBCON |= ((Handle->TriggerMode) | 
10003128:	430d      	orrs	r5, r1
1000312a:	6015      	str	r5, [r2, #0]
    ((uint32_t)(Handle->TriggerDelay) << BCCU_GLOBCON_TRDEL_Pos) | 
    ((uint32_t)(Handle->TrapEdge) << BCCU_GLOBCON_TRAPED_Pos));

  /* Maximum Off-Bits Allowed at Output */
  WR_REG(BCCURegs->GLOBCON, BCCU_GLOBCON_WDMBN_Msk, BCCU_GLOBCON_WDMBN_Pos, 
1000312c:	899d      	ldrh	r5, [r3, #12]
1000312e:	6814      	ldr	r4, [r2, #0]
10003130:	0428      	lsls	r0, r5, #16
10003132:	4908      	ldr	r1, [pc, #32]	; (10003154 <BCCUGLOBAL_Init+0x6c>)
10003134:	4d08      	ldr	r5, [pc, #32]	; (10003158 <BCCUGLOBAL_Init+0x70>)
10003136:	4008      	ands	r0, r1
10003138:	4025      	ands	r5, r4
    Handle->OutMaxZeroTime);

  /* Interrupt Configuration */
  BCCURegs->EVIER = Handle->EnableEventIntr;
1000313a:	7c9c      	ldrb	r4, [r3, #18]
  
  /* Global Dimming Level Configuration */
  BCCURegs->GLOBDIM = Handle->GlobalDimInitialLevel;
1000313c:	8a1b      	ldrh	r3, [r3, #16]
  BCCURegs->GLOBCON |= ((Handle->TriggerMode) | 
    ((uint32_t)(Handle->TriggerDelay) << BCCU_GLOBCON_TRDEL_Pos) | 
    ((uint32_t)(Handle->TrapEdge) << BCCU_GLOBCON_TRAPED_Pos));

  /* Maximum Off-Bits Allowed at Output */
  WR_REG(BCCURegs->GLOBCON, BCCU_GLOBCON_WDMBN_Msk, BCCU_GLOBCON_WDMBN_Pos, 
1000313e:	4305      	orrs	r5, r0
10003140:	6015      	str	r5, [r2, #0]
    Handle->OutMaxZeroTime);

  /* Interrupt Configuration */
  BCCURegs->EVIER = Handle->EnableEventIntr;
10003142:	62d4      	str	r4, [r2, #44]	; 0x2c
  
  /* Global Dimming Level Configuration */
  BCCURegs->GLOBDIM = Handle->GlobalDimInitialLevel;
10003144:	6293      	str	r3, [r2, #40]	; 0x28

//This function is called by DAVESupport App
void BCCUGLOBAL_Init(void)
{
	BCCUGLOBAL_lGUIInit(&BCCUGlobal_Handle0);
}
10003146:	bd30      	pop	{r4, r5, pc}
10003148:	40010000 	.word	0x40010000
1000314c:	40010300 	.word	0x40010300
10003150:	100044d8 	.word	0x100044d8
10003154:	0fff0000 	.word	0x0fff0000
10003158:	f000ffff 	.word	0xf000ffff

1000315c <BCCUDIM01_lGUIInit>:
/*******************************************************************************
**                      Private Function Definitions                          **
*******************************************************************************/

 void BCCUDIM01_lGUIInit(const BCCUDIM01_HandleType * handle)
{
1000315c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
1000315e:	1c04      	adds	r4, r0, #0
	BCCU_DE_Type * DeRegs = handle->BCCU_DE_Regs;
10003160:	6845      	ldr	r5, [r0, #4]
	BCCU_Type* BCCURegs = handle->BCCURegs;

	/* Select the DimDiv value, Dither function 
                selection and Curve selection */
	DeRegs->DTT |= (
              ((uint32_t)(handle->DitherEnable) << BCCU_DE_DTT_DTEN_Pos) |
10003162:	7c01      	ldrb	r1, [r0, #16]
		((uint32_t)(handle->CurveSel) << BCCU_DE_DTT_CSEL_Pos)
10003164:	7c63      	ldrb	r3, [r4, #17]

	BCCU_Type* BCCURegs = handle->BCCURegs;

	/* Select the DimDiv value, Dither function 
                selection and Curve selection */
	DeRegs->DTT |= (
10003166:	68aa      	ldr	r2, [r5, #8]

 void BCCUDIM01_lGUIInit(const BCCUDIM01_HandleType * handle)
{
	BCCU_DE_Type * DeRegs = handle->BCCU_DE_Regs;

	BCCU_Type* BCCURegs = handle->BCCURegs;
10003168:	6806      	ldr	r6, [r0, #0]

	/* Select the DimDiv value, Dither function 
                selection and Curve selection */
	DeRegs->DTT |= (
              ((uint32_t)(handle->DitherEnable) << BCCU_DE_DTT_DTEN_Pos) |
		((uint32_t)(handle->CurveSel) << BCCU_DE_DTT_CSEL_Pos)
1000316a:	045f      	lsls	r7, r3, #17
	BCCU_Type* BCCURegs = handle->BCCURegs;

	/* Select the DimDiv value, Dither function 
                selection and Curve selection */
	DeRegs->DTT |= (
              ((uint32_t)(handle->DitherEnable) << BCCU_DE_DTT_DTEN_Pos) |
1000316c:	0408      	lsls	r0, r1, #16
1000316e:	4307      	orrs	r7, r0

	BCCU_Type* BCCURegs = handle->BCCURegs;

	/* Select the DimDiv value, Dither function 
                selection and Curve selection */
	DeRegs->DTT |= (
10003170:	4317      	orrs	r7, r2
10003172:	60af      	str	r7, [r5, #8]
              ((uint32_t)(handle->DitherEnable) << BCCU_DE_DTT_DTEN_Pos) |
		((uint32_t)(handle->CurveSel) << BCCU_DE_DTT_CSEL_Pos)
        );

    /* Enable the Dimming Engine */
    if (ENGINE_EN == handle->EnableAtStart)
10003174:	7a62      	ldrb	r2, [r4, #9]
10003176:	2a01      	cmp	r2, #1
10003178:	d105      	bne.n	10003186 <BCCUDIM01_lGUIInit+0x2a>
    {
      BCCURegs->DEEN |= GET_CHANNEL_DIM_MASK(handle->DE_Num);
1000317a:	7a20      	ldrb	r0, [r4, #8]
1000317c:	6a37      	ldr	r7, [r6, #32]
1000317e:	f7ff ffaf 	bl	100030e0 <GET_CHANNEL_DIM_MASK>
10003182:	4307      	orrs	r7, r0
10003184:	6237      	str	r7, [r6, #32]
    }

    /* Initial Dimming Level */
    DeRegs->DLS |= handle->InitialLevel;
10003186:	6829      	ldr	r1, [r5, #0]
10003188:	6960      	ldr	r0, [r4, #20]
1000318a:	4301      	orrs	r1, r0
1000318c:	6029      	str	r1, [r5, #0]

    /* Enable the Shadow Transfer with Initial Dimming Level  */
    BCCURegs->DESTRCON |= GET_CHANNEL_DIM_MASK(handle->DE_Num);
1000318e:	7a20      	ldrb	r0, [r4, #8]
10003190:	6a77      	ldr	r7, [r6, #36]	; 0x24
10003192:	f7ff ffa5 	bl	100030e0 <GET_CHANNEL_DIM_MASK>
10003196:	4307      	orrs	r7, r0
10003198:	6277      	str	r7, [r6, #36]	; 0x24

    /* Configures DIMDIV */
    DeRegs->DTT |= (((uint32_t)(handle->DimDiv) << BCCU_DE_DTT_DIMDIV_Pos));
1000319a:	68ae      	ldr	r6, [r5, #8]
1000319c:	68e4      	ldr	r4, [r4, #12]
1000319e:	4334      	orrs	r4, r6
100031a0:	60ac      	str	r4, [r5, #8]

  }
100031a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

100031a4 <BCCUDIM01_Init>:

/*******************************************************************************
**                      Public Function Definitions                           **
*******************************************************************************/
void BCCUDIM01_Init(void)
{
100031a4:	b508      	push	{r3, lr}
    uint32_t num;
    for (num = 0; num < BCCUDIM01_NUM_INSTANCES; num++)
    {
        BCCUDIM01_lGUIInit(BCCUDIM01_HandleArr[num]);  
100031a6:	4b02      	ldr	r3, [pc, #8]	; (100031b0 <BCCUDIM01_Init+0xc>)
100031a8:	6818      	ldr	r0, [r3, #0]
100031aa:	f7ff ffd7 	bl	1000315c <BCCUDIM01_lGUIInit>
    }        
     
}
100031ae:	bd08      	pop	{r3, pc}
100031b0:	20000688 	.word	0x20000688

100031b4 <BCCUDIM01_StartDimming>:
    handle->BCCURegs->DEEN &= ~EngineMask;
}
inline void BCCUDIM01_StartDimming(const BCCUDIM01_HandleType * handle,
    uint32_t EngineMask)
{
    handle->BCCURegs->DESTRCON |= EngineMask;
100031b4:	6803      	ldr	r3, [r0, #0]
100031b6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
100031b8:	4311      	orrs	r1, r2
100031ba:	6259      	str	r1, [r3, #36]	; 0x24
}
100031bc:	4770      	bx	lr

100031be <BCCUDIM01_AbortDimming>:

inline void BCCUDIM01_AbortDimming(const BCCUDIM01_HandleType * handle,
    uint32_t EngineMask)
{
    handle->BCCURegs->DESTRCON |= (EngineMask << BCCU_DESTRCON_DE0A_Pos);
100031be:	6803      	ldr	r3, [r0, #0]
100031c0:	0409      	lsls	r1, r1, #16
100031c2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
100031c4:	4311      	orrs	r1, r2
100031c6:	6259      	str	r1, [r3, #36]	; 0x24
}
100031c8:	4770      	bx	lr

100031ca <BCCUDIM01_SetDimLvl>:

inline void BCCUDIM01_SetDimLvl(const BCCUDIM01_HandleType * handle,
    uint32_t DimLevel)
{
    WR_REG(handle->BCCU_DE_Regs->DLS, BCCU_DE_DLS_TDLEV_Msk,
100031ca:	6843      	ldr	r3, [r0, #4]
100031cc:	0509      	lsls	r1, r1, #20
100031ce:	681a      	ldr	r2, [r3, #0]
100031d0:	0d08      	lsrs	r0, r1, #20
100031d2:	0b12      	lsrs	r2, r2, #12
100031d4:	0311      	lsls	r1, r2, #12
100031d6:	4308      	orrs	r0, r1
100031d8:	6018      	str	r0, [r3, #0]
        BCCU_DE_DLS_TDLEV_Pos, DimLevel);
}
100031da:	4770      	bx	lr

100031dc <BCCUDIM01_GetDimLvl>:

inline uint32_t BCCUDIM01_GetDimLvl(const BCCUDIM01_HandleType * handle)
{
    return ((uint32_t)(handle->BCCU_DE_Regs->DL) & BCCU_DE_DL_DLEV_Msk);
100031dc:	6843      	ldr	r3, [r0, #4]
100031de:	6858      	ldr	r0, [r3, #4]
100031e0:	0501      	lsls	r1, r0, #20
100031e2:	0d08      	lsrs	r0, r1, #20
}
100031e4:	4770      	bx	lr

100031e6 <BCCUDIM01_SetDimDiv>:
  while (BCCUDIM01_FadeCompletionStatus(handle) == 1);
}

inline void BCCUDIM01_SetDimDiv(const BCCUDIM01_HandleType * handle, uint32_t DimDiv)
{
    WR_REG(handle->BCCU_DE_Regs->DTT, BCCU_DE_DTT_DIMDIV_Msk,
100031e6:	6843      	ldr	r3, [r0, #4]
100031e8:	0589      	lsls	r1, r1, #22
100031ea:	689a      	ldr	r2, [r3, #8]
100031ec:	0d88      	lsrs	r0, r1, #22
100031ee:	0a92      	lsrs	r2, r2, #10
100031f0:	0291      	lsls	r1, r2, #10
100031f2:	4308      	orrs	r0, r1
100031f4:	6098      	str	r0, [r3, #8]
        BCCU_DE_DTT_DIMDIV_Pos, DimDiv);
}
100031f6:	4770      	bx	lr

100031f8 <BCCUDIM01_GetDimDiv>:

inline uint32_t BCCUDIM01_GetDimDiv(const BCCUDIM01_HandleType * handle)
{
    return ((uint32_t)(handle->BCCU_DE_Regs->DTT) & BCCU_DE_DTT_DIMDIV_Msk);
100031f8:	6843      	ldr	r3, [r0, #4]
100031fa:	6898      	ldr	r0, [r3, #8]
100031fc:	0581      	lsls	r1, r0, #22
100031fe:	0d88      	lsrs	r0, r1, #22
}
10003200:	4770      	bx	lr
	...

10003204 <BCCUCH01_Init>:

/*******************************************************************************
**                      Public Function Definitions                           **
*******************************************************************************/
void BCCUCH01_Init(void)
{
10003204:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
10003206:	2700      	movs	r7, #0
  uint32_t i;

  for (i = 0; i < BCCUCH01_NUM_INSTANCES; i++)
  {
      BCCUCH01_lGUIInit(BCCUCH01_HandleArr[i]);
10003208:	4b3a      	ldr	r3, [pc, #232]	; (100032f4 <BCCUCH01_Init+0xf0>)
1000320a:	59dc      	ldr	r4, [r3, r7]
  BCCU_CH_Type * BCCUCh = handle->BCCU_CH;

  /* Channel Output ControlRegister */
  BCCURegs->CHOCON |= (
    /* Channel Output Passive Level */
    ((uint32_t)(handle->OpPassiveLvl) << (handle->ChNum)) |
1000320c:	1c22      	adds	r2, r4, #0
*******************************************************************************/
static void BCCUCH01_lGUIInit(const BCCUCH01_HandleType * handle)
{
  /* Pointer Declaration of type BCCU_Type for accessing BCCU
  * global registers */
  BCCU_Type * BCCURegs = handle->BCCURegs;
1000320e:	6826      	ldr	r6, [r4, #0]
  BCCU_CH_Type * BCCUCh = handle->BCCU_CH;

  /* Channel Output ControlRegister */
  BCCURegs->CHOCON |= (
    /* Channel Output Passive Level */
    ((uint32_t)(handle->OpPassiveLvl) << (handle->ChNum)) |
10003210:	3237      	adds	r2, #55	; 0x37
10003212:	68a0      	ldr	r0, [r4, #8]
10003214:	7813      	ldrb	r3, [r2, #0]
  /* Pointer Declaration of type BCCU_CH_Type for accessing BCCU
  * channel registers */
  BCCU_CH_Type * BCCUCh = handle->BCCU_CH;

  /* Channel Output ControlRegister */
  BCCURegs->CHOCON |= (
10003216:	6931      	ldr	r1, [r6, #16]
    /* Channel Output Passive Level */
    ((uint32_t)(handle->OpPassiveLvl) << (handle->ChNum)) |
10003218:	4083      	lsls	r3, r0
1000321a:	430b      	orrs	r3, r1
    /* Trap enable */
    (((uint32_t)(handle->TrapEnable) << (handle->ChNum))
1000321c:	1c21      	adds	r1, r4, #0
1000321e:	3138      	adds	r1, #56	; 0x38
10003220:	780a      	ldrb	r2, [r1, #0]
  * global registers */
  BCCU_Type * BCCURegs = handle->BCCURegs;

  /* Pointer Declaration of type BCCU_CH_Type for accessing BCCU
  * channel registers */
  BCCU_CH_Type * BCCUCh = handle->BCCU_CH;
10003222:	6865      	ldr	r5, [r4, #4]
  /* Channel Output ControlRegister */
  BCCURegs->CHOCON |= (
    /* Channel Output Passive Level */
    ((uint32_t)(handle->OpPassiveLvl) << (handle->ChNum)) |
    /* Trap enable */
    (((uint32_t)(handle->TrapEnable) << (handle->ChNum))
10003224:	4082      	lsls	r2, r0
        << BCCU_CHOCON_CH0TPE_Pos)
10003226:	0411      	lsls	r1, r2, #16
  /* Pointer Declaration of type BCCU_CH_Type for accessing BCCU
  * channel registers */
  BCCU_CH_Type * BCCUCh = handle->BCCU_CH;

  /* Channel Output ControlRegister */
  BCCURegs->CHOCON |= (
10003228:	430b      	orrs	r3, r1
1000322a:	6133      	str	r3, [r6, #16]
  );

  /* Channel Trigger Register */
  BCCURegs->CHTRIG |= (
      /* Channel Trigger Enable */
      ((uint32_t)(handle->TrigEnable) << (handle->ChNum))
1000322c:	1c23      	adds	r3, r4, #0
1000322e:	3339      	adds	r3, #57	; 0x39
10003230:	7819      	ldrb	r1, [r3, #0]
    (((uint32_t)(handle->TrapEnable) << (handle->ChNum))
        << BCCU_CHOCON_CH0TPE_Pos)
  );

  /* Channel Trigger Register */
  BCCURegs->CHTRIG |= (
10003232:	6972      	ldr	r2, [r6, #20]
      /* Channel Trigger Enable */
      ((uint32_t)(handle->TrigEnable) << (handle->ChNum))
10003234:	4081      	lsls	r1, r0
10003236:	1c08      	adds	r0, r1, #0
    (((uint32_t)(handle->TrapEnable) << (handle->ChNum))
        << BCCU_CHOCON_CH0TPE_Pos)
  );

  /* Channel Trigger Register */
  BCCURegs->CHTRIG |= (
10003238:	4310      	orrs	r0, r2
  );

  /*Channel ConfigurationRegister*/
  BCCUCh->CHCONFIG |= (
    /* forced Trigger enable */
    ((uint32_t)(handle->ForceTrigger) << BCCU_CH_CHCONFIG_ENFT_Pos)|
1000323a:	1c23      	adds	r3, r4, #0
    (((uint32_t)(handle->TrapEnable) << (handle->ChNum))
        << BCCU_CHOCON_CH0TPE_Pos)
  );

  /* Channel Trigger Register */
  BCCURegs->CHTRIG |= (
1000323c:	6170      	str	r0, [r6, #20]
  );

  /*Channel ConfigurationRegister*/
  BCCUCh->CHCONFIG |= (
    /* forced Trigger enable */
    ((uint32_t)(handle->ForceTrigger) << BCCU_CH_CHCONFIG_ENFT_Pos)|
1000323e:	333c      	adds	r3, #60	; 0x3c
10003240:	7819      	ldrb	r1, [r3, #0]
    /* Trigger Edge */
    ((uint32_t)(handle->TrigEdgeSel) << BCCU_CH_CHCONFIG_TRED_Pos) |
10003242:	3b01      	subs	r3, #1
10003244:	781b      	ldrb	r3, [r3, #0]
      /* Channel Trigger Enable */
      ((uint32_t)(handle->TrigEnable) << (handle->ChNum))
  );

  /*Channel ConfigurationRegister*/
  BCCUCh->CHCONFIG |= (
10003246:	68aa      	ldr	r2, [r5, #8]
    /* forced Trigger enable */
    ((uint32_t)(handle->ForceTrigger) << BCCU_CH_CHCONFIG_ENFT_Pos)|
10003248:	02c8      	lsls	r0, r1, #11
    /* Trigger Edge */
    ((uint32_t)(handle->TrigEdgeSel) << BCCU_CH_CHCONFIG_TRED_Pos) |
1000324a:	0299      	lsls	r1, r3, #10
  );

  /*Channel ConfigurationRegister*/
  BCCUCh->CHCONFIG |= (
    /* forced Trigger enable */
    ((uint32_t)(handle->ForceTrigger) << BCCU_CH_CHCONFIG_ENFT_Pos)|
1000324c:	4301      	orrs	r1, r0
    /* Trigger Edge */
    ((uint32_t)(handle->TrigEdgeSel) << BCCU_CH_CHCONFIG_TRED_Pos) |
1000324e:	4311      	orrs	r1, r2
    /* Flicker Watchdog Enable */
    ((uint32_t)(handle->FlickerWDGEnable) << BCCU_CH_CHCONFIG_WEN_Pos) |
10003250:	1c22      	adds	r2, r4, #0
10003252:	3236      	adds	r2, #54	; 0x36
10003254:	7810      	ldrb	r0, [r2, #0]
    /* Gating Enable */
    ((uint32_t)(handle->GateEnable) << BCCU_CH_CHCONFIG_GEN_Pos)|
10003256:	1c22      	adds	r2, r4, #0
10003258:	3235      	adds	r2, #53	; 0x35
    /* forced Trigger enable */
    ((uint32_t)(handle->ForceTrigger) << BCCU_CH_CHCONFIG_ENFT_Pos)|
    /* Trigger Edge */
    ((uint32_t)(handle->TrigEdgeSel) << BCCU_CH_CHCONFIG_TRED_Pos) |
    /* Flicker Watchdog Enable */
    ((uint32_t)(handle->FlickerWDGEnable) << BCCU_CH_CHCONFIG_WEN_Pos) |
1000325a:	0243      	lsls	r3, r0, #9
    /* Gating Enable */
    ((uint32_t)(handle->GateEnable) << BCCU_CH_CHCONFIG_GEN_Pos)|
1000325c:	7810      	ldrb	r0, [r2, #0]
    /* dimming source bypass*/
    ((uint32_t)(handle->DimmingSrcBypass) <<  BCCU_CH_CHCONFIG_DBP_Pos) |
1000325e:	1c22      	adds	r2, r4, #0
10003260:	3234      	adds	r2, #52	; 0x34
    /* forced Trigger enable */
    ((uint32_t)(handle->ForceTrigger) << BCCU_CH_CHCONFIG_ENFT_Pos)|
    /* Trigger Edge */
    ((uint32_t)(handle->TrigEdgeSel) << BCCU_CH_CHCONFIG_TRED_Pos) |
    /* Flicker Watchdog Enable */
    ((uint32_t)(handle->FlickerWDGEnable) << BCCU_CH_CHCONFIG_WEN_Pos) |
10003262:	4319      	orrs	r1, r3
    /* Gating Enable */
    ((uint32_t)(handle->GateEnable) << BCCU_CH_CHCONFIG_GEN_Pos)|
10003264:	0203      	lsls	r3, r0, #8
    /* dimming source bypass*/
    ((uint32_t)(handle->DimmingSrcBypass) <<  BCCU_CH_CHCONFIG_DBP_Pos) |
10003266:	7810      	ldrb	r0, [r2, #0]
    /* Packer Enable */
    ((uint32_t)(handle->PackerEnable) << BCCU_CH_CHCONFIG_PEN_Pos)
10003268:	1c22      	adds	r2, r4, #0
1000326a:	323d      	adds	r2, #61	; 0x3d
    /* Trigger Edge */
    ((uint32_t)(handle->TrigEdgeSel) << BCCU_CH_CHCONFIG_TRED_Pos) |
    /* Flicker Watchdog Enable */
    ((uint32_t)(handle->FlickerWDGEnable) << BCCU_CH_CHCONFIG_WEN_Pos) |
    /* Gating Enable */
    ((uint32_t)(handle->GateEnable) << BCCU_CH_CHCONFIG_GEN_Pos)|
1000326c:	4319      	orrs	r1, r3
    /* dimming source bypass*/
    ((uint32_t)(handle->DimmingSrcBypass) <<  BCCU_CH_CHCONFIG_DBP_Pos) |
1000326e:	01c3      	lsls	r3, r0, #7
    /* Packer Enable */
    ((uint32_t)(handle->PackerEnable) << BCCU_CH_CHCONFIG_PEN_Pos)
10003270:	7810      	ldrb	r0, [r2, #0]
    /* Flicker Watchdog Enable */
    ((uint32_t)(handle->FlickerWDGEnable) << BCCU_CH_CHCONFIG_WEN_Pos) |
    /* Gating Enable */
    ((uint32_t)(handle->GateEnable) << BCCU_CH_CHCONFIG_GEN_Pos)|
    /* dimming source bypass*/
    ((uint32_t)(handle->DimmingSrcBypass) <<  BCCU_CH_CHCONFIG_DBP_Pos) |
10003272:	4319      	orrs	r1, r3
    /* Packer Enable */
    ((uint32_t)(handle->PackerEnable) << BCCU_CH_CHCONFIG_PEN_Pos)
10003274:	00c3      	lsls	r3, r0, #3
      /* Channel Trigger Enable */
      ((uint32_t)(handle->TrigEnable) << (handle->ChNum))
  );

  /*Channel ConfigurationRegister*/
  BCCUCh->CHCONFIG |= (
10003276:	4319      	orrs	r1, r3
10003278:	60a9      	str	r1, [r5, #8]
    /* Packer Enable */
    ((uint32_t)(handle->PackerEnable) << BCCU_CH_CHCONFIG_PEN_Pos)
  );

  /*   Packer Threshold */
  WR_REG_SIZE(BCCUCh->CHCONFIG, BCCU_CH_CHCONFIG_PKTH_Msk,
1000327a:	68a9      	ldr	r1, [r5, #8]
1000327c:	6c20      	ldr	r0, [r4, #64]	; 0x40
1000327e:	2207      	movs	r2, #7
10003280:	4391      	bics	r1, r2
10003282:	4002      	ands	r2, r0
      BCCU_CH_CHCONFIG_PKTH_Pos, handle->PackerThreshold, 32);

  /* Packer Compare Register */
  BCCUCh->PKCMP = (
    /* Packer On-Time Compare Level */
    ((uint32_t)(handle->PackerONCmpLevel) << BCCU_CH_PKCMP_ONCMP_Pos) |
10003284:	6c63      	ldr	r3, [r4, #68]	; 0x44
    /* Packer Enable */
    ((uint32_t)(handle->PackerEnable) << BCCU_CH_CHCONFIG_PEN_Pos)
  );

  /*   Packer Threshold */
  WR_REG_SIZE(BCCUCh->CHCONFIG, BCCU_CH_CHCONFIG_PKTH_Msk,
10003286:	430a      	orrs	r2, r1
10003288:	60aa      	str	r2, [r5, #8]
      BCCU_CH_CHCONFIG_PKTH_Pos, handle->PackerThreshold, 32);

  /* Packer Compare Register */
  BCCUCh->PKCMP = (
    /* Packer On-Time Compare Level */
    ((uint32_t)(handle->PackerONCmpLevel) << BCCU_CH_PKCMP_ONCMP_Pos) |
1000328a:	6ca2      	ldr	r2, [r4, #72]	; 0x48
1000328c:	0419      	lsls	r1, r3, #16
1000328e:	4311      	orrs	r1, r2
  /*   Packer Threshold */
  WR_REG_SIZE(BCCUCh->CHCONFIG, BCCU_CH_CHCONFIG_PKTH_Msk,
      BCCU_CH_CHCONFIG_PKTH_Pos, handle->PackerThreshold, 32);

  /* Packer Compare Register */
  BCCUCh->PKCMP = (
10003290:	60e9      	str	r1, [r5, #12]
    ((uint32_t)(handle->PackerONCmpLevel) << BCCU_CH_PKCMP_ONCMP_Pos) |
    /* Packer Off-Time Compare Level */
    ((uint32_t)(handle->PackerOFFCmpLevel) << BCCU_CH_PKCMP_OFFCMP_Pos)
  );
  /* Packer Counter Register */
  BCCUCh->PKCNTR |= (
10003292:	692b      	ldr	r3, [r5, #16]
    /* On-Time Counter Value */
    ((uint32_t)(handle->PackerONTimeCntrAtInit)
        << BCCU_CH_PKCNTR_ONCNTVAL_Pos) |
10003294:	6d20      	ldr	r0, [r4, #80]	; 0x50
10003296:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
10003298:	4303      	orrs	r3, r0
1000329a:	040a      	lsls	r2, r1, #16
    ((uint32_t)(handle->PackerONCmpLevel) << BCCU_CH_PKCMP_ONCMP_Pos) |
    /* Packer Off-Time Compare Level */
    ((uint32_t)(handle->PackerOFFCmpLevel) << BCCU_CH_PKCMP_OFFCMP_Pos)
  );
  /* Packer Counter Register */
  BCCUCh->PKCNTR |= (
1000329c:	4313      	orrs	r3, r2
1000329e:	612b      	str	r3, [r5, #16]
    /*Off-Time Counter Value */
    ((uint32_t)(handle->PackerOFFTimeCntrAtInit)
        << BCCU_CH_PKCNTR_OFFCNTVAL_Pos)
  );

 if (handle->op_en == 1)
100032a0:	69e3      	ldr	r3, [r4, #28]
100032a2:	2b01      	cmp	r3, #1
100032a4:	d109      	bne.n	100032ba <BCCUCH01_Init+0xb6>
    *((uint32_t *)(handle->IOCR_ptr)) |= 
           (uint32_t)(handle->pad_char 
	             << (handle->IOCR_Val + handle->IOCR_offset));
100032a6:	6a60      	ldr	r0, [r4, #36]	; 0x24
100032a8:	69a1      	ldr	r1, [r4, #24]
    ((uint32_t)(handle->PackerOFFTimeCntrAtInit)
        << BCCU_CH_PKCNTR_OFFCNTVAL_Pos)
  );

 if (handle->op_en == 1)
    *((uint32_t *)(handle->IOCR_ptr)) |= 
100032aa:	68e3      	ldr	r3, [r4, #12]
           (uint32_t)(handle->pad_char 
	             << (handle->IOCR_Val + handle->IOCR_offset));
100032ac:	1842      	adds	r2, r0, r1
        << BCCU_CH_PKCNTR_OFFCNTVAL_Pos)
  );

 if (handle->op_en == 1)
    *((uint32_t *)(handle->IOCR_ptr)) |= 
           (uint32_t)(handle->pad_char 
100032ae:	6a20      	ldr	r0, [r4, #32]
    ((uint32_t)(handle->PackerOFFTimeCntrAtInit)
        << BCCU_CH_PKCNTR_OFFCNTVAL_Pos)
  );

 if (handle->op_en == 1)
    *((uint32_t *)(handle->IOCR_ptr)) |= 
100032b0:	6819      	ldr	r1, [r3, #0]
           (uint32_t)(handle->pad_char 
100032b2:	4090      	lsls	r0, r2
100032b4:	1c02      	adds	r2, r0, #0
    ((uint32_t)(handle->PackerOFFTimeCntrAtInit)
        << BCCU_CH_PKCNTR_OFFCNTVAL_Pos)
  );

 if (handle->op_en == 1)
    *((uint32_t *)(handle->IOCR_ptr)) |= 
100032b6:	430a      	orrs	r2, r1
100032b8:	601a      	str	r2, [r3, #0]
           (uint32_t)(handle->pad_char 
	             << (handle->IOCR_Val + handle->IOCR_offset));
  /* Global Control Register */

  /*Channel Enable*/
  if (BCCUCH01_ENABLE_AT_INIT == handle->EnableAtInit)
100032ba:	1c23      	adds	r3, r4, #0
100032bc:	3328      	adds	r3, #40	; 0x28
100032be:	7819      	ldrb	r1, [r3, #0]
100032c0:	68a0      	ldr	r0, [r4, #8]
100032c2:	2901      	cmp	r1, #1
100032c4:	d103      	bne.n	100032ce <BCCUCH01_Init+0xca>
  {
      BCCURegs->CHEN |=  ((uint32_t)(handle->EnableAtInit) << (handle->ChNum));
100032c6:	68f2      	ldr	r2, [r6, #12]
100032c8:	4081      	lsls	r1, r0
100032ca:	4311      	orrs	r1, r2
100032cc:	60f1      	str	r1, [r6, #12]
  }

  /* Configures Initial Target Intensity */
  BCCUCh->INTS = handle->InitialIntensity;
100032ce:	6b23      	ldr	r3, [r4, #48]	; 0x30
100032d0:	3704      	adds	r7, #4
100032d2:	602b      	str	r3, [r5, #0]

  /* Enable the Shadow Transfer with Initial Channel Intensity */
  BCCURegs->CHSTRCON |= GET_CHANNEL_DIM_MASK(handle->ChNum);
100032d4:	69b1      	ldr	r1, [r6, #24]
100032d6:	9101      	str	r1, [sp, #4]
100032d8:	f7ff ff02 	bl	100030e0 <GET_CHANNEL_DIM_MASK>
100032dc:	9a01      	ldr	r2, [sp, #4]

  /*Channel Configuration Register*/
  BCCUCh->CHCONFIG |= (
    /*Linear Walker Clock Prescaler (LINPRES) */
    ((uint32_t)(handle->LinPres) << BCCU_CH_CHCONFIG_LINPRES_Pos)
100032de:	6ae4      	ldr	r4, [r4, #44]	; 0x2c

  /* Configures Initial Target Intensity */
  BCCUCh->INTS = handle->InitialIntensity;

  /* Enable the Shadow Transfer with Initial Channel Intensity */
  BCCURegs->CHSTRCON |= GET_CHANNEL_DIM_MASK(handle->ChNum);
100032e0:	4310      	orrs	r0, r2
100032e2:	61b0      	str	r0, [r6, #24]

  /*Channel Configuration Register*/
  BCCUCh->CHCONFIG |= (
100032e4:	68ae      	ldr	r6, [r5, #8]
    /*Linear Walker Clock Prescaler (LINPRES) */
    ((uint32_t)(handle->LinPres) << BCCU_CH_CHCONFIG_LINPRES_Pos)
100032e6:	0420      	lsls	r0, r4, #16

  /* Enable the Shadow Transfer with Initial Channel Intensity */
  BCCURegs->CHSTRCON |= GET_CHANNEL_DIM_MASK(handle->ChNum);

  /*Channel Configuration Register*/
  BCCUCh->CHCONFIG |= (
100032e8:	4330      	orrs	r0, r6
100032ea:	60a8      	str	r0, [r5, #8]
*******************************************************************************/
void BCCUCH01_Init(void)
{
  uint32_t i;

  for (i = 0; i < BCCUCH01_NUM_INSTANCES; i++)
100032ec:	2f18      	cmp	r7, #24
100032ee:	d18b      	bne.n	10003208 <BCCUCH01_Init+0x4>
  {
      BCCUCH01_lGUIInit(BCCUCH01_HandleArr[i]);
  }
}
100032f0:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
100032f2:	46c0      	nop			; (mov r8, r8)
100032f4:	2000068c 	.word	0x2000068c

100032f8 <BCCUCH01_StartLinearWalk>:


inline void BCCUCH01_StartLinearWalk(const BCCUGlobal_HandleType* handle,
    uint32_t ChannelMask)
{
  handle->BCCURegs->CHSTRCON |= ChannelMask;
100032f8:	6803      	ldr	r3, [r0, #0]
100032fa:	699a      	ldr	r2, [r3, #24]
100032fc:	4311      	orrs	r1, r2
100032fe:	6199      	str	r1, [r3, #24]
}
10003300:	4770      	bx	lr

10003302 <BCCUCH01_AbortLinearWalk>:


inline void BCCUCH01_AbortLinearWalk(const BCCUGlobal_HandleType* handle,
    uint32_t ChannelMask)
{
  handle->BCCURegs->CHSTRCON |= ((ChannelMask) << BCCU_CHSTRCON_CH0A_Pos);
10003302:	6803      	ldr	r3, [r0, #0]
10003304:	0409      	lsls	r1, r1, #16
10003306:	699a      	ldr	r2, [r3, #24]
10003308:	4311      	orrs	r1, r2
1000330a:	6199      	str	r1, [r3, #24]
}
1000330c:	4770      	bx	lr

1000330e <BCCUCH01_SetIntensity>:
}

inline void BCCUCH01_SetIntensity(const BCCUCH01_HandleType * handle,
    uint32_t Intensity)
{
  handle->BCCU_CH->INTS = Intensity;
1000330e:	6843      	ldr	r3, [r0, #4]
10003310:	6019      	str	r1, [r3, #0]
}
10003312:	4770      	bx	lr

10003314 <BCCUCH01_GetIntensity>:

inline uint32_t BCCUCH01_GetIntensity(const BCCUCH01_HandleType * handle)
{
  return (handle->BCCU_CH->INT);
10003314:	6843      	ldr	r3, [r0, #4]
10003316:	6858      	ldr	r0, [r3, #4]
}
10003318:	4770      	bx	lr
	...

1000331c <BCCUCH01_SetLinearWalkPrescaler>:

inline void BCCUCH01_SetLinearWalkPrescaler(
    const BCCUCH01_HandleType * handle, 
    uint32_t LinearWalkPrescaler)
{
  WR_REG_SIZE(handle->BCCU_CH->CHCONFIG, BCCU_CH_CHCONFIG_LINPRES_Msk,
1000331c:	6843      	ldr	r3, [r0, #4]
1000331e:	4a04      	ldr	r2, [pc, #16]	; (10003330 <BCCUCH01_SetLinearWalkPrescaler+0x14>)
10003320:	0409      	lsls	r1, r1, #16
10003322:	6898      	ldr	r0, [r3, #8]
10003324:	4011      	ands	r1, r2
10003326:	4a03      	ldr	r2, [pc, #12]	; (10003334 <BCCUCH01_SetLinearWalkPrescaler+0x18>)
10003328:	4002      	ands	r2, r0
1000332a:	4311      	orrs	r1, r2
1000332c:	6099      	str	r1, [r3, #8]
      BCCU_CH_CHCONFIG_LINPRES_Pos, LinearWalkPrescaler, 32);
}
1000332e:	4770      	bx	lr
10003330:	03ff0000 	.word	0x03ff0000
10003334:	fc00ffff 	.word	0xfc00ffff

10003338 <ANACMPGLOB01_Init>:
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 */

  void ANACMPGLOB01_Init(void)
  {
10003338:	b510      	push	{r4, lr}
      ANACMPGLOB01_Handle0.ANACMPGlobRegs0Ptr->ANACMP0 = \
      ((ANACMPGLOB01_Handle0.ANACMPGlobRegs0Ptr->ANACMP0 & ~COMPARATOR_ANACMP0_CMP_LPWR_Msk) \
1000333a:	4905      	ldr	r1, [pc, #20]	; (10003350 <ANACMPGLOB01_Init+0x18>)
1000333c:	4b05      	ldr	r3, [pc, #20]	; (10003354 <ANACMPGLOB01_Init+0x1c>)
1000333e:	684a      	ldr	r2, [r1, #4]
 * <b>Sync/Async:  Synchronous</b><BR>
 */

  void ANACMPGLOB01_Init(void)
  {
      ANACMPGLOB01_Handle0.ANACMPGlobRegs0Ptr->ANACMP0 = \
10003340:	7808      	ldrb	r0, [r1, #0]
      ((ANACMPGLOB01_Handle0.ANACMPGlobRegs0Ptr->ANACMP0 & ~COMPARATOR_ANACMP0_CMP_LPWR_Msk) \
10003342:	5ad4      	ldrh	r4, [r2, r3]
 * <b>Sync/Async:  Synchronous</b><BR>
 */

  void ANACMPGLOB01_Init(void)
  {
      ANACMPGLOB01_Handle0.ANACMPGlobRegs0Ptr->ANACMP0 = \
10003344:	4904      	ldr	r1, [pc, #16]	; (10003358 <ANACMPGLOB01_Init+0x20>)
10003346:	0200      	lsls	r0, r0, #8
10003348:	4021      	ands	r1, r4
1000334a:	4301      	orrs	r1, r0
1000334c:	52d1      	strh	r1, [r2, r3]
      ((ANACMPGLOB01_Handle0.ANACMPGlobRegs0Ptr->ANACMP0 & ~COMPARATOR_ANACMP0_CMP_LPWR_Msk) \
     |(ANACMPGLOB01_Handle0.Powermode <<COMPARATOR_ANACMP0_CMP_LPWR_Pos));
  }
1000334e:	bd10      	pop	{r4, pc}
10003350:	100046fc 	.word	0x100046fc
10003354:	00000b5c 	.word	0x00000b5c
10003358:	fffffeff 	.word	0xfffffeff

1000335c <ANACMP01_lInit>:
       * Disable Filter selection
       * Invert the output
       * Selecting the Hysteresis mode selection.
       * */
	  
      if((HandlePtr) == (&ANACMP01_Handle0))
1000335c:	4a30      	ldr	r2, [pc, #192]	; (10003420 <ANACMP01_lInit+0xc4>)
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 */
  void ANACMP01_lInit(const ANACMP01_HandleType* HandlePtr)
  {
1000335e:	b530      	push	{r4, r5, lr}
	  COMPARATOR_Type* ANACMPRegsPtr = HandlePtr->ANACMPSliceRegs0Ptr;
10003360:	6843      	ldr	r3, [r0, #4]
       * Disable Filter selection
       * Invert the output
       * Selecting the Hysteresis mode selection.
       * */
	  
      if((HandlePtr) == (&ANACMP01_Handle0))
10003362:	4290      	cmp	r0, r2
10003364:	d11b      	bne.n	1000339e <ANACMP01_lInit+0x42>
      {	    
	    ANACMPRegsPtr->ANACMP0 = (ANACMPRegsPtr->ANACMP0 & ~COMPARATOR_ANACMP0_CMP_EN_Msk) | HandlePtr->EnableAnaCmp;
10003366:	4a2f      	ldr	r2, [pc, #188]	; (10003424 <ANACMP01_lInit+0xc8>)
10003368:	2501      	movs	r5, #1
1000336a:	5a99      	ldrh	r1, [r3, r2]
1000336c:	7804      	ldrb	r4, [r0, #0]
1000336e:	43a9      	bics	r1, r5
10003370:	4321      	orrs	r1, r4
10003372:	5299      	strh	r1, [r3, r2]
	               
	    ANACMPRegsPtr->ANACMP0 = ((ANACMPRegsPtr->ANACMP0 & ~COMPARATOR_ANACMP0_CMP_FLT_OFF_Msk) \
10003374:	7884      	ldrb	r4, [r0, #2]
10003376:	5a99      	ldrh	r1, [r3, r2]
10003378:	40ac      	lsls	r4, r5
1000337a:	2502      	movs	r5, #2
1000337c:	43a9      	bics	r1, r5
1000337e:	4321      	orrs	r1, r4
10003380:	5299      	strh	r1, [r3, r2]
	                                          | (HandlePtr->DisableFilterAnaCmp<<COMPARATOR_ANACMP0_CMP_FLT_OFF_Pos));
	    ANACMPRegsPtr->ANACMP0 = ((ANACMPRegsPtr->ANACMP0 & ~COMPARATOR_ANACMP0_CMP_INV_OUT_Msk) \
10003382:	5a99      	ldrh	r1, [r3, r2]
10003384:	7844      	ldrb	r4, [r0, #1]
10003386:	2508      	movs	r5, #8
10003388:	00e4      	lsls	r4, r4, #3
1000338a:	43a9      	bics	r1, r5
1000338c:	4321      	orrs	r1, r4
1000338e:	5299      	strh	r1, [r3, r2]
	    		                              | (HandlePtr->InvertOutputAnaCmp<< COMPARATOR_ANACMP0_CMP_INV_OUT_Pos));
	    ANACMPRegsPtr->ANACMP0 = ((ANACMPRegsPtr->ANACMP0 & ~COMPARATOR_ANACMP0_CMP_HYST_ADJ_Msk) \
10003390:	5a99      	ldrh	r1, [r3, r2]
10003392:	78c4      	ldrb	r4, [r0, #3]
10003394:	2530      	movs	r5, #48	; 0x30
10003396:	0124      	lsls	r4, r4, #4
10003398:	43a9      	bics	r1, r5
1000339a:	4321      	orrs	r1, r4
1000339c:	5299      	strh	r1, [r3, r2]
	    						              | (HandlePtr->Hysmodesel << COMPARATOR_ANACMP0_CMP_HYST_ADJ_Pos));
       }
	  
      if((HandlePtr) == (&ANACMP01_Handle1))
1000339e:	4a22      	ldr	r2, [pc, #136]	; (10003428 <ANACMP01_lInit+0xcc>)
100033a0:	4290      	cmp	r0, r2
100033a2:	d11c      	bne.n	100033de <ANACMP01_lInit+0x82>
      {	    
	    ANACMPRegsPtr->ANACMP1 = (ANACMPRegsPtr->ANACMP1 & ~COMPARATOR_ANACMP0_CMP_EN_Msk) | HandlePtr->EnableAnaCmp;
100033a4:	21b6      	movs	r1, #182	; 0xb6
100033a6:	010a      	lsls	r2, r1, #4
100033a8:	5a99      	ldrh	r1, [r3, r2]
100033aa:	2501      	movs	r5, #1
100033ac:	7804      	ldrb	r4, [r0, #0]
100033ae:	43a9      	bics	r1, r5
100033b0:	4321      	orrs	r1, r4
100033b2:	5299      	strh	r1, [r3, r2]
	               
	    ANACMPRegsPtr->ANACMP1 = ((ANACMPRegsPtr->ANACMP1 & ~COMPARATOR_ANACMP0_CMP_FLT_OFF_Msk) \
100033b4:	7884      	ldrb	r4, [r0, #2]
100033b6:	5a99      	ldrh	r1, [r3, r2]
100033b8:	40ac      	lsls	r4, r5
100033ba:	2502      	movs	r5, #2
100033bc:	43a9      	bics	r1, r5
100033be:	4321      	orrs	r1, r4
100033c0:	5299      	strh	r1, [r3, r2]
	                                          | (HandlePtr->DisableFilterAnaCmp<<COMPARATOR_ANACMP0_CMP_FLT_OFF_Pos));
	    ANACMPRegsPtr->ANACMP1 = ((ANACMPRegsPtr->ANACMP1 & ~COMPARATOR_ANACMP0_CMP_INV_OUT_Msk) \
100033c2:	5a99      	ldrh	r1, [r3, r2]
100033c4:	7844      	ldrb	r4, [r0, #1]
100033c6:	2508      	movs	r5, #8
100033c8:	00e4      	lsls	r4, r4, #3
100033ca:	43a9      	bics	r1, r5
100033cc:	4321      	orrs	r1, r4
100033ce:	5299      	strh	r1, [r3, r2]
	    		                              | (HandlePtr->InvertOutputAnaCmp<< COMPARATOR_ANACMP0_CMP_INV_OUT_Pos));
	    ANACMPRegsPtr->ANACMP1 = ((ANACMPRegsPtr->ANACMP1 & ~COMPARATOR_ANACMP0_CMP_HYST_ADJ_Msk) \
100033d0:	5a99      	ldrh	r1, [r3, r2]
100033d2:	78c4      	ldrb	r4, [r0, #3]
100033d4:	2530      	movs	r5, #48	; 0x30
100033d6:	0124      	lsls	r4, r4, #4
100033d8:	43a9      	bics	r1, r5
100033da:	4321      	orrs	r1, r4
100033dc:	5299      	strh	r1, [r3, r2]
	    						              | (HandlePtr->Hysmodesel << COMPARATOR_ANACMP0_CMP_HYST_ADJ_Pos));
       }
	  
      if((HandlePtr) == (&ANACMP01_Handle2))
100033de:	4a13      	ldr	r2, [pc, #76]	; (1000342c <ANACMP01_lInit+0xd0>)
100033e0:	4290      	cmp	r0, r2
100033e2:	d11b      	bne.n	1000341c <ANACMP01_lInit+0xc0>
      {	    
	    ANACMPRegsPtr->ANACMP2 = (ANACMPRegsPtr->ANACMP2 & ~COMPARATOR_ANACMP0_CMP_EN_Msk) | HandlePtr->EnableAnaCmp;
100033e4:	4a12      	ldr	r2, [pc, #72]	; (10003430 <ANACMP01_lInit+0xd4>)
100033e6:	7804      	ldrb	r4, [r0, #0]
100033e8:	5a99      	ldrh	r1, [r3, r2]
100033ea:	2501      	movs	r5, #1
100033ec:	43a9      	bics	r1, r5
100033ee:	4321      	orrs	r1, r4
100033f0:	5299      	strh	r1, [r3, r2]
	               
	    ANACMPRegsPtr->ANACMP2 = ((ANACMPRegsPtr->ANACMP2 & ~COMPARATOR_ANACMP0_CMP_FLT_OFF_Msk) \
100033f2:	7884      	ldrb	r4, [r0, #2]
100033f4:	5a99      	ldrh	r1, [r3, r2]
100033f6:	40ac      	lsls	r4, r5
100033f8:	2502      	movs	r5, #2
100033fa:	43a9      	bics	r1, r5
100033fc:	4321      	orrs	r1, r4
100033fe:	5299      	strh	r1, [r3, r2]
	                                          | (HandlePtr->DisableFilterAnaCmp<<COMPARATOR_ANACMP0_CMP_FLT_OFF_Pos));
	    ANACMPRegsPtr->ANACMP2 = ((ANACMPRegsPtr->ANACMP2 & ~COMPARATOR_ANACMP0_CMP_INV_OUT_Msk) \
10003400:	5a99      	ldrh	r1, [r3, r2]
10003402:	7844      	ldrb	r4, [r0, #1]
10003404:	2508      	movs	r5, #8
10003406:	00e4      	lsls	r4, r4, #3
10003408:	43a9      	bics	r1, r5
1000340a:	4321      	orrs	r1, r4
1000340c:	5299      	strh	r1, [r3, r2]
	    		                              | (HandlePtr->InvertOutputAnaCmp<< COMPARATOR_ANACMP0_CMP_INV_OUT_Pos));
	    ANACMPRegsPtr->ANACMP2 = ((ANACMPRegsPtr->ANACMP2 & ~COMPARATOR_ANACMP0_CMP_HYST_ADJ_Msk) \
1000340e:	5a99      	ldrh	r1, [r3, r2]
10003410:	78c0      	ldrb	r0, [r0, #3]
10003412:	2430      	movs	r4, #48	; 0x30
10003414:	0105      	lsls	r5, r0, #4
10003416:	43a1      	bics	r1, r4
10003418:	4329      	orrs	r1, r5
1000341a:	5299      	strh	r1, [r3, r2]
	    						              | (HandlePtr->Hysmodesel << COMPARATOR_ANACMP0_CMP_HYST_ADJ_Pos));
       }
	  
	  
	  
  }
1000341c:	bd30      	pop	{r4, r5, pc}
1000341e:	46c0      	nop			; (mov r8, r8)
10003420:	10004714 	.word	0x10004714
10003424:	00000b5c 	.word	0x00000b5c
10003428:	1000470c 	.word	0x1000470c
1000342c:	10004704 	.word	0x10004704
10003430:	00000b64 	.word	0x00000b64

10003434 <ANACMP01_Init>:
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 */
  void ANACMP01_Init(void)
  {
10003434:	b508      	push	{r3, lr}
     /* Call the local function with the handle pointer for each instance */
     ANACMP01_lInit(&ANACMP01_Handle0);
10003436:	4805      	ldr	r0, [pc, #20]	; (1000344c <ANACMP01_Init+0x18>)
10003438:	f7ff ff90 	bl	1000335c <ANACMP01_lInit>
     /* Call the local function with the handle pointer for each instance */
     ANACMP01_lInit(&ANACMP01_Handle1);
1000343c:	4804      	ldr	r0, [pc, #16]	; (10003450 <ANACMP01_Init+0x1c>)
1000343e:	f7ff ff8d 	bl	1000335c <ANACMP01_lInit>
     /* Call the local function with the handle pointer for each instance */
     ANACMP01_lInit(&ANACMP01_Handle2);
10003442:	4804      	ldr	r0, [pc, #16]	; (10003454 <ANACMP01_Init+0x20>)
10003444:	f7ff ff8a 	bl	1000335c <ANACMP01_lInit>
           
  }
10003448:	bd08      	pop	{r3, pc}
1000344a:	46c0      	nop			; (mov r8, r8)
1000344c:	10004714 	.word	0x10004714
10003450:	1000470c 	.word	0x1000470c
10003454:	10004704 	.word	0x10004704

10003458 <__aeabi_uidiv>:
10003458:	2900      	cmp	r1, #0
1000345a:	d034      	beq.n	100034c6 <.udivsi3_skip_div0_test+0x6a>

1000345c <.udivsi3_skip_div0_test>:
1000345c:	2301      	movs	r3, #1
1000345e:	2200      	movs	r2, #0
10003460:	b410      	push	{r4}
10003462:	4288      	cmp	r0, r1
10003464:	d32c      	bcc.n	100034c0 <.udivsi3_skip_div0_test+0x64>
10003466:	2401      	movs	r4, #1
10003468:	0724      	lsls	r4, r4, #28
1000346a:	42a1      	cmp	r1, r4
1000346c:	d204      	bcs.n	10003478 <.udivsi3_skip_div0_test+0x1c>
1000346e:	4281      	cmp	r1, r0
10003470:	d202      	bcs.n	10003478 <.udivsi3_skip_div0_test+0x1c>
10003472:	0109      	lsls	r1, r1, #4
10003474:	011b      	lsls	r3, r3, #4
10003476:	e7f8      	b.n	1000346a <.udivsi3_skip_div0_test+0xe>
10003478:	00e4      	lsls	r4, r4, #3
1000347a:	42a1      	cmp	r1, r4
1000347c:	d204      	bcs.n	10003488 <.udivsi3_skip_div0_test+0x2c>
1000347e:	4281      	cmp	r1, r0
10003480:	d202      	bcs.n	10003488 <.udivsi3_skip_div0_test+0x2c>
10003482:	0049      	lsls	r1, r1, #1
10003484:	005b      	lsls	r3, r3, #1
10003486:	e7f8      	b.n	1000347a <.udivsi3_skip_div0_test+0x1e>
10003488:	4288      	cmp	r0, r1
1000348a:	d301      	bcc.n	10003490 <.udivsi3_skip_div0_test+0x34>
1000348c:	1a40      	subs	r0, r0, r1
1000348e:	431a      	orrs	r2, r3
10003490:	084c      	lsrs	r4, r1, #1
10003492:	42a0      	cmp	r0, r4
10003494:	d302      	bcc.n	1000349c <.udivsi3_skip_div0_test+0x40>
10003496:	1b00      	subs	r0, r0, r4
10003498:	085c      	lsrs	r4, r3, #1
1000349a:	4322      	orrs	r2, r4
1000349c:	088c      	lsrs	r4, r1, #2
1000349e:	42a0      	cmp	r0, r4
100034a0:	d302      	bcc.n	100034a8 <.udivsi3_skip_div0_test+0x4c>
100034a2:	1b00      	subs	r0, r0, r4
100034a4:	089c      	lsrs	r4, r3, #2
100034a6:	4322      	orrs	r2, r4
100034a8:	08cc      	lsrs	r4, r1, #3
100034aa:	42a0      	cmp	r0, r4
100034ac:	d302      	bcc.n	100034b4 <.udivsi3_skip_div0_test+0x58>
100034ae:	1b00      	subs	r0, r0, r4
100034b0:	08dc      	lsrs	r4, r3, #3
100034b2:	4322      	orrs	r2, r4
100034b4:	2800      	cmp	r0, #0
100034b6:	d003      	beq.n	100034c0 <.udivsi3_skip_div0_test+0x64>
100034b8:	091b      	lsrs	r3, r3, #4
100034ba:	d001      	beq.n	100034c0 <.udivsi3_skip_div0_test+0x64>
100034bc:	0909      	lsrs	r1, r1, #4
100034be:	e7e3      	b.n	10003488 <.udivsi3_skip_div0_test+0x2c>
100034c0:	1c10      	adds	r0, r2, #0
100034c2:	bc10      	pop	{r4}
100034c4:	4770      	bx	lr
100034c6:	2800      	cmp	r0, #0
100034c8:	d001      	beq.n	100034ce <.udivsi3_skip_div0_test+0x72>
100034ca:	2000      	movs	r0, #0
100034cc:	43c0      	mvns	r0, r0
100034ce:	b407      	push	{r0, r1, r2}
100034d0:	4802      	ldr	r0, [pc, #8]	; (100034dc <.udivsi3_skip_div0_test+0x80>)
100034d2:	a102      	add	r1, pc, #8	; (adr r1, 100034dc <.udivsi3_skip_div0_test+0x80>)
100034d4:	1840      	adds	r0, r0, r1
100034d6:	9002      	str	r0, [sp, #8]
100034d8:	bd03      	pop	{r0, r1, pc}
100034da:	46c0      	nop			; (mov r8, r8)
100034dc:	00000019 	.word	0x00000019

100034e0 <__aeabi_uidivmod>:
100034e0:	2900      	cmp	r1, #0
100034e2:	d0f0      	beq.n	100034c6 <.udivsi3_skip_div0_test+0x6a>
100034e4:	b503      	push	{r0, r1, lr}
100034e6:	f7ff ffb9 	bl	1000345c <.udivsi3_skip_div0_test>
100034ea:	bc0e      	pop	{r1, r2, r3}
100034ec:	4342      	muls	r2, r0
100034ee:	1a89      	subs	r1, r1, r2
100034f0:	4718      	bx	r3
100034f2:	46c0      	nop			; (mov r8, r8)

100034f4 <__aeabi_idiv0>:
100034f4:	4770      	bx	lr
100034f6:	46c0      	nop			; (mov r8, r8)

100034f8 <__aeabi_cfrcmple>:
100034f8:	4684      	mov	ip, r0
100034fa:	1c08      	adds	r0, r1, #0
100034fc:	4661      	mov	r1, ip
100034fe:	e7ff      	b.n	10003500 <__aeabi_cfcmpeq>

10003500 <__aeabi_cfcmpeq>:
10003500:	b51f      	push	{r0, r1, r2, r3, r4, lr}
10003502:	f000 f9f5 	bl	100038f0 <__lesf2>
10003506:	2800      	cmp	r0, #0
10003508:	d401      	bmi.n	1000350e <__aeabi_cfcmpeq+0xe>
1000350a:	2100      	movs	r1, #0
1000350c:	42c8      	cmn	r0, r1
1000350e:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

10003510 <__aeabi_fcmpeq>:
10003510:	b510      	push	{r4, lr}
10003512:	f000 f97d 	bl	10003810 <__eqsf2>
10003516:	4240      	negs	r0, r0
10003518:	3001      	adds	r0, #1
1000351a:	bd10      	pop	{r4, pc}

1000351c <__aeabi_fcmplt>:
1000351c:	b510      	push	{r4, lr}
1000351e:	f000 f9e7 	bl	100038f0 <__lesf2>
10003522:	2800      	cmp	r0, #0
10003524:	db01      	blt.n	1000352a <__aeabi_fcmplt+0xe>
10003526:	2000      	movs	r0, #0
10003528:	bd10      	pop	{r4, pc}
1000352a:	2001      	movs	r0, #1
1000352c:	bd10      	pop	{r4, pc}
1000352e:	46c0      	nop			; (mov r8, r8)

10003530 <__aeabi_fcmple>:
10003530:	b510      	push	{r4, lr}
10003532:	f000 f9dd 	bl	100038f0 <__lesf2>
10003536:	2800      	cmp	r0, #0
10003538:	dd01      	ble.n	1000353e <__aeabi_fcmple+0xe>
1000353a:	2000      	movs	r0, #0
1000353c:	bd10      	pop	{r4, pc}
1000353e:	2001      	movs	r0, #1
10003540:	bd10      	pop	{r4, pc}
10003542:	46c0      	nop			; (mov r8, r8)

10003544 <__aeabi_fcmpgt>:
10003544:	b510      	push	{r4, lr}
10003546:	f000 f98b 	bl	10003860 <__gesf2>
1000354a:	2800      	cmp	r0, #0
1000354c:	dc01      	bgt.n	10003552 <__aeabi_fcmpgt+0xe>
1000354e:	2000      	movs	r0, #0
10003550:	bd10      	pop	{r4, pc}
10003552:	2001      	movs	r0, #1
10003554:	bd10      	pop	{r4, pc}
10003556:	46c0      	nop			; (mov r8, r8)

10003558 <__aeabi_fcmpge>:
10003558:	b510      	push	{r4, lr}
1000355a:	f000 f981 	bl	10003860 <__gesf2>
1000355e:	2800      	cmp	r0, #0
10003560:	da01      	bge.n	10003566 <__aeabi_fcmpge+0xe>
10003562:	2000      	movs	r0, #0
10003564:	bd10      	pop	{r4, pc}
10003566:	2001      	movs	r0, #1
10003568:	bd10      	pop	{r4, pc}
1000356a:	46c0      	nop			; (mov r8, r8)

1000356c <__aeabi_f2uiz>:
1000356c:	219e      	movs	r1, #158	; 0x9e
1000356e:	b510      	push	{r4, lr}
10003570:	05c9      	lsls	r1, r1, #23
10003572:	1c04      	adds	r4, r0, #0
10003574:	f7ff fff0 	bl	10003558 <__aeabi_fcmpge>
10003578:	2800      	cmp	r0, #0
1000357a:	d103      	bne.n	10003584 <__aeabi_f2uiz+0x18>
1000357c:	1c20      	adds	r0, r4, #0
1000357e:	f000 fd09 	bl	10003f94 <__aeabi_f2iz>
10003582:	bd10      	pop	{r4, pc}
10003584:	229e      	movs	r2, #158	; 0x9e
10003586:	1c20      	adds	r0, r4, #0
10003588:	05d1      	lsls	r1, r2, #23
1000358a:	f000 fb29 	bl	10003be0 <__aeabi_fsub>
1000358e:	f000 fd01 	bl	10003f94 <__aeabi_f2iz>
10003592:	2380      	movs	r3, #128	; 0x80
10003594:	061c      	lsls	r4, r3, #24
10003596:	1900      	adds	r0, r0, r4
10003598:	e7f3      	b.n	10003582 <__aeabi_f2uiz+0x16>
1000359a:	46c0      	nop			; (mov r8, r8)

1000359c <__aeabi_fdiv>:
1000359c:	b5f0      	push	{r4, r5, r6, r7, lr}
1000359e:	465f      	mov	r7, fp
100035a0:	4656      	mov	r6, sl
100035a2:	464d      	mov	r5, r9
100035a4:	4644      	mov	r4, r8
100035a6:	b4f0      	push	{r4, r5, r6, r7}
100035a8:	0245      	lsls	r5, r0, #9
100035aa:	0044      	lsls	r4, r0, #1
100035ac:	b083      	sub	sp, #12
100035ae:	1c0e      	adds	r6, r1, #0
100035b0:	0a6d      	lsrs	r5, r5, #9
100035b2:	0e24      	lsrs	r4, r4, #24
100035b4:	0fc7      	lsrs	r7, r0, #31
100035b6:	2c00      	cmp	r4, #0
100035b8:	d107      	bne.n	100035ca <__aeabi_fdiv+0x2e>
100035ba:	2d00      	cmp	r5, #0
100035bc:	d000      	beq.n	100035c0 <__aeabi_fdiv+0x24>
100035be:	e091      	b.n	100036e4 <__aeabi_fdiv+0x148>
100035c0:	2104      	movs	r1, #4
100035c2:	2201      	movs	r2, #1
100035c4:	4688      	mov	r8, r1
100035c6:	4692      	mov	sl, r2
100035c8:	e009      	b.n	100035de <__aeabi_fdiv+0x42>
100035ca:	2cff      	cmp	r4, #255	; 0xff
100035cc:	d055      	beq.n	1000367a <__aeabi_fdiv+0xde>
100035ce:	2380      	movs	r3, #128	; 0x80
100035d0:	0418      	lsls	r0, r3, #16
100035d2:	2100      	movs	r1, #0
100035d4:	4305      	orrs	r5, r0
100035d6:	00ed      	lsls	r5, r5, #3
100035d8:	3c7f      	subs	r4, #127	; 0x7f
100035da:	4688      	mov	r8, r1
100035dc:	468a      	mov	sl, r1
100035de:	1c33      	adds	r3, r6, #0
100035e0:	0058      	lsls	r0, r3, #1
100035e2:	0276      	lsls	r6, r6, #9
100035e4:	0fd9      	lsrs	r1, r3, #31
100035e6:	0a76      	lsrs	r6, r6, #9
100035e8:	0e00      	lsrs	r0, r0, #24
100035ea:	468b      	mov	fp, r1
100035ec:	d14c      	bne.n	10003688 <__aeabi_fdiv+0xec>
100035ee:	2201      	movs	r2, #1
100035f0:	4694      	mov	ip, r2
100035f2:	2e00      	cmp	r6, #0
100035f4:	d000      	beq.n	100035f8 <__aeabi_fdiv+0x5c>
100035f6:	e081      	b.n	100036fc <__aeabi_fdiv+0x160>
100035f8:	465b      	mov	r3, fp
100035fa:	407b      	eors	r3, r7
100035fc:	4662      	mov	r2, ip
100035fe:	4641      	mov	r1, r8
10003600:	9301      	str	r3, [sp, #4]
10003602:	430a      	orrs	r2, r1
10003604:	2a0f      	cmp	r2, #15
10003606:	d950      	bls.n	100036aa <__aeabi_fdiv+0x10e>
10003608:	1a20      	subs	r0, r4, r0
1000360a:	0169      	lsls	r1, r5, #5
1000360c:	4681      	mov	r9, r0
1000360e:	0175      	lsls	r5, r6, #5
10003610:	42a9      	cmp	r1, r5
10003612:	d300      	bcc.n	10003616 <__aeabi_fdiv+0x7a>
10003614:	e0b3      	b.n	1000377e <__aeabi_fdiv+0x1e2>
10003616:	2201      	movs	r2, #1
10003618:	4253      	negs	r3, r2
1000361a:	4499      	add	r9, r3
1000361c:	241b      	movs	r4, #27
1000361e:	2600      	movs	r6, #0
10003620:	2701      	movs	r7, #1
10003622:	1e62      	subs	r2, r4, #1
10003624:	1c38      	adds	r0, r7, #0
10003626:	4010      	ands	r0, r2
10003628:	004b      	lsls	r3, r1, #1
1000362a:	0076      	lsls	r6, r6, #1
1000362c:	2900      	cmp	r1, #0
1000362e:	da00      	bge.n	10003632 <__aeabi_fdiv+0x96>
10003630:	e0a9      	b.n	10003786 <__aeabi_fdiv+0x1ea>
10003632:	429d      	cmp	r5, r3
10003634:	d800      	bhi.n	10003638 <__aeabi_fdiv+0x9c>
10003636:	e0a6      	b.n	10003786 <__aeabi_fdiv+0x1ea>
10003638:	3c01      	subs	r4, #1
1000363a:	2c00      	cmp	r4, #0
1000363c:	dc00      	bgt.n	10003640 <__aeabi_fdiv+0xa4>
1000363e:	e0ab      	b.n	10003798 <__aeabi_fdiv+0x1fc>
10003640:	2800      	cmp	r0, #0
10003642:	d00c      	beq.n	1000365e <__aeabi_fdiv+0xc2>
10003644:	1c19      	adds	r1, r3, #0
10003646:	0076      	lsls	r6, r6, #1
10003648:	005b      	lsls	r3, r3, #1
1000364a:	2900      	cmp	r1, #0
1000364c:	db01      	blt.n	10003652 <__aeabi_fdiv+0xb6>
1000364e:	429d      	cmp	r5, r3
10003650:	d801      	bhi.n	10003656 <__aeabi_fdiv+0xba>
10003652:	1b5b      	subs	r3, r3, r5
10003654:	433e      	orrs	r6, r7
10003656:	3c01      	subs	r4, #1
10003658:	2c00      	cmp	r4, #0
1000365a:	dc00      	bgt.n	1000365e <__aeabi_fdiv+0xc2>
1000365c:	e09c      	b.n	10003798 <__aeabi_fdiv+0x1fc>
1000365e:	0059      	lsls	r1, r3, #1
10003660:	0072      	lsls	r2, r6, #1
10003662:	2b00      	cmp	r3, #0
10003664:	db01      	blt.n	1000366a <__aeabi_fdiv+0xce>
10003666:	428d      	cmp	r5, r1
10003668:	d801      	bhi.n	1000366e <__aeabi_fdiv+0xd2>
1000366a:	1b49      	subs	r1, r1, r5
1000366c:	433a      	orrs	r2, r7
1000366e:	3c01      	subs	r4, #1
10003670:	004b      	lsls	r3, r1, #1
10003672:	0056      	lsls	r6, r2, #1
10003674:	2900      	cmp	r1, #0
10003676:	daea      	bge.n	1000364e <__aeabi_fdiv+0xb2>
10003678:	e7eb      	b.n	10003652 <__aeabi_fdiv+0xb6>
1000367a:	2d00      	cmp	r5, #0
1000367c:	d12d      	bne.n	100036da <__aeabi_fdiv+0x13e>
1000367e:	2008      	movs	r0, #8
10003680:	2102      	movs	r1, #2
10003682:	4680      	mov	r8, r0
10003684:	468a      	mov	sl, r1
10003686:	e7aa      	b.n	100035de <__aeabi_fdiv+0x42>
10003688:	28ff      	cmp	r0, #255	; 0xff
1000368a:	d020      	beq.n	100036ce <__aeabi_fdiv+0x132>
1000368c:	2280      	movs	r2, #128	; 0x80
1000368e:	0413      	lsls	r3, r2, #16
10003690:	2100      	movs	r1, #0
10003692:	431e      	orrs	r6, r3
10003694:	468c      	mov	ip, r1
10003696:	465b      	mov	r3, fp
10003698:	407b      	eors	r3, r7
1000369a:	4662      	mov	r2, ip
1000369c:	4641      	mov	r1, r8
1000369e:	00f6      	lsls	r6, r6, #3
100036a0:	387f      	subs	r0, #127	; 0x7f
100036a2:	9301      	str	r3, [sp, #4]
100036a4:	430a      	orrs	r2, r1
100036a6:	2a0f      	cmp	r2, #15
100036a8:	d8ae      	bhi.n	10003608 <__aeabi_fdiv+0x6c>
100036aa:	4956      	ldr	r1, [pc, #344]	; (10003804 <__aeabi_fdiv+0x268>)
100036ac:	0092      	lsls	r2, r2, #2
100036ae:	588a      	ldr	r2, [r1, r2]
100036b0:	4697      	mov	pc, r2
100036b2:	9b01      	ldr	r3, [sp, #4]
100036b4:	26ff      	movs	r6, #255	; 0xff
100036b6:	2500      	movs	r5, #0
100036b8:	05f0      	lsls	r0, r6, #23
100036ba:	4328      	orrs	r0, r5
100036bc:	07de      	lsls	r6, r3, #31
100036be:	4330      	orrs	r0, r6
100036c0:	b003      	add	sp, #12
100036c2:	bc3c      	pop	{r2, r3, r4, r5}
100036c4:	4690      	mov	r8, r2
100036c6:	4699      	mov	r9, r3
100036c8:	46a2      	mov	sl, r4
100036ca:	46ab      	mov	fp, r5
100036cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
100036ce:	1c33      	adds	r3, r6, #0
100036d0:	1e5a      	subs	r2, r3, #1
100036d2:	4193      	sbcs	r3, r2
100036d4:	3302      	adds	r3, #2
100036d6:	469c      	mov	ip, r3
100036d8:	e78e      	b.n	100035f8 <__aeabi_fdiv+0x5c>
100036da:	220c      	movs	r2, #12
100036dc:	2303      	movs	r3, #3
100036de:	4690      	mov	r8, r2
100036e0:	469a      	mov	sl, r3
100036e2:	e77c      	b.n	100035de <__aeabi_fdiv+0x42>
100036e4:	1c28      	adds	r0, r5, #0
100036e6:	f000 fcc9 	bl	1000407c <__clzsi2>
100036ea:	2276      	movs	r2, #118	; 0x76
100036ec:	1f44      	subs	r4, r0, #5
100036ee:	4253      	negs	r3, r2
100036f0:	40a5      	lsls	r5, r4
100036f2:	1a1c      	subs	r4, r3, r0
100036f4:	2000      	movs	r0, #0
100036f6:	4680      	mov	r8, r0
100036f8:	4682      	mov	sl, r0
100036fa:	e770      	b.n	100035de <__aeabi_fdiv+0x42>
100036fc:	1c30      	adds	r0, r6, #0
100036fe:	f000 fcbd 	bl	1000407c <__clzsi2>
10003702:	2376      	movs	r3, #118	; 0x76
10003704:	1f41      	subs	r1, r0, #5
10003706:	408e      	lsls	r6, r1
10003708:	425a      	negs	r2, r3
1000370a:	2100      	movs	r1, #0
1000370c:	1a10      	subs	r0, r2, r0
1000370e:	468c      	mov	ip, r1
10003710:	e772      	b.n	100035f8 <__aeabi_fdiv+0x5c>
10003712:	2300      	movs	r3, #0
10003714:	4d3c      	ldr	r5, [pc, #240]	; (10003808 <__aeabi_fdiv+0x26c>)
10003716:	26ff      	movs	r6, #255	; 0xff
10003718:	e7ce      	b.n	100036b8 <__aeabi_fdiv+0x11c>
1000371a:	465f      	mov	r7, fp
1000371c:	1c35      	adds	r5, r6, #0
1000371e:	9701      	str	r7, [sp, #4]
10003720:	4663      	mov	r3, ip
10003722:	2b02      	cmp	r3, #2
10003724:	d0c5      	beq.n	100036b2 <__aeabi_fdiv+0x116>
10003726:	2b03      	cmp	r3, #3
10003728:	d063      	beq.n	100037f2 <__aeabi_fdiv+0x256>
1000372a:	2b01      	cmp	r3, #1
1000372c:	d043      	beq.n	100037b6 <__aeabi_fdiv+0x21a>
1000372e:	4649      	mov	r1, r9
10003730:	317f      	adds	r1, #127	; 0x7f
10003732:	2900      	cmp	r1, #0
10003734:	dd35      	ble.n	100037a2 <__aeabi_fdiv+0x206>
10003736:	270f      	movs	r7, #15
10003738:	402f      	ands	r7, r5
1000373a:	2f04      	cmp	r7, #4
1000373c:	d000      	beq.n	10003740 <__aeabi_fdiv+0x1a4>
1000373e:	3504      	adds	r5, #4
10003740:	012b      	lsls	r3, r5, #4
10003742:	d503      	bpl.n	1000374c <__aeabi_fdiv+0x1b0>
10003744:	4a31      	ldr	r2, [pc, #196]	; (1000380c <__aeabi_fdiv+0x270>)
10003746:	4649      	mov	r1, r9
10003748:	4015      	ands	r5, r2
1000374a:	3180      	adds	r1, #128	; 0x80
1000374c:	29fe      	cmp	r1, #254	; 0xfe
1000374e:	dcb0      	bgt.n	100036b2 <__aeabi_fdiv+0x116>
10003750:	01a8      	lsls	r0, r5, #6
10003752:	0a45      	lsrs	r5, r0, #9
10003754:	b2ce      	uxtb	r6, r1
10003756:	9b01      	ldr	r3, [sp, #4]
10003758:	e7ae      	b.n	100036b8 <__aeabi_fdiv+0x11c>
1000375a:	2600      	movs	r6, #0
1000375c:	2500      	movs	r5, #0
1000375e:	e7ab      	b.n	100036b8 <__aeabi_fdiv+0x11c>
10003760:	2080      	movs	r0, #128	; 0x80
10003762:	03c1      	lsls	r1, r0, #15
10003764:	420d      	tst	r5, r1
10003766:	d011      	beq.n	1000378c <__aeabi_fdiv+0x1f0>
10003768:	420e      	tst	r6, r1
1000376a:	d10f      	bne.n	1000378c <__aeabi_fdiv+0x1f0>
1000376c:	430e      	orrs	r6, r1
1000376e:	0273      	lsls	r3, r6, #9
10003770:	0a5d      	lsrs	r5, r3, #9
10003772:	26ff      	movs	r6, #255	; 0xff
10003774:	465b      	mov	r3, fp
10003776:	e79f      	b.n	100036b8 <__aeabi_fdiv+0x11c>
10003778:	9701      	str	r7, [sp, #4]
1000377a:	4653      	mov	r3, sl
1000377c:	e7d1      	b.n	10003722 <__aeabi_fdiv+0x186>
1000377e:	1b49      	subs	r1, r1, r5
10003780:	241a      	movs	r4, #26
10003782:	2601      	movs	r6, #1
10003784:	e74c      	b.n	10003620 <__aeabi_fdiv+0x84>
10003786:	1b5b      	subs	r3, r3, r5
10003788:	433e      	orrs	r6, r7
1000378a:	e755      	b.n	10003638 <__aeabi_fdiv+0x9c>
1000378c:	430d      	orrs	r5, r1
1000378e:	026a      	lsls	r2, r5, #9
10003790:	0a55      	lsrs	r5, r2, #9
10003792:	1c3b      	adds	r3, r7, #0
10003794:	26ff      	movs	r6, #255	; 0xff
10003796:	e78f      	b.n	100036b8 <__aeabi_fdiv+0x11c>
10003798:	1c1d      	adds	r5, r3, #0
1000379a:	1e6b      	subs	r3, r5, #1
1000379c:	419d      	sbcs	r5, r3
1000379e:	4335      	orrs	r5, r6
100037a0:	e7c5      	b.n	1000372e <__aeabi_fdiv+0x192>
100037a2:	247e      	movs	r4, #126	; 0x7e
100037a4:	4267      	negs	r7, r4
100037a6:	464a      	mov	r2, r9
100037a8:	1ab9      	subs	r1, r7, r2
100037aa:	291b      	cmp	r1, #27
100037ac:	dd08      	ble.n	100037c0 <__aeabi_fdiv+0x224>
100037ae:	9b01      	ldr	r3, [sp, #4]
100037b0:	2600      	movs	r6, #0
100037b2:	2500      	movs	r5, #0
100037b4:	e780      	b.n	100036b8 <__aeabi_fdiv+0x11c>
100037b6:	9d01      	ldr	r5, [sp, #4]
100037b8:	2600      	movs	r6, #0
100037ba:	402b      	ands	r3, r5
100037bc:	2500      	movs	r5, #0
100037be:	e77b      	b.n	100036b8 <__aeabi_fdiv+0x11c>
100037c0:	464e      	mov	r6, r9
100037c2:	369e      	adds	r6, #158	; 0x9e
100037c4:	1c28      	adds	r0, r5, #0
100037c6:	40b5      	lsls	r5, r6
100037c8:	1c2b      	adds	r3, r5, #0
100037ca:	1e5d      	subs	r5, r3, #1
100037cc:	41ab      	sbcs	r3, r5
100037ce:	40c8      	lsrs	r0, r1
100037d0:	4303      	orrs	r3, r0
100037d2:	250f      	movs	r5, #15
100037d4:	401d      	ands	r5, r3
100037d6:	2d04      	cmp	r5, #4
100037d8:	d000      	beq.n	100037dc <__aeabi_fdiv+0x240>
100037da:	3304      	adds	r3, #4
100037dc:	015a      	lsls	r2, r3, #5
100037de:	d503      	bpl.n	100037e8 <__aeabi_fdiv+0x24c>
100037e0:	9b01      	ldr	r3, [sp, #4]
100037e2:	2601      	movs	r6, #1
100037e4:	2500      	movs	r5, #0
100037e6:	e767      	b.n	100036b8 <__aeabi_fdiv+0x11c>
100037e8:	019c      	lsls	r4, r3, #6
100037ea:	0a65      	lsrs	r5, r4, #9
100037ec:	9b01      	ldr	r3, [sp, #4]
100037ee:	2600      	movs	r6, #0
100037f0:	e762      	b.n	100036b8 <__aeabi_fdiv+0x11c>
100037f2:	2780      	movs	r7, #128	; 0x80
100037f4:	03fc      	lsls	r4, r7, #15
100037f6:	4325      	orrs	r5, r4
100037f8:	026e      	lsls	r6, r5, #9
100037fa:	0a75      	lsrs	r5, r6, #9
100037fc:	9b01      	ldr	r3, [sp, #4]
100037fe:	26ff      	movs	r6, #255	; 0xff
10003800:	e75a      	b.n	100036b8 <__aeabi_fdiv+0x11c>
10003802:	46c0      	nop			; (mov r8, r8)
10003804:	1000471c 	.word	0x1000471c
10003808:	007fffff 	.word	0x007fffff
1000380c:	f7ffffff 	.word	0xf7ffffff

10003810 <__eqsf2>:
10003810:	0243      	lsls	r3, r0, #9
10003812:	0042      	lsls	r2, r0, #1
10003814:	b570      	push	{r4, r5, r6, lr}
10003816:	0a5c      	lsrs	r4, r3, #9
10003818:	0fc6      	lsrs	r6, r0, #31
1000381a:	0e13      	lsrs	r3, r2, #24
1000381c:	0248      	lsls	r0, r1, #9
1000381e:	004a      	lsls	r2, r1, #1
10003820:	0a45      	lsrs	r5, r0, #9
10003822:	0e12      	lsrs	r2, r2, #24
10003824:	0fc9      	lsrs	r1, r1, #31
10003826:	2bff      	cmp	r3, #255	; 0xff
10003828:	d005      	beq.n	10003836 <__eqsf2+0x26>
1000382a:	2aff      	cmp	r2, #255	; 0xff
1000382c:	d008      	beq.n	10003840 <__eqsf2+0x30>
1000382e:	2001      	movs	r0, #1
10003830:	4293      	cmp	r3, r2
10003832:	d00b      	beq.n	1000384c <__eqsf2+0x3c>
10003834:	bd70      	pop	{r4, r5, r6, pc}
10003836:	2001      	movs	r0, #1
10003838:	2c00      	cmp	r4, #0
1000383a:	d1fb      	bne.n	10003834 <__eqsf2+0x24>
1000383c:	2aff      	cmp	r2, #255	; 0xff
1000383e:	d1f6      	bne.n	1000382e <__eqsf2+0x1e>
10003840:	2001      	movs	r0, #1
10003842:	2d00      	cmp	r5, #0
10003844:	d1f6      	bne.n	10003834 <__eqsf2+0x24>
10003846:	2001      	movs	r0, #1
10003848:	4293      	cmp	r3, r2
1000384a:	d1f3      	bne.n	10003834 <__eqsf2+0x24>
1000384c:	42ac      	cmp	r4, r5
1000384e:	d1f1      	bne.n	10003834 <__eqsf2+0x24>
10003850:	428e      	cmp	r6, r1
10003852:	d003      	beq.n	1000385c <__eqsf2+0x4c>
10003854:	2b00      	cmp	r3, #0
10003856:	d1ed      	bne.n	10003834 <__eqsf2+0x24>
10003858:	2c00      	cmp	r4, #0
1000385a:	d1eb      	bne.n	10003834 <__eqsf2+0x24>
1000385c:	2000      	movs	r0, #0
1000385e:	e7e9      	b.n	10003834 <__eqsf2+0x24>

10003860 <__gesf2>:
10003860:	b5f0      	push	{r4, r5, r6, r7, lr}
10003862:	0243      	lsls	r3, r0, #9
10003864:	0042      	lsls	r2, r0, #1
10003866:	004f      	lsls	r7, r1, #1
10003868:	0fc6      	lsrs	r6, r0, #31
1000386a:	0248      	lsls	r0, r1, #9
1000386c:	0a5c      	lsrs	r4, r3, #9
1000386e:	0a45      	lsrs	r5, r0, #9
10003870:	0e13      	lsrs	r3, r2, #24
10003872:	0fc9      	lsrs	r1, r1, #31
10003874:	0e3a      	lsrs	r2, r7, #24
10003876:	2bff      	cmp	r3, #255	; 0xff
10003878:	d026      	beq.n	100038c8 <__gesf2+0x68>
1000387a:	2aff      	cmp	r2, #255	; 0xff
1000387c:	d029      	beq.n	100038d2 <__gesf2+0x72>
1000387e:	2b00      	cmp	r3, #0
10003880:	d10c      	bne.n	1000389c <__gesf2+0x3c>
10003882:	4260      	negs	r0, r4
10003884:	4160      	adcs	r0, r4
10003886:	4684      	mov	ip, r0
10003888:	2a00      	cmp	r2, #0
1000388a:	d00a      	beq.n	100038a2 <__gesf2+0x42>
1000388c:	2800      	cmp	r0, #0
1000388e:	d116      	bne.n	100038be <__gesf2+0x5e>
10003890:	428e      	cmp	r6, r1
10003892:	d021      	beq.n	100038d8 <__gesf2+0x78>
10003894:	2e00      	cmp	r6, #0
10003896:	d114      	bne.n	100038c2 <__gesf2+0x62>
10003898:	2001      	movs	r0, #1
1000389a:	e014      	b.n	100038c6 <__gesf2+0x66>
1000389c:	2a00      	cmp	r2, #0
1000389e:	d1f7      	bne.n	10003890 <__gesf2+0x30>
100038a0:	4694      	mov	ip, r2
100038a2:	426f      	negs	r7, r5
100038a4:	416f      	adcs	r7, r5
100038a6:	4660      	mov	r0, ip
100038a8:	2800      	cmp	r0, #0
100038aa:	d105      	bne.n	100038b8 <__gesf2+0x58>
100038ac:	2f00      	cmp	r7, #0
100038ae:	d0ef      	beq.n	10003890 <__gesf2+0x30>
100038b0:	2001      	movs	r0, #1
100038b2:	2e00      	cmp	r6, #0
100038b4:	d007      	beq.n	100038c6 <__gesf2+0x66>
100038b6:	e004      	b.n	100038c2 <__gesf2+0x62>
100038b8:	2000      	movs	r0, #0
100038ba:	2f00      	cmp	r7, #0
100038bc:	d103      	bne.n	100038c6 <__gesf2+0x66>
100038be:	2900      	cmp	r1, #0
100038c0:	d1ea      	bne.n	10003898 <__gesf2+0x38>
100038c2:	2101      	movs	r1, #1
100038c4:	4248      	negs	r0, r1
100038c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
100038c8:	2c00      	cmp	r4, #0
100038ca:	d0d6      	beq.n	1000387a <__gesf2+0x1a>
100038cc:	2202      	movs	r2, #2
100038ce:	4250      	negs	r0, r2
100038d0:	e7f9      	b.n	100038c6 <__gesf2+0x66>
100038d2:	2d00      	cmp	r5, #0
100038d4:	d0d3      	beq.n	1000387e <__gesf2+0x1e>
100038d6:	e7f9      	b.n	100038cc <__gesf2+0x6c>
100038d8:	4293      	cmp	r3, r2
100038da:	dcdb      	bgt.n	10003894 <__gesf2+0x34>
100038dc:	db04      	blt.n	100038e8 <__gesf2+0x88>
100038de:	42ac      	cmp	r4, r5
100038e0:	d8d8      	bhi.n	10003894 <__gesf2+0x34>
100038e2:	2000      	movs	r0, #0
100038e4:	42ac      	cmp	r4, r5
100038e6:	d2ee      	bcs.n	100038c6 <__gesf2+0x66>
100038e8:	2e00      	cmp	r6, #0
100038ea:	d0ea      	beq.n	100038c2 <__gesf2+0x62>
100038ec:	2001      	movs	r0, #1
100038ee:	e7ea      	b.n	100038c6 <__gesf2+0x66>

100038f0 <__lesf2>:
100038f0:	b5f0      	push	{r4, r5, r6, r7, lr}
100038f2:	0243      	lsls	r3, r0, #9
100038f4:	0042      	lsls	r2, r0, #1
100038f6:	004f      	lsls	r7, r1, #1
100038f8:	0fc6      	lsrs	r6, r0, #31
100038fa:	0248      	lsls	r0, r1, #9
100038fc:	0a5c      	lsrs	r4, r3, #9
100038fe:	0a45      	lsrs	r5, r0, #9
10003900:	0e13      	lsrs	r3, r2, #24
10003902:	0fc9      	lsrs	r1, r1, #31
10003904:	0e3a      	lsrs	r2, r7, #24
10003906:	2bff      	cmp	r3, #255	; 0xff
10003908:	d026      	beq.n	10003958 <__lesf2+0x68>
1000390a:	2aff      	cmp	r2, #255	; 0xff
1000390c:	d028      	beq.n	10003960 <__lesf2+0x70>
1000390e:	2b00      	cmp	r3, #0
10003910:	d00f      	beq.n	10003932 <__lesf2+0x42>
10003912:	2a00      	cmp	r2, #0
10003914:	d114      	bne.n	10003940 <__lesf2+0x50>
10003916:	4694      	mov	ip, r2
10003918:	426f      	negs	r7, r5
1000391a:	416f      	adcs	r7, r5
1000391c:	4660      	mov	r0, ip
1000391e:	2800      	cmp	r0, #0
10003920:	d014      	beq.n	1000394c <__lesf2+0x5c>
10003922:	2000      	movs	r0, #0
10003924:	2f00      	cmp	r7, #0
10003926:	d103      	bne.n	10003930 <__lesf2+0x40>
10003928:	2900      	cmp	r1, #0
1000392a:	d10d      	bne.n	10003948 <__lesf2+0x58>
1000392c:	2101      	movs	r1, #1
1000392e:	4248      	negs	r0, r1
10003930:	bdf0      	pop	{r4, r5, r6, r7, pc}
10003932:	4260      	negs	r0, r4
10003934:	4160      	adcs	r0, r4
10003936:	4684      	mov	ip, r0
10003938:	2a00      	cmp	r2, #0
1000393a:	d0ed      	beq.n	10003918 <__lesf2+0x28>
1000393c:	2800      	cmp	r0, #0
1000393e:	d1f3      	bne.n	10003928 <__lesf2+0x38>
10003940:	428e      	cmp	r6, r1
10003942:	d011      	beq.n	10003968 <__lesf2+0x78>
10003944:	2e00      	cmp	r6, #0
10003946:	d1f1      	bne.n	1000392c <__lesf2+0x3c>
10003948:	2001      	movs	r0, #1
1000394a:	e7f1      	b.n	10003930 <__lesf2+0x40>
1000394c:	2f00      	cmp	r7, #0
1000394e:	d0f7      	beq.n	10003940 <__lesf2+0x50>
10003950:	2001      	movs	r0, #1
10003952:	2e00      	cmp	r6, #0
10003954:	d0ec      	beq.n	10003930 <__lesf2+0x40>
10003956:	e7e9      	b.n	1000392c <__lesf2+0x3c>
10003958:	2002      	movs	r0, #2
1000395a:	2c00      	cmp	r4, #0
1000395c:	d1e8      	bne.n	10003930 <__lesf2+0x40>
1000395e:	e7d4      	b.n	1000390a <__lesf2+0x1a>
10003960:	2002      	movs	r0, #2
10003962:	2d00      	cmp	r5, #0
10003964:	d1e4      	bne.n	10003930 <__lesf2+0x40>
10003966:	e7d2      	b.n	1000390e <__lesf2+0x1e>
10003968:	4293      	cmp	r3, r2
1000396a:	dceb      	bgt.n	10003944 <__lesf2+0x54>
1000396c:	db04      	blt.n	10003978 <__lesf2+0x88>
1000396e:	42ac      	cmp	r4, r5
10003970:	d8e8      	bhi.n	10003944 <__lesf2+0x54>
10003972:	2000      	movs	r0, #0
10003974:	42ac      	cmp	r4, r5
10003976:	d2db      	bcs.n	10003930 <__lesf2+0x40>
10003978:	2e00      	cmp	r6, #0
1000397a:	d0d7      	beq.n	1000392c <__lesf2+0x3c>
1000397c:	2001      	movs	r0, #1
1000397e:	e7d7      	b.n	10003930 <__lesf2+0x40>

10003980 <__aeabi_fmul>:
10003980:	b5f0      	push	{r4, r5, r6, r7, lr}
10003982:	465f      	mov	r7, fp
10003984:	4656      	mov	r6, sl
10003986:	464d      	mov	r5, r9
10003988:	4644      	mov	r4, r8
1000398a:	b4f0      	push	{r4, r5, r6, r7}
1000398c:	0245      	lsls	r5, r0, #9
1000398e:	0046      	lsls	r6, r0, #1
10003990:	b083      	sub	sp, #12
10003992:	1c0f      	adds	r7, r1, #0
10003994:	0a6d      	lsrs	r5, r5, #9
10003996:	0e36      	lsrs	r6, r6, #24
10003998:	0fc4      	lsrs	r4, r0, #31
1000399a:	2e00      	cmp	r6, #0
1000399c:	d106      	bne.n	100039ac <__aeabi_fmul+0x2c>
1000399e:	2d00      	cmp	r5, #0
100039a0:	d170      	bne.n	10003a84 <__aeabi_fmul+0x104>
100039a2:	2104      	movs	r1, #4
100039a4:	2201      	movs	r2, #1
100039a6:	4688      	mov	r8, r1
100039a8:	4692      	mov	sl, r2
100039aa:	e009      	b.n	100039c0 <__aeabi_fmul+0x40>
100039ac:	2eff      	cmp	r6, #255	; 0xff
100039ae:	d043      	beq.n	10003a38 <__aeabi_fmul+0xb8>
100039b0:	2380      	movs	r3, #128	; 0x80
100039b2:	0418      	lsls	r0, r3, #16
100039b4:	2100      	movs	r1, #0
100039b6:	4305      	orrs	r5, r0
100039b8:	00ed      	lsls	r5, r5, #3
100039ba:	3e7f      	subs	r6, #127	; 0x7f
100039bc:	4688      	mov	r8, r1
100039be:	468a      	mov	sl, r1
100039c0:	1c38      	adds	r0, r7, #0
100039c2:	0043      	lsls	r3, r0, #1
100039c4:	027f      	lsls	r7, r7, #9
100039c6:	0fc1      	lsrs	r1, r0, #31
100039c8:	0a7f      	lsrs	r7, r7, #9
100039ca:	0e1b      	lsrs	r3, r3, #24
100039cc:	468b      	mov	fp, r1
100039ce:	d13a      	bne.n	10003a46 <__aeabi_fmul+0xc6>
100039d0:	2101      	movs	r1, #1
100039d2:	2f00      	cmp	r7, #0
100039d4:	d162      	bne.n	10003a9c <__aeabi_fmul+0x11c>
100039d6:	4658      	mov	r0, fp
100039d8:	4060      	eors	r0, r4
100039da:	4642      	mov	r2, r8
100039dc:	9001      	str	r0, [sp, #4]
100039de:	430a      	orrs	r2, r1
100039e0:	2a0f      	cmp	r2, #15
100039e2:	d93f      	bls.n	10003a64 <__aeabi_fmul+0xe4>
100039e4:	042c      	lsls	r4, r5, #16
100039e6:	18f0      	adds	r0, r6, r3
100039e8:	0c26      	lsrs	r6, r4, #16
100039ea:	043b      	lsls	r3, r7, #16
100039ec:	0c1a      	lsrs	r2, r3, #16
100039ee:	1c31      	adds	r1, r6, #0
100039f0:	4351      	muls	r1, r2
100039f2:	0c3f      	lsrs	r7, r7, #16
100039f4:	0c2d      	lsrs	r5, r5, #16
100039f6:	437e      	muls	r6, r7
100039f8:	436a      	muls	r2, r5
100039fa:	4681      	mov	r9, r0
100039fc:	0c08      	lsrs	r0, r1, #16
100039fe:	1836      	adds	r6, r6, r0
10003a00:	1c2c      	adds	r4, r5, #0
10003a02:	18b3      	adds	r3, r6, r2
10003a04:	437c      	muls	r4, r7
10003a06:	429a      	cmp	r2, r3
10003a08:	d900      	bls.n	10003a0c <__aeabi_fmul+0x8c>
10003a0a:	e09a      	b.n	10003b42 <__aeabi_fmul+0x1c2>
10003a0c:	0409      	lsls	r1, r1, #16
10003a0e:	041d      	lsls	r5, r3, #16
10003a10:	0c08      	lsrs	r0, r1, #16
10003a12:	182e      	adds	r6, r5, r0
10003a14:	01b5      	lsls	r5, r6, #6
10003a16:	0c1b      	lsrs	r3, r3, #16
10003a18:	1e69      	subs	r1, r5, #1
10003a1a:	418d      	sbcs	r5, r1
10003a1c:	0eb2      	lsrs	r2, r6, #26
10003a1e:	18e7      	adds	r7, r4, r3
10003a20:	4315      	orrs	r5, r2
10003a22:	01bc      	lsls	r4, r7, #6
10003a24:	4325      	orrs	r5, r4
10003a26:	012b      	lsls	r3, r5, #4
10003a28:	d54b      	bpl.n	10003ac2 <__aeabi_fmul+0x142>
10003a2a:	2001      	movs	r0, #1
10003a2c:	4028      	ands	r0, r5
10003a2e:	2101      	movs	r1, #1
10003a30:	086d      	lsrs	r5, r5, #1
10003a32:	4489      	add	r9, r1
10003a34:	4305      	orrs	r5, r0
10003a36:	e044      	b.n	10003ac2 <__aeabi_fmul+0x142>
10003a38:	2d00      	cmp	r5, #0
10003a3a:	d11e      	bne.n	10003a7a <__aeabi_fmul+0xfa>
10003a3c:	2008      	movs	r0, #8
10003a3e:	2102      	movs	r1, #2
10003a40:	4680      	mov	r8, r0
10003a42:	468a      	mov	sl, r1
10003a44:	e7bc      	b.n	100039c0 <__aeabi_fmul+0x40>
10003a46:	2bff      	cmp	r3, #255	; 0xff
10003a48:	d012      	beq.n	10003a70 <__aeabi_fmul+0xf0>
10003a4a:	2280      	movs	r2, #128	; 0x80
10003a4c:	0410      	lsls	r0, r2, #16
10003a4e:	4307      	orrs	r7, r0
10003a50:	4658      	mov	r0, fp
10003a52:	2100      	movs	r1, #0
10003a54:	4060      	eors	r0, r4
10003a56:	4642      	mov	r2, r8
10003a58:	00ff      	lsls	r7, r7, #3
10003a5a:	3b7f      	subs	r3, #127	; 0x7f
10003a5c:	9001      	str	r0, [sp, #4]
10003a5e:	430a      	orrs	r2, r1
10003a60:	2a0f      	cmp	r2, #15
10003a62:	d8bf      	bhi.n	100039e4 <__aeabi_fmul+0x64>
10003a64:	0090      	lsls	r0, r2, #2
10003a66:	4a5b      	ldr	r2, [pc, #364]	; (10003bd4 <__aeabi_fmul+0x254>)
10003a68:	4684      	mov	ip, r0
10003a6a:	4462      	add	r2, ip
10003a6c:	6810      	ldr	r0, [r2, #0]
10003a6e:	4687      	mov	pc, r0
10003a70:	1c39      	adds	r1, r7, #0
10003a72:	1e4a      	subs	r2, r1, #1
10003a74:	4191      	sbcs	r1, r2
10003a76:	3102      	adds	r1, #2
10003a78:	e7ad      	b.n	100039d6 <__aeabi_fmul+0x56>
10003a7a:	220c      	movs	r2, #12
10003a7c:	2303      	movs	r3, #3
10003a7e:	4690      	mov	r8, r2
10003a80:	469a      	mov	sl, r3
10003a82:	e79d      	b.n	100039c0 <__aeabi_fmul+0x40>
10003a84:	1c28      	adds	r0, r5, #0
10003a86:	f000 faf9 	bl	1000407c <__clzsi2>
10003a8a:	2276      	movs	r2, #118	; 0x76
10003a8c:	1f46      	subs	r6, r0, #5
10003a8e:	4253      	negs	r3, r2
10003a90:	40b5      	lsls	r5, r6
10003a92:	1a1e      	subs	r6, r3, r0
10003a94:	2000      	movs	r0, #0
10003a96:	4680      	mov	r8, r0
10003a98:	4682      	mov	sl, r0
10003a9a:	e791      	b.n	100039c0 <__aeabi_fmul+0x40>
10003a9c:	1c38      	adds	r0, r7, #0
10003a9e:	f000 faed 	bl	1000407c <__clzsi2>
10003aa2:	2176      	movs	r1, #118	; 0x76
10003aa4:	1f43      	subs	r3, r0, #5
10003aa6:	424a      	negs	r2, r1
10003aa8:	409f      	lsls	r7, r3
10003aaa:	2100      	movs	r1, #0
10003aac:	1a13      	subs	r3, r2, r0
10003aae:	e792      	b.n	100039d6 <__aeabi_fmul+0x56>
10003ab0:	9401      	str	r4, [sp, #4]
10003ab2:	4651      	mov	r1, sl
10003ab4:	2902      	cmp	r1, #2
10003ab6:	d02c      	beq.n	10003b12 <__aeabi_fmul+0x192>
10003ab8:	2903      	cmp	r1, #3
10003aba:	d100      	bne.n	10003abe <__aeabi_fmul+0x13e>
10003abc:	e080      	b.n	10003bc0 <__aeabi_fmul+0x240>
10003abe:	2901      	cmp	r1, #1
10003ac0:	d048      	beq.n	10003b54 <__aeabi_fmul+0x1d4>
10003ac2:	464e      	mov	r6, r9
10003ac4:	367f      	adds	r6, #127	; 0x7f
10003ac6:	2e00      	cmp	r6, #0
10003ac8:	dd51      	ble.n	10003b6e <__aeabi_fmul+0x1ee>
10003aca:	240f      	movs	r4, #15
10003acc:	402c      	ands	r4, r5
10003ace:	2c04      	cmp	r4, #4
10003ad0:	d000      	beq.n	10003ad4 <__aeabi_fmul+0x154>
10003ad2:	3504      	adds	r5, #4
10003ad4:	012a      	lsls	r2, r5, #4
10003ad6:	d503      	bpl.n	10003ae0 <__aeabi_fmul+0x160>
10003ad8:	493f      	ldr	r1, [pc, #252]	; (10003bd8 <__aeabi_fmul+0x258>)
10003ada:	464e      	mov	r6, r9
10003adc:	400d      	ands	r5, r1
10003ade:	3680      	adds	r6, #128	; 0x80
10003ae0:	2efe      	cmp	r6, #254	; 0xfe
10003ae2:	dd3d      	ble.n	10003b60 <__aeabi_fmul+0x1e0>
10003ae4:	9b01      	ldr	r3, [sp, #4]
10003ae6:	2401      	movs	r4, #1
10003ae8:	401c      	ands	r4, r3
10003aea:	21ff      	movs	r1, #255	; 0xff
10003aec:	2500      	movs	r5, #0
10003aee:	05c8      	lsls	r0, r1, #23
10003af0:	07e2      	lsls	r2, r4, #31
10003af2:	4328      	orrs	r0, r5
10003af4:	4310      	orrs	r0, r2
10003af6:	b003      	add	sp, #12
10003af8:	bc3c      	pop	{r2, r3, r4, r5}
10003afa:	4690      	mov	r8, r2
10003afc:	4699      	mov	r9, r3
10003afe:	46a2      	mov	sl, r4
10003b00:	46ab      	mov	fp, r5
10003b02:	bdf0      	pop	{r4, r5, r6, r7, pc}
10003b04:	2400      	movs	r4, #0
10003b06:	4d35      	ldr	r5, [pc, #212]	; (10003bdc <__aeabi_fmul+0x25c>)
10003b08:	21ff      	movs	r1, #255	; 0xff
10003b0a:	e7f0      	b.n	10003aee <__aeabi_fmul+0x16e>
10003b0c:	4651      	mov	r1, sl
10003b0e:	2902      	cmp	r1, #2
10003b10:	d1d2      	bne.n	10003ab8 <__aeabi_fmul+0x138>
10003b12:	9d01      	ldr	r5, [sp, #4]
10003b14:	2401      	movs	r4, #1
10003b16:	402c      	ands	r4, r5
10003b18:	21ff      	movs	r1, #255	; 0xff
10003b1a:	2500      	movs	r5, #0
10003b1c:	e7e7      	b.n	10003aee <__aeabi_fmul+0x16e>
10003b1e:	465e      	mov	r6, fp
10003b20:	1c3d      	adds	r5, r7, #0
10003b22:	9601      	str	r6, [sp, #4]
10003b24:	e7c6      	b.n	10003ab4 <__aeabi_fmul+0x134>
10003b26:	1c3d      	adds	r5, r7, #0
10003b28:	e7c4      	b.n	10003ab4 <__aeabi_fmul+0x134>
10003b2a:	2680      	movs	r6, #128	; 0x80
10003b2c:	03f3      	lsls	r3, r6, #15
10003b2e:	421d      	tst	r5, r3
10003b30:	d00b      	beq.n	10003b4a <__aeabi_fmul+0x1ca>
10003b32:	421f      	tst	r7, r3
10003b34:	d109      	bne.n	10003b4a <__aeabi_fmul+0x1ca>
10003b36:	431f      	orrs	r7, r3
10003b38:	027a      	lsls	r2, r7, #9
10003b3a:	0a55      	lsrs	r5, r2, #9
10003b3c:	465c      	mov	r4, fp
10003b3e:	21ff      	movs	r1, #255	; 0xff
10003b40:	e7d5      	b.n	10003aee <__aeabi_fmul+0x16e>
10003b42:	2280      	movs	r2, #128	; 0x80
10003b44:	0257      	lsls	r7, r2, #9
10003b46:	19e4      	adds	r4, r4, r7
10003b48:	e760      	b.n	10003a0c <__aeabi_fmul+0x8c>
10003b4a:	431d      	orrs	r5, r3
10003b4c:	026f      	lsls	r7, r5, #9
10003b4e:	0a7d      	lsrs	r5, r7, #9
10003b50:	21ff      	movs	r1, #255	; 0xff
10003b52:	e7cc      	b.n	10003aee <__aeabi_fmul+0x16e>
10003b54:	9b01      	ldr	r3, [sp, #4]
10003b56:	2500      	movs	r5, #0
10003b58:	4019      	ands	r1, r3
10003b5a:	b2cc      	uxtb	r4, r1
10003b5c:	2100      	movs	r1, #0
10003b5e:	e7c6      	b.n	10003aee <__aeabi_fmul+0x16e>
10003b60:	9801      	ldr	r0, [sp, #4]
10003b62:	01ad      	lsls	r5, r5, #6
10003b64:	2401      	movs	r4, #1
10003b66:	0a6d      	lsrs	r5, r5, #9
10003b68:	b2f1      	uxtb	r1, r6
10003b6a:	4004      	ands	r4, r0
10003b6c:	e7bf      	b.n	10003aee <__aeabi_fmul+0x16e>
10003b6e:	267e      	movs	r6, #126	; 0x7e
10003b70:	4273      	negs	r3, r6
10003b72:	464a      	mov	r2, r9
10003b74:	1a9f      	subs	r7, r3, r2
10003b76:	2f1b      	cmp	r7, #27
10003b78:	dd05      	ble.n	10003b86 <__aeabi_fmul+0x206>
10003b7a:	9d01      	ldr	r5, [sp, #4]
10003b7c:	2401      	movs	r4, #1
10003b7e:	402c      	ands	r4, r5
10003b80:	2100      	movs	r1, #0
10003b82:	2500      	movs	r5, #0
10003b84:	e7b3      	b.n	10003aee <__aeabi_fmul+0x16e>
10003b86:	4649      	mov	r1, r9
10003b88:	319e      	adds	r1, #158	; 0x9e
10003b8a:	1c2c      	adds	r4, r5, #0
10003b8c:	408d      	lsls	r5, r1
10003b8e:	1c2e      	adds	r6, r5, #0
10003b90:	40fc      	lsrs	r4, r7
10003b92:	1e75      	subs	r5, r6, #1
10003b94:	41ae      	sbcs	r6, r5
10003b96:	4326      	orrs	r6, r4
10003b98:	200f      	movs	r0, #15
10003b9a:	4030      	ands	r0, r6
10003b9c:	2804      	cmp	r0, #4
10003b9e:	d000      	beq.n	10003ba2 <__aeabi_fmul+0x222>
10003ba0:	3604      	adds	r6, #4
10003ba2:	0170      	lsls	r0, r6, #5
10003ba4:	d505      	bpl.n	10003bb2 <__aeabi_fmul+0x232>
10003ba6:	9f01      	ldr	r7, [sp, #4]
10003ba8:	2401      	movs	r4, #1
10003baa:	403c      	ands	r4, r7
10003bac:	2101      	movs	r1, #1
10003bae:	2500      	movs	r5, #0
10003bb0:	e79d      	b.n	10003aee <__aeabi_fmul+0x16e>
10003bb2:	9a01      	ldr	r2, [sp, #4]
10003bb4:	01b3      	lsls	r3, r6, #6
10003bb6:	2401      	movs	r4, #1
10003bb8:	0a5d      	lsrs	r5, r3, #9
10003bba:	4014      	ands	r4, r2
10003bbc:	2100      	movs	r1, #0
10003bbe:	e796      	b.n	10003aee <__aeabi_fmul+0x16e>
10003bc0:	2280      	movs	r2, #128	; 0x80
10003bc2:	03d0      	lsls	r0, r2, #15
10003bc4:	4305      	orrs	r5, r0
10003bc6:	026c      	lsls	r4, r5, #9
10003bc8:	9901      	ldr	r1, [sp, #4]
10003bca:	0a65      	lsrs	r5, r4, #9
10003bcc:	2401      	movs	r4, #1
10003bce:	400c      	ands	r4, r1
10003bd0:	21ff      	movs	r1, #255	; 0xff
10003bd2:	e78c      	b.n	10003aee <__aeabi_fmul+0x16e>
10003bd4:	1000475c 	.word	0x1000475c
10003bd8:	f7ffffff 	.word	0xf7ffffff
10003bdc:	007fffff 	.word	0x007fffff

10003be0 <__aeabi_fsub>:
10003be0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
10003be2:	0243      	lsls	r3, r0, #9
10003be4:	0045      	lsls	r5, r0, #1
10003be6:	024f      	lsls	r7, r1, #9
10003be8:	004c      	lsls	r4, r1, #1
10003bea:	0fc2      	lsrs	r2, r0, #31
10003bec:	0998      	lsrs	r0, r3, #6
10003bee:	4684      	mov	ip, r0
10003bf0:	0e2d      	lsrs	r5, r5, #24
10003bf2:	0e20      	lsrs	r0, r4, #24
10003bf4:	0fc9      	lsrs	r1, r1, #31
10003bf6:	09bf      	lsrs	r7, r7, #6
10003bf8:	28ff      	cmp	r0, #255	; 0xff
10003bfa:	d054      	beq.n	10003ca6 <__aeabi_fsub+0xc6>
10003bfc:	2601      	movs	r6, #1
10003bfe:	4071      	eors	r1, r6
10003c00:	428a      	cmp	r2, r1
10003c02:	d03b      	beq.n	10003c7c <__aeabi_fsub+0x9c>
10003c04:	1a2c      	subs	r4, r5, r0
10003c06:	2c00      	cmp	r4, #0
10003c08:	dc00      	bgt.n	10003c0c <__aeabi_fsub+0x2c>
10003c0a:	e089      	b.n	10003d20 <__aeabi_fsub+0x140>
10003c0c:	2800      	cmp	r0, #0
10003c0e:	d125      	bne.n	10003c5c <__aeabi_fsub+0x7c>
10003c10:	2f00      	cmp	r7, #0
10003c12:	d14b      	bne.n	10003cac <__aeabi_fsub+0xcc>
10003c14:	1c6e      	adds	r6, r5, #1
10003c16:	1c2c      	adds	r4, r5, #0
10003c18:	4663      	mov	r3, ip
10003c1a:	1c15      	adds	r5, r2, #0
10003c1c:	220f      	movs	r2, #15
10003c1e:	401a      	ands	r2, r3
10003c20:	2a04      	cmp	r2, #4
10003c22:	d000      	beq.n	10003c26 <__aeabi_fsub+0x46>
10003c24:	3304      	adds	r3, #4
10003c26:	2780      	movs	r7, #128	; 0x80
10003c28:	04f9      	lsls	r1, r7, #19
10003c2a:	2201      	movs	r2, #1
10003c2c:	4019      	ands	r1, r3
10003c2e:	402a      	ands	r2, r5
10003c30:	2900      	cmp	r1, #0
10003c32:	d006      	beq.n	10003c42 <__aeabi_fsub+0x62>
10003c34:	2eff      	cmp	r6, #255	; 0xff
10003c36:	d100      	bne.n	10003c3a <__aeabi_fsub+0x5a>
10003c38:	e081      	b.n	10003d3e <__aeabi_fsub+0x15e>
10003c3a:	4db1      	ldr	r5, [pc, #708]	; (10003f00 <__aeabi_fsub+0x320>)
10003c3c:	1c34      	adds	r4, r6, #0
10003c3e:	402b      	ands	r3, r5
10003c40:	3601      	adds	r6, #1
10003c42:	b2f6      	uxtb	r6, r6
10003c44:	08dd      	lsrs	r5, r3, #3
10003c46:	2e01      	cmp	r6, #1
10003c48:	dd62      	ble.n	10003d10 <__aeabi_fsub+0x130>
10003c4a:	026b      	lsls	r3, r5, #9
10003c4c:	0a5d      	lsrs	r5, r3, #9
10003c4e:	b2e4      	uxtb	r4, r4
10003c50:	05e4      	lsls	r4, r4, #23
10003c52:	4325      	orrs	r5, r4
10003c54:	1c28      	adds	r0, r5, #0
10003c56:	07d2      	lsls	r2, r2, #31
10003c58:	4310      	orrs	r0, r2
10003c5a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
10003c5c:	2dff      	cmp	r5, #255	; 0xff
10003c5e:	d051      	beq.n	10003d04 <__aeabi_fsub+0x124>
10003c60:	2180      	movs	r1, #128	; 0x80
10003c62:	04cb      	lsls	r3, r1, #19
10003c64:	431f      	orrs	r7, r3
10003c66:	2601      	movs	r6, #1
10003c68:	2c1b      	cmp	r4, #27
10003c6a:	dd70      	ble.n	10003d4e <__aeabi_fsub+0x16e>
10003c6c:	4667      	mov	r7, ip
10003c6e:	1c2c      	adds	r4, r5, #0
10003c70:	1bbb      	subs	r3, r7, r6
10003c72:	1c15      	adds	r5, r2, #0
10003c74:	0158      	lsls	r0, r3, #5
10003c76:	d422      	bmi.n	10003cbe <__aeabi_fsub+0xde>
10003c78:	1c66      	adds	r6, r4, #1
10003c7a:	e7cf      	b.n	10003c1c <__aeabi_fsub+0x3c>
10003c7c:	1a2e      	subs	r6, r5, r0
10003c7e:	2e00      	cmp	r6, #0
10003c80:	dd76      	ble.n	10003d70 <__aeabi_fsub+0x190>
10003c82:	2800      	cmp	r0, #0
10003c84:	d032      	beq.n	10003cec <__aeabi_fsub+0x10c>
10003c86:	2dff      	cmp	r5, #255	; 0xff
10003c88:	d03c      	beq.n	10003d04 <__aeabi_fsub+0x124>
10003c8a:	2480      	movs	r4, #128	; 0x80
10003c8c:	04e1      	lsls	r1, r4, #19
10003c8e:	430f      	orrs	r7, r1
10003c90:	2301      	movs	r3, #1
10003c92:	2e1b      	cmp	r6, #27
10003c94:	dc00      	bgt.n	10003c98 <__aeabi_fsub+0xb8>
10003c96:	e0d1      	b.n	10003e3c <__aeabi_fsub+0x25c>
10003c98:	4463      	add	r3, ip
10003c9a:	1c2c      	adds	r4, r5, #0
10003c9c:	0158      	lsls	r0, r3, #5
10003c9e:	d47a      	bmi.n	10003d96 <__aeabi_fsub+0x1b6>
10003ca0:	1c66      	adds	r6, r4, #1
10003ca2:	1c15      	adds	r5, r2, #0
10003ca4:	e7ba      	b.n	10003c1c <__aeabi_fsub+0x3c>
10003ca6:	2f00      	cmp	r7, #0
10003ca8:	d1aa      	bne.n	10003c00 <__aeabi_fsub+0x20>
10003caa:	e7a7      	b.n	10003bfc <__aeabi_fsub+0x1c>
10003cac:	3c01      	subs	r4, #1
10003cae:	2c00      	cmp	r4, #0
10003cb0:	d16d      	bne.n	10003d8e <__aeabi_fsub+0x1ae>
10003cb2:	4663      	mov	r3, ip
10003cb4:	1c2c      	adds	r4, r5, #0
10003cb6:	1bdb      	subs	r3, r3, r7
10003cb8:	1c15      	adds	r5, r2, #0
10003cba:	0158      	lsls	r0, r3, #5
10003cbc:	d5dc      	bpl.n	10003c78 <__aeabi_fsub+0x98>
10003cbe:	019a      	lsls	r2, r3, #6
10003cc0:	0996      	lsrs	r6, r2, #6
10003cc2:	1c30      	adds	r0, r6, #0
10003cc4:	f000 f9da 	bl	1000407c <__clzsi2>
10003cc8:	3805      	subs	r0, #5
10003cca:	4086      	lsls	r6, r0
10003ccc:	4284      	cmp	r4, r0
10003cce:	dc39      	bgt.n	10003d44 <__aeabi_fsub+0x164>
10003cd0:	1b00      	subs	r0, r0, r4
10003cd2:	231f      	movs	r3, #31
10003cd4:	1a1a      	subs	r2, r3, r0
10003cd6:	1c33      	adds	r3, r6, #0
10003cd8:	1c31      	adds	r1, r6, #0
10003cda:	1c44      	adds	r4, r0, #1
10003cdc:	4093      	lsls	r3, r2
10003cde:	40e1      	lsrs	r1, r4
10003ce0:	1e5e      	subs	r6, r3, #1
10003ce2:	41b3      	sbcs	r3, r6
10003ce4:	430b      	orrs	r3, r1
10003ce6:	2601      	movs	r6, #1
10003ce8:	2400      	movs	r4, #0
10003cea:	e797      	b.n	10003c1c <__aeabi_fsub+0x3c>
10003cec:	2f00      	cmp	r7, #0
10003cee:	d100      	bne.n	10003cf2 <__aeabi_fsub+0x112>
10003cf0:	e790      	b.n	10003c14 <__aeabi_fsub+0x34>
10003cf2:	3e01      	subs	r6, #1
10003cf4:	2e00      	cmp	r6, #0
10003cf6:	d103      	bne.n	10003d00 <__aeabi_fsub+0x120>
10003cf8:	4664      	mov	r4, ip
10003cfa:	193b      	adds	r3, r7, r4
10003cfc:	1c2c      	adds	r4, r5, #0
10003cfe:	e7cd      	b.n	10003c9c <__aeabi_fsub+0xbc>
10003d00:	2dff      	cmp	r5, #255	; 0xff
10003d02:	d1c5      	bne.n	10003c90 <__aeabi_fsub+0xb0>
10003d04:	1c15      	adds	r5, r2, #0
10003d06:	2280      	movs	r2, #128	; 0x80
10003d08:	4663      	mov	r3, ip
10003d0a:	0056      	lsls	r6, r2, #1
10003d0c:	24ff      	movs	r4, #255	; 0xff
10003d0e:	e785      	b.n	10003c1c <__aeabi_fsub+0x3c>
10003d10:	2d00      	cmp	r5, #0
10003d12:	d09c      	beq.n	10003c4e <__aeabi_fsub+0x6e>
10003d14:	2c00      	cmp	r4, #0
10003d16:	d028      	beq.n	10003d6a <__aeabi_fsub+0x18a>
10003d18:	2080      	movs	r0, #128	; 0x80
10003d1a:	03c7      	lsls	r7, r0, #15
10003d1c:	433d      	orrs	r5, r7
10003d1e:	e794      	b.n	10003c4a <__aeabi_fsub+0x6a>
10003d20:	2c00      	cmp	r4, #0
10003d22:	d145      	bne.n	10003db0 <__aeabi_fsub+0x1d0>
10003d24:	1c6b      	adds	r3, r5, #1
10003d26:	b2d8      	uxtb	r0, r3
10003d28:	2801      	cmp	r0, #1
10003d2a:	dc00      	bgt.n	10003d2e <__aeabi_fsub+0x14e>
10003d2c:	e090      	b.n	10003e50 <__aeabi_fsub+0x270>
10003d2e:	4664      	mov	r4, ip
10003d30:	1be6      	subs	r6, r4, r7
10003d32:	0173      	lsls	r3, r6, #5
10003d34:	d557      	bpl.n	10003de6 <__aeabi_fsub+0x206>
10003d36:	1b3e      	subs	r6, r7, r4
10003d38:	1c2c      	adds	r4, r5, #0
10003d3a:	1c0d      	adds	r5, r1, #0
10003d3c:	e7c1      	b.n	10003cc2 <__aeabi_fsub+0xe2>
10003d3e:	24ff      	movs	r4, #255	; 0xff
10003d40:	2500      	movs	r5, #0
10003d42:	e785      	b.n	10003c50 <__aeabi_fsub+0x70>
10003d44:	4b6e      	ldr	r3, [pc, #440]	; (10003f00 <__aeabi_fsub+0x320>)
10003d46:	1a24      	subs	r4, r4, r0
10003d48:	4033      	ands	r3, r6
10003d4a:	1c66      	adds	r6, r4, #1
10003d4c:	e766      	b.n	10003c1c <__aeabi_fsub+0x3c>
10003d4e:	1c38      	adds	r0, r7, #0
10003d50:	2120      	movs	r1, #32
10003d52:	40e0      	lsrs	r0, r4
10003d54:	1b0c      	subs	r4, r1, r4
10003d56:	40a7      	lsls	r7, r4
10003d58:	1c3e      	adds	r6, r7, #0
10003d5a:	1e77      	subs	r7, r6, #1
10003d5c:	41be      	sbcs	r6, r7
10003d5e:	4306      	orrs	r6, r0
10003d60:	4667      	mov	r7, ip
10003d62:	1c2c      	adds	r4, r5, #0
10003d64:	1bbb      	subs	r3, r7, r6
10003d66:	1c15      	adds	r5, r2, #0
10003d68:	e784      	b.n	10003c74 <__aeabi_fsub+0x94>
10003d6a:	0269      	lsls	r1, r5, #9
10003d6c:	0a4d      	lsrs	r5, r1, #9
10003d6e:	e76f      	b.n	10003c50 <__aeabi_fsub+0x70>
10003d70:	2e00      	cmp	r6, #0
10003d72:	d179      	bne.n	10003e68 <__aeabi_fsub+0x288>
10003d74:	1c6c      	adds	r4, r5, #1
10003d76:	b2e0      	uxtb	r0, r4
10003d78:	2801      	cmp	r0, #1
10003d7a:	dd4b      	ble.n	10003e14 <__aeabi_fsub+0x234>
10003d7c:	2cff      	cmp	r4, #255	; 0xff
10003d7e:	d100      	bne.n	10003d82 <__aeabi_fsub+0x1a2>
10003d80:	e098      	b.n	10003eb4 <__aeabi_fsub+0x2d4>
10003d82:	4661      	mov	r1, ip
10003d84:	187f      	adds	r7, r7, r1
10003d86:	1cae      	adds	r6, r5, #2
10003d88:	087b      	lsrs	r3, r7, #1
10003d8a:	1c15      	adds	r5, r2, #0
10003d8c:	e746      	b.n	10003c1c <__aeabi_fsub+0x3c>
10003d8e:	2dff      	cmp	r5, #255	; 0xff
10003d90:	d000      	beq.n	10003d94 <__aeabi_fsub+0x1b4>
10003d92:	e768      	b.n	10003c66 <__aeabi_fsub+0x86>
10003d94:	e7b6      	b.n	10003d04 <__aeabi_fsub+0x124>
10003d96:	1c67      	adds	r7, r4, #1
10003d98:	2fff      	cmp	r7, #255	; 0xff
10003d9a:	d036      	beq.n	10003e0a <__aeabi_fsub+0x22a>
10003d9c:	4858      	ldr	r0, [pc, #352]	; (10003f00 <__aeabi_fsub+0x320>)
10003d9e:	2101      	movs	r1, #1
10003da0:	4019      	ands	r1, r3
10003da2:	4003      	ands	r3, r0
10003da4:	085b      	lsrs	r3, r3, #1
10003da6:	1ca6      	adds	r6, r4, #2
10003da8:	430b      	orrs	r3, r1
10003daa:	1c3c      	adds	r4, r7, #0
10003dac:	1c15      	adds	r5, r2, #0
10003dae:	e735      	b.n	10003c1c <__aeabi_fsub+0x3c>
10003db0:	4266      	negs	r6, r4
10003db2:	2d00      	cmp	r5, #0
10003db4:	d01e      	beq.n	10003df4 <__aeabi_fsub+0x214>
10003db6:	28ff      	cmp	r0, #255	; 0xff
10003db8:	d06f      	beq.n	10003e9a <__aeabi_fsub+0x2ba>
10003dba:	2580      	movs	r5, #128	; 0x80
10003dbc:	4662      	mov	r2, ip
10003dbe:	04eb      	lsls	r3, r5, #19
10003dc0:	431a      	orrs	r2, r3
10003dc2:	4694      	mov	ip, r2
10003dc4:	2501      	movs	r5, #1
10003dc6:	2e1b      	cmp	r6, #27
10003dc8:	dc09      	bgt.n	10003dde <__aeabi_fsub+0x1fe>
10003dca:	4662      	mov	r2, ip
10003dcc:	2320      	movs	r3, #32
10003dce:	40f2      	lsrs	r2, r6
10003dd0:	4664      	mov	r4, ip
10003dd2:	1b9e      	subs	r6, r3, r6
10003dd4:	40b4      	lsls	r4, r6
10003dd6:	1c25      	adds	r5, r4, #0
10003dd8:	1e6c      	subs	r4, r5, #1
10003dda:	41a5      	sbcs	r5, r4
10003ddc:	4315      	orrs	r5, r2
10003dde:	1b7b      	subs	r3, r7, r5
10003de0:	1c04      	adds	r4, r0, #0
10003de2:	1c0d      	adds	r5, r1, #0
10003de4:	e769      	b.n	10003cba <__aeabi_fsub+0xda>
10003de6:	2e00      	cmp	r6, #0
10003de8:	d10c      	bne.n	10003e04 <__aeabi_fsub+0x224>
10003dea:	2200      	movs	r2, #0
10003dec:	2601      	movs	r6, #1
10003dee:	2304      	movs	r3, #4
10003df0:	2400      	movs	r4, #0
10003df2:	e726      	b.n	10003c42 <__aeabi_fsub+0x62>
10003df4:	4664      	mov	r4, ip
10003df6:	2c00      	cmp	r4, #0
10003df8:	d155      	bne.n	10003ea6 <__aeabi_fsub+0x2c6>
10003dfa:	1c46      	adds	r6, r0, #1
10003dfc:	1c3b      	adds	r3, r7, #0
10003dfe:	1c04      	adds	r4, r0, #0
10003e00:	1c0d      	adds	r5, r1, #0
10003e02:	e70b      	b.n	10003c1c <__aeabi_fsub+0x3c>
10003e04:	1c2c      	adds	r4, r5, #0
10003e06:	1c15      	adds	r5, r2, #0
10003e08:	e75b      	b.n	10003cc2 <__aeabi_fsub+0xe2>
10003e0a:	2380      	movs	r3, #128	; 0x80
10003e0c:	005e      	lsls	r6, r3, #1
10003e0e:	24ff      	movs	r4, #255	; 0xff
10003e10:	2304      	movs	r3, #4
10003e12:	e716      	b.n	10003c42 <__aeabi_fsub+0x62>
10003e14:	2d00      	cmp	r5, #0
10003e16:	d000      	beq.n	10003e1a <__aeabi_fsub+0x23a>
10003e18:	e08d      	b.n	10003f36 <__aeabi_fsub+0x356>
10003e1a:	4665      	mov	r5, ip
10003e1c:	2d00      	cmp	r5, #0
10003e1e:	d100      	bne.n	10003e22 <__aeabi_fsub+0x242>
10003e20:	e0ad      	b.n	10003f7e <__aeabi_fsub+0x39e>
10003e22:	2f00      	cmp	r7, #0
10003e24:	d100      	bne.n	10003e28 <__aeabi_fsub+0x248>
10003e26:	e081      	b.n	10003f2c <__aeabi_fsub+0x34c>
10003e28:	197b      	adds	r3, r7, r5
10003e2a:	015c      	lsls	r4, r3, #5
10003e2c:	d400      	bmi.n	10003e30 <__aeabi_fsub+0x250>
10003e2e:	e07e      	b.n	10003f2e <__aeabi_fsub+0x34e>
10003e30:	4f33      	ldr	r7, [pc, #204]	; (10003f00 <__aeabi_fsub+0x320>)
10003e32:	1c15      	adds	r5, r2, #0
10003e34:	403b      	ands	r3, r7
10003e36:	2602      	movs	r6, #2
10003e38:	2401      	movs	r4, #1
10003e3a:	e6ef      	b.n	10003c1c <__aeabi_fsub+0x3c>
10003e3c:	1c38      	adds	r0, r7, #0
10003e3e:	2320      	movs	r3, #32
10003e40:	40f0      	lsrs	r0, r6
10003e42:	1b9e      	subs	r6, r3, r6
10003e44:	40b7      	lsls	r7, r6
10003e46:	1c3b      	adds	r3, r7, #0
10003e48:	1e5f      	subs	r7, r3, #1
10003e4a:	41bb      	sbcs	r3, r7
10003e4c:	4303      	orrs	r3, r0
10003e4e:	e723      	b.n	10003c98 <__aeabi_fsub+0xb8>
10003e50:	2d00      	cmp	r5, #0
10003e52:	d115      	bne.n	10003e80 <__aeabi_fsub+0x2a0>
10003e54:	4665      	mov	r5, ip
10003e56:	2d00      	cmp	r5, #0
10003e58:	d147      	bne.n	10003eea <__aeabi_fsub+0x30a>
10003e5a:	2f00      	cmp	r7, #0
10003e5c:	d0c5      	beq.n	10003dea <__aeabi_fsub+0x20a>
10003e5e:	1c3b      	adds	r3, r7, #0
10003e60:	1c0d      	adds	r5, r1, #0
10003e62:	2601      	movs	r6, #1
10003e64:	2400      	movs	r4, #0
10003e66:	e6d9      	b.n	10003c1c <__aeabi_fsub+0x3c>
10003e68:	4276      	negs	r6, r6
10003e6a:	2d00      	cmp	r5, #0
10003e6c:	d126      	bne.n	10003ebc <__aeabi_fsub+0x2dc>
10003e6e:	4665      	mov	r5, ip
10003e70:	2d00      	cmp	r5, #0
10003e72:	d000      	beq.n	10003e76 <__aeabi_fsub+0x296>
10003e74:	e07d      	b.n	10003f72 <__aeabi_fsub+0x392>
10003e76:	1c46      	adds	r6, r0, #1
10003e78:	1c3b      	adds	r3, r7, #0
10003e7a:	1c04      	adds	r4, r0, #0
10003e7c:	1c15      	adds	r5, r2, #0
10003e7e:	e6cd      	b.n	10003c1c <__aeabi_fsub+0x3c>
10003e80:	4665      	mov	r5, ip
10003e82:	2d00      	cmp	r5, #0
10003e84:	d140      	bne.n	10003f08 <__aeabi_fsub+0x328>
10003e86:	2f00      	cmp	r7, #0
10003e88:	d107      	bne.n	10003e9a <__aeabi_fsub+0x2ba>
10003e8a:	2180      	movs	r1, #128	; 0x80
10003e8c:	2200      	movs	r2, #0
10003e8e:	004e      	lsls	r6, r1, #1
10003e90:	4b1c      	ldr	r3, [pc, #112]	; (10003f04 <__aeabi_fsub+0x324>)
10003e92:	24ff      	movs	r4, #255	; 0xff
10003e94:	e6d5      	b.n	10003c42 <__aeabi_fsub+0x62>
10003e96:	28ff      	cmp	r0, #255	; 0xff
10003e98:	d194      	bne.n	10003dc4 <__aeabi_fsub+0x1e4>
10003e9a:	2080      	movs	r0, #128	; 0x80
10003e9c:	1c3b      	adds	r3, r7, #0
10003e9e:	1c0d      	adds	r5, r1, #0
10003ea0:	0046      	lsls	r6, r0, #1
10003ea2:	24ff      	movs	r4, #255	; 0xff
10003ea4:	e6ba      	b.n	10003c1c <__aeabi_fsub+0x3c>
10003ea6:	3e01      	subs	r6, #1
10003ea8:	2e00      	cmp	r6, #0
10003eaa:	d1f4      	bne.n	10003e96 <__aeabi_fsub+0x2b6>
10003eac:	1b3b      	subs	r3, r7, r4
10003eae:	1c0d      	adds	r5, r1, #0
10003eb0:	1c04      	adds	r4, r0, #0
10003eb2:	e702      	b.n	10003cba <__aeabi_fsub+0xda>
10003eb4:	2580      	movs	r5, #128	; 0x80
10003eb6:	006e      	lsls	r6, r5, #1
10003eb8:	2304      	movs	r3, #4
10003eba:	e6c2      	b.n	10003c42 <__aeabi_fsub+0x62>
10003ebc:	28ff      	cmp	r0, #255	; 0xff
10003ebe:	d052      	beq.n	10003f66 <__aeabi_fsub+0x386>
10003ec0:	2480      	movs	r4, #128	; 0x80
10003ec2:	4661      	mov	r1, ip
10003ec4:	04e3      	lsls	r3, r4, #19
10003ec6:	4319      	orrs	r1, r3
10003ec8:	468c      	mov	ip, r1
10003eca:	2301      	movs	r3, #1
10003ecc:	2e1b      	cmp	r6, #27
10003ece:	dc09      	bgt.n	10003ee4 <__aeabi_fsub+0x304>
10003ed0:	2120      	movs	r1, #32
10003ed2:	4664      	mov	r4, ip
10003ed4:	40f4      	lsrs	r4, r6
10003ed6:	4665      	mov	r5, ip
10003ed8:	1b8e      	subs	r6, r1, r6
10003eda:	40b5      	lsls	r5, r6
10003edc:	1c2b      	adds	r3, r5, #0
10003ede:	1e59      	subs	r1, r3, #1
10003ee0:	418b      	sbcs	r3, r1
10003ee2:	4323      	orrs	r3, r4
10003ee4:	19db      	adds	r3, r3, r7
10003ee6:	1c04      	adds	r4, r0, #0
10003ee8:	e6d8      	b.n	10003c9c <__aeabi_fsub+0xbc>
10003eea:	2f00      	cmp	r7, #0
10003eec:	d01e      	beq.n	10003f2c <__aeabi_fsub+0x34c>
10003eee:	1beb      	subs	r3, r5, r7
10003ef0:	0158      	lsls	r0, r3, #5
10003ef2:	d54b      	bpl.n	10003f8c <__aeabi_fsub+0x3ac>
10003ef4:	1b7b      	subs	r3, r7, r5
10003ef6:	2601      	movs	r6, #1
10003ef8:	1c0d      	adds	r5, r1, #0
10003efa:	2400      	movs	r4, #0
10003efc:	e68e      	b.n	10003c1c <__aeabi_fsub+0x3c>
10003efe:	46c0      	nop			; (mov r8, r8)
10003f00:	fbffffff 	.word	0xfbffffff
10003f04:	03fffffc 	.word	0x03fffffc
10003f08:	2f00      	cmp	r7, #0
10003f0a:	d100      	bne.n	10003f0e <__aeabi_fsub+0x32e>
10003f0c:	e6fa      	b.n	10003d04 <__aeabi_fsub+0x124>
10003f0e:	2080      	movs	r0, #128	; 0x80
10003f10:	08eb      	lsrs	r3, r5, #3
10003f12:	03c4      	lsls	r4, r0, #15
10003f14:	4223      	tst	r3, r4
10003f16:	d037      	beq.n	10003f88 <__aeabi_fsub+0x3a8>
10003f18:	08ff      	lsrs	r7, r7, #3
10003f1a:	4227      	tst	r7, r4
10003f1c:	d134      	bne.n	10003f88 <__aeabi_fsub+0x3a8>
10003f1e:	1c3b      	adds	r3, r7, #0
10003f20:	1c0d      	adds	r5, r1, #0
10003f22:	2280      	movs	r2, #128	; 0x80
10003f24:	00db      	lsls	r3, r3, #3
10003f26:	0056      	lsls	r6, r2, #1
10003f28:	24ff      	movs	r4, #255	; 0xff
10003f2a:	e677      	b.n	10003c1c <__aeabi_fsub+0x3c>
10003f2c:	4663      	mov	r3, ip
10003f2e:	1c15      	adds	r5, r2, #0
10003f30:	2601      	movs	r6, #1
10003f32:	2400      	movs	r4, #0
10003f34:	e672      	b.n	10003c1c <__aeabi_fsub+0x3c>
10003f36:	4664      	mov	r4, ip
10003f38:	2c00      	cmp	r4, #0
10003f3a:	d014      	beq.n	10003f66 <__aeabi_fsub+0x386>
10003f3c:	2f00      	cmp	r7, #0
10003f3e:	d100      	bne.n	10003f42 <__aeabi_fsub+0x362>
10003f40:	e6e0      	b.n	10003d04 <__aeabi_fsub+0x124>
10003f42:	2380      	movs	r3, #128	; 0x80
10003f44:	08e6      	lsrs	r6, r4, #3
10003f46:	03d8      	lsls	r0, r3, #15
10003f48:	1c31      	adds	r1, r6, #0
10003f4a:	4206      	tst	r6, r0
10003f4c:	d003      	beq.n	10003f56 <__aeabi_fsub+0x376>
10003f4e:	08f9      	lsrs	r1, r7, #3
10003f50:	4201      	tst	r1, r0
10003f52:	d000      	beq.n	10003f56 <__aeabi_fsub+0x376>
10003f54:	1c31      	adds	r1, r6, #0
10003f56:	1c15      	adds	r5, r2, #0
10003f58:	2280      	movs	r2, #128	; 0x80
10003f5a:	00cb      	lsls	r3, r1, #3
10003f5c:	0056      	lsls	r6, r2, #1
10003f5e:	24ff      	movs	r4, #255	; 0xff
10003f60:	e65c      	b.n	10003c1c <__aeabi_fsub+0x3c>
10003f62:	28ff      	cmp	r0, #255	; 0xff
10003f64:	d1b1      	bne.n	10003eca <__aeabi_fsub+0x2ea>
10003f66:	2080      	movs	r0, #128	; 0x80
10003f68:	1c3b      	adds	r3, r7, #0
10003f6a:	1c15      	adds	r5, r2, #0
10003f6c:	0046      	lsls	r6, r0, #1
10003f6e:	24ff      	movs	r4, #255	; 0xff
10003f70:	e654      	b.n	10003c1c <__aeabi_fsub+0x3c>
10003f72:	3e01      	subs	r6, #1
10003f74:	2e00      	cmp	r6, #0
10003f76:	d1f4      	bne.n	10003f62 <__aeabi_fsub+0x382>
10003f78:	197b      	adds	r3, r7, r5
10003f7a:	1c04      	adds	r4, r0, #0
10003f7c:	e68e      	b.n	10003c9c <__aeabi_fsub+0xbc>
10003f7e:	1c3b      	adds	r3, r7, #0
10003f80:	1c15      	adds	r5, r2, #0
10003f82:	2601      	movs	r6, #1
10003f84:	2400      	movs	r4, #0
10003f86:	e649      	b.n	10003c1c <__aeabi_fsub+0x3c>
10003f88:	1c15      	adds	r5, r2, #0
10003f8a:	e7ca      	b.n	10003f22 <__aeabi_fsub+0x342>
10003f8c:	2b00      	cmp	r3, #0
10003f8e:	d100      	bne.n	10003f92 <__aeabi_fsub+0x3b2>
10003f90:	e72b      	b.n	10003dea <__aeabi_fsub+0x20a>
10003f92:	e7cc      	b.n	10003f2e <__aeabi_fsub+0x34e>

10003f94 <__aeabi_f2iz>:
10003f94:	0243      	lsls	r3, r0, #9
10003f96:	0042      	lsls	r2, r0, #1
10003f98:	0a59      	lsrs	r1, r3, #9
10003f9a:	0e13      	lsrs	r3, r2, #24
10003f9c:	0fc2      	lsrs	r2, r0, #31
10003f9e:	2000      	movs	r0, #0
10003fa0:	2b7e      	cmp	r3, #126	; 0x7e
10003fa2:	dd0d      	ble.n	10003fc0 <__aeabi_f2iz+0x2c>
10003fa4:	2b9d      	cmp	r3, #157	; 0x9d
10003fa6:	dc0c      	bgt.n	10003fc2 <__aeabi_f2iz+0x2e>
10003fa8:	2080      	movs	r0, #128	; 0x80
10003faa:	0400      	lsls	r0, r0, #16
10003fac:	4301      	orrs	r1, r0
10003fae:	2b95      	cmp	r3, #149	; 0x95
10003fb0:	dc0a      	bgt.n	10003fc8 <__aeabi_f2iz+0x34>
10003fb2:	2096      	movs	r0, #150	; 0x96
10003fb4:	1ac3      	subs	r3, r0, r3
10003fb6:	40d9      	lsrs	r1, r3
10003fb8:	4248      	negs	r0, r1
10003fba:	2a00      	cmp	r2, #0
10003fbc:	d100      	bne.n	10003fc0 <__aeabi_f2iz+0x2c>
10003fbe:	1c08      	adds	r0, r1, #0
10003fc0:	4770      	bx	lr
10003fc2:	4903      	ldr	r1, [pc, #12]	; (10003fd0 <__aeabi_f2iz+0x3c>)
10003fc4:	1850      	adds	r0, r2, r1
10003fc6:	e7fb      	b.n	10003fc0 <__aeabi_f2iz+0x2c>
10003fc8:	3b96      	subs	r3, #150	; 0x96
10003fca:	4099      	lsls	r1, r3
10003fcc:	e7f4      	b.n	10003fb8 <__aeabi_f2iz+0x24>
10003fce:	46c0      	nop			; (mov r8, r8)
10003fd0:	7fffffff 	.word	0x7fffffff

10003fd4 <__aeabi_ui2f>:
10003fd4:	b510      	push	{r4, lr}
10003fd6:	1e04      	subs	r4, r0, #0
10003fd8:	d034      	beq.n	10004044 <__aeabi_ui2f+0x70>
10003fda:	f000 f84f 	bl	1000407c <__clzsi2>
10003fde:	239e      	movs	r3, #158	; 0x9e
10003fe0:	1a1b      	subs	r3, r3, r0
10003fe2:	2b96      	cmp	r3, #150	; 0x96
10003fe4:	dc07      	bgt.n	10003ff6 <__aeabi_ui2f+0x22>
10003fe6:	3808      	subs	r0, #8
10003fe8:	4084      	lsls	r4, r0
10003fea:	0264      	lsls	r4, r4, #9
10003fec:	0a61      	lsrs	r1, r4, #9
10003fee:	b2db      	uxtb	r3, r3
10003ff0:	05d8      	lsls	r0, r3, #23
10003ff2:	4308      	orrs	r0, r1
10003ff4:	bd10      	pop	{r4, pc}
10003ff6:	2b99      	cmp	r3, #153	; 0x99
10003ff8:	dd0a      	ble.n	10004010 <__aeabi_ui2f+0x3c>
10003ffa:	1c02      	adds	r2, r0, #0
10003ffc:	321b      	adds	r2, #27
10003ffe:	1c21      	adds	r1, r4, #0
10004000:	4091      	lsls	r1, r2
10004002:	1c0a      	adds	r2, r1, #0
10004004:	1e51      	subs	r1, r2, #1
10004006:	418a      	sbcs	r2, r1
10004008:	2105      	movs	r1, #5
1000400a:	1a09      	subs	r1, r1, r0
1000400c:	40cc      	lsrs	r4, r1
1000400e:	4314      	orrs	r4, r2
10004010:	2805      	cmp	r0, #5
10004012:	dc1a      	bgt.n	1000404a <__aeabi_ui2f+0x76>
10004014:	4a18      	ldr	r2, [pc, #96]	; (10004078 <__aeabi_ui2f+0xa4>)
10004016:	210f      	movs	r1, #15
10004018:	4022      	ands	r2, r4
1000401a:	400c      	ands	r4, r1
1000401c:	2c04      	cmp	r4, #4
1000401e:	d000      	beq.n	10004022 <__aeabi_ui2f+0x4e>
10004020:	3204      	adds	r2, #4
10004022:	0151      	lsls	r1, r2, #5
10004024:	d505      	bpl.n	10004032 <__aeabi_ui2f+0x5e>
10004026:	249f      	movs	r4, #159	; 0x9f
10004028:	1a23      	subs	r3, r4, r0
1000402a:	2bff      	cmp	r3, #255	; 0xff
1000402c:	d021      	beq.n	10004072 <__aeabi_ui2f+0x9e>
1000402e:	4812      	ldr	r0, [pc, #72]	; (10004078 <__aeabi_ui2f+0xa4>)
10004030:	4002      	ands	r2, r0
10004032:	1c59      	adds	r1, r3, #1
10004034:	b2cc      	uxtb	r4, r1
10004036:	08d2      	lsrs	r2, r2, #3
10004038:	2c01      	cmp	r4, #1
1000403a:	dd09      	ble.n	10004050 <__aeabi_ui2f+0x7c>
1000403c:	0250      	lsls	r0, r2, #9
1000403e:	0a41      	lsrs	r1, r0, #9
10004040:	b2db      	uxtb	r3, r3
10004042:	e7d5      	b.n	10003ff0 <__aeabi_ui2f+0x1c>
10004044:	2300      	movs	r3, #0
10004046:	2100      	movs	r1, #0
10004048:	e7d2      	b.n	10003ff0 <__aeabi_ui2f+0x1c>
1000404a:	1f42      	subs	r2, r0, #5
1000404c:	4094      	lsls	r4, r2
1000404e:	e7e1      	b.n	10004014 <__aeabi_ui2f+0x40>
10004050:	2a00      	cmp	r2, #0
10004052:	d00b      	beq.n	1000406c <__aeabi_ui2f+0x98>
10004054:	2b00      	cmp	r3, #0
10004056:	d006      	beq.n	10004066 <__aeabi_ui2f+0x92>
10004058:	2180      	movs	r1, #128	; 0x80
1000405a:	03cc      	lsls	r4, r1, #15
1000405c:	4322      	orrs	r2, r4
1000405e:	0252      	lsls	r2, r2, #9
10004060:	0a51      	lsrs	r1, r2, #9
10004062:	b2db      	uxtb	r3, r3
10004064:	e7c4      	b.n	10003ff0 <__aeabi_ui2f+0x1c>
10004066:	0250      	lsls	r0, r2, #9
10004068:	0a41      	lsrs	r1, r0, #9
1000406a:	e7c1      	b.n	10003ff0 <__aeabi_ui2f+0x1c>
1000406c:	b2db      	uxtb	r3, r3
1000406e:	2100      	movs	r1, #0
10004070:	e7be      	b.n	10003ff0 <__aeabi_ui2f+0x1c>
10004072:	23ff      	movs	r3, #255	; 0xff
10004074:	2100      	movs	r1, #0
10004076:	e7bb      	b.n	10003ff0 <__aeabi_ui2f+0x1c>
10004078:	fbffffff 	.word	0xfbffffff

1000407c <__clzsi2>:
1000407c:	211c      	movs	r1, #28
1000407e:	2301      	movs	r3, #1
10004080:	041b      	lsls	r3, r3, #16
10004082:	4298      	cmp	r0, r3
10004084:	d301      	bcc.n	1000408a <__clzsi2+0xe>
10004086:	0c00      	lsrs	r0, r0, #16
10004088:	3910      	subs	r1, #16
1000408a:	0a1b      	lsrs	r3, r3, #8
1000408c:	4298      	cmp	r0, r3
1000408e:	d301      	bcc.n	10004094 <__clzsi2+0x18>
10004090:	0a00      	lsrs	r0, r0, #8
10004092:	3908      	subs	r1, #8
10004094:	091b      	lsrs	r3, r3, #4
10004096:	4298      	cmp	r0, r3
10004098:	d301      	bcc.n	1000409e <__clzsi2+0x22>
1000409a:	0900      	lsrs	r0, r0, #4
1000409c:	3904      	subs	r1, #4
1000409e:	a202      	add	r2, pc, #8	; (adr r2, 100040a8 <__clzsi2+0x2c>)
100040a0:	5c10      	ldrb	r0, [r2, r0]
100040a2:	1840      	adds	r0, r0, r1
100040a4:	4770      	bx	lr
100040a6:	46c0      	nop			; (mov r8, r8)
100040a8:	02020304 	.word	0x02020304
100040ac:	01010101 	.word	0x01010101
	...

Disassembly of section .VENEER_Code:

2000000c <HardFault_Veneer>:

/* ==================VENEERS VENEERS VENEERS VENEERS VENEERS=============== */
    .section ".XmcVeneerCode","ax",%progbits
.globl HardFault_Veneer
HardFault_Veneer:
    LDR R0, =HardFault_Handler
2000000c:	482c      	ldr	r0, [pc, #176]	; (200000c0 <BCCU0_0_Veneer+0x4>)
    MOV PC,R0
2000000e:	4687      	mov	pc, r0
	...

2000002c <SVC_Veneer>:
    .long 0
    
/* ======================================================================== */
.globl SVC_Veneer
SVC_Veneer:
    LDR R0, =SVC_Handler
2000002c:	4825      	ldr	r0, [pc, #148]	; (200000c4 <BCCU0_0_Veneer+0x8>)
    MOV PC,R0
2000002e:	4687      	mov	pc, r0
	...

20000038 <PendSV_Veneer>:
    .long 0
    .long 0
/* ======================================================================== */
.globl PendSV_Veneer
PendSV_Veneer:
    LDR R0, =PendSV_Handler
20000038:	4823      	ldr	r0, [pc, #140]	; (200000c8 <BCCU0_0_Veneer+0xc>)
    MOV PC,R0
2000003a:	4687      	mov	pc, r0

2000003c <SysTick_Veneer>:
/* ======================================================================== */
.globl SysTick_Veneer 
SysTick_Veneer:
    LDR R0, =SysTick_Handler
2000003c:	4823      	ldr	r0, [pc, #140]	; (200000cc <BCCU0_0_Veneer+0x10>)
    MOV PC,R0
2000003e:	4687      	mov	pc, r0

20000040 <SCU_0_Veneer>:
/* ======================================================================== */
.globl SCU_0_Veneer 
SCU_0_Veneer:
    LDR R0, =SCU_0_IRQHandler
20000040:	4823      	ldr	r0, [pc, #140]	; (200000d0 <BCCU0_0_Veneer+0x14>)
    MOV PC,R0
20000042:	4687      	mov	pc, r0

20000044 <SCU_1_Veneer>:
/* ======================================================================== */
.globl SCU_1_Veneer 
SCU_1_Veneer:
    LDR R0, =SCU_1_IRQHandler
20000044:	4823      	ldr	r0, [pc, #140]	; (200000d4 <BCCU0_0_Veneer+0x18>)
    MOV PC,R0
20000046:	4687      	mov	pc, r0

20000048 <SCU_2_Veneer>:
/* ======================================================================== */
.globl SCU_2_Veneer
SCU_2_Veneer:
    LDR R0, =SCU_2_IRQHandler
20000048:	4823      	ldr	r0, [pc, #140]	; (200000d8 <BCCU0_0_Veneer+0x1c>)
    MOV PC,R0
2000004a:	4687      	mov	pc, r0

2000004c <SCU_3_Veneer>:
/* ======================================================================== */
.globl SCU_3_Veneer 
SCU_3_Veneer:
    LDR R0, =ERU0_0_IRQHandler
2000004c:	4823      	ldr	r0, [pc, #140]	; (200000dc <BCCU0_0_Veneer+0x20>)
    MOV PC,R0
2000004e:	4687      	mov	pc, r0

20000050 <SCU_4_Veneer>:
/* ======================================================================== */
.globl SCU_4_Veneer 
SCU_4_Veneer:
    LDR R0, =ERU0_1_IRQHandler
20000050:	4823      	ldr	r0, [pc, #140]	; (200000e0 <BCCU0_0_Veneer+0x24>)
    MOV PC,R0
20000052:	4687      	mov	pc, r0

20000054 <SCU_5_Veneer>:
/* ======================================================================== */
.globl SCU_5_Veneer 
SCU_5_Veneer:
    LDR R0, =ERU0_2_IRQHandler
20000054:	4823      	ldr	r0, [pc, #140]	; (200000e4 <BCCU0_0_Veneer+0x28>)
    MOV PC,R0
20000056:	4687      	mov	pc, r0

20000058 <SCU_6_Veneer>:
/* ======================================================================== */
.globl SCU_6_Veneer 
SCU_6_Veneer:
    LDR R0, =ERU0_3_IRQHandler
20000058:	4823      	ldr	r0, [pc, #140]	; (200000e8 <BCCU0_0_Veneer+0x2c>)
    MOV PC,R0
2000005a:	4687      	mov	pc, r0
	...

20000064 <USIC0_0_Veneer>:
    .long 0
    .long 0
/* ======================================================================== */
.globl USIC0_0_Veneer
USIC0_0_Veneer:
    LDR R0, =USIC0_0_IRQHandler
20000064:	4821      	ldr	r0, [pc, #132]	; (200000ec <BCCU0_0_Veneer+0x30>)
    MOV PC,R0
20000066:	4687      	mov	pc, r0

20000068 <USIC0_1_Veneer>:
/* ======================================================================== */
.globl USIC0_1_Veneer
USIC0_1_Veneer:
    LDR R0, =USIC0_1_IRQHandler
20000068:	4821      	ldr	r0, [pc, #132]	; (200000f0 <BCCU0_0_Veneer+0x34>)
    MOV PC,R0
2000006a:	4687      	mov	pc, r0

2000006c <USIC0_2_Veneer>:
/* ======================================================================== */
.globl USIC0_2_Veneer
USIC0_2_Veneer:
    LDR R0, =USIC0_2_IRQHandler
2000006c:	4821      	ldr	r0, [pc, #132]	; (200000f4 <BCCU0_0_Veneer+0x38>)
    MOV PC,R0
2000006e:	4687      	mov	pc, r0

20000070 <USIC0_3_Veneer>:
/* ======================================================================== */
.globl USIC0_3_Veneer
USIC0_3_Veneer:
    LDR R0, =USIC0_3_IRQHandler
20000070:	4821      	ldr	r0, [pc, #132]	; (200000f8 <BCCU0_0_Veneer+0x3c>)
    MOV PC,R0
20000072:	4687      	mov	pc, r0

20000074 <USIC0_4_Veneer>:
/* ======================================================================== */
.globl USIC0_4_Veneer
USIC0_4_Veneer:
    LDR R0, =USIC0_4_IRQHandler
20000074:	4821      	ldr	r0, [pc, #132]	; (200000fc <BCCU0_0_Veneer+0x40>)
    MOV PC,R0
20000076:	4687      	mov	pc, r0

20000078 <USIC0_5_Veneer>:
/* ======================================================================== */
.globl USIC0_5_Veneer
USIC0_5_Veneer:
    LDR R0, =USIC0_5_IRQHandler
20000078:	4821      	ldr	r0, [pc, #132]	; (20000100 <BCCU0_0_Veneer+0x44>)
    MOV PC,R0
2000007a:	4687      	mov	pc, r0

2000007c <VADC0_C0_0_Veneer>:
/* ======================================================================== */
.globl VADC0_C0_0_Veneer 
VADC0_C0_0_Veneer:
    LDR R0, =VADC0_C0_0_IRQHandler
2000007c:	4821      	ldr	r0, [pc, #132]	; (20000104 <BCCU0_0_Veneer+0x48>)
    MOV PC,R0
2000007e:	4687      	mov	pc, r0

20000080 <VADC0_C0_1_Veneer>:
/* ======================================================================== */
.globl VADC0_C0_1_Veneer
VADC0_C0_1_Veneer:
    LDR R0, =VADC0_C0_1_IRQHandler
20000080:	4821      	ldr	r0, [pc, #132]	; (20000108 <BCCU0_0_Veneer+0x4c>)
    MOV PC,R0
20000082:	4687      	mov	pc, r0

20000084 <VADC0_G0_0_Veneer>:
/* ======================================================================== */
.globl VADC0_G0_0_Veneer
VADC0_G0_0_Veneer:
    LDR R0, =VADC0_G0_0_IRQHandler
20000084:	4821      	ldr	r0, [pc, #132]	; (2000010c <BCCU0_0_Veneer+0x50>)
    MOV PC,R0
20000086:	4687      	mov	pc, r0

20000088 <VADC0_G0_1_Veneer>:
/* ======================================================================== */
.globl VADC0_G0_1_Veneer
VADC0_G0_1_Veneer:
    LDR R0, =VADC0_G0_1_IRQHandler
20000088:	4821      	ldr	r0, [pc, #132]	; (20000110 <BCCU0_0_Veneer+0x54>)
    MOV PC,R0
2000008a:	4687      	mov	pc, r0

2000008c <VADC0_G1_0_Veneer>:
/* ======================================================================== */
.globl VADC0_G1_0_Veneer
VADC0_G1_0_Veneer:
    LDR R0, =VADC0_G1_0_IRQHandler
2000008c:	4821      	ldr	r0, [pc, #132]	; (20000114 <BCCU0_0_Veneer+0x58>)
    MOV PC,R0
2000008e:	4687      	mov	pc, r0

20000090 <VADC0_G1_1_Veneer>:
/* ======================================================================== */
.globl VADC0_G1_1_Veneer
VADC0_G1_1_Veneer:
    LDR R0, =VADC0_G1_1_IRQHandler
20000090:	4821      	ldr	r0, [pc, #132]	; (20000118 <BCCU0_0_Veneer+0x5c>)
    MOV PC,R0
20000092:	4687      	mov	pc, r0

20000094 <CCU40_0_Veneer>:
/* ======================================================================== */
.globl CCU40_0_Veneer
CCU40_0_Veneer:
    LDR R0, =CCU40_0_IRQHandler
20000094:	4821      	ldr	r0, [pc, #132]	; (2000011c <BCCU0_0_Veneer+0x60>)
    MOV PC,R0
20000096:	4687      	mov	pc, r0

20000098 <CCU40_1_Veneer>:
/* ======================================================================== */
.globl CCU40_1_Veneer
CCU40_1_Veneer:
    LDR R0, =CCU40_1_IRQHandler
20000098:	4821      	ldr	r0, [pc, #132]	; (20000120 <BCCU0_0_Veneer+0x64>)
    MOV PC,R0
2000009a:	4687      	mov	pc, r0

2000009c <CCU40_2_Veneer>:
/* ======================================================================== */
.globl CCU40_2_Veneer
CCU40_2_Veneer:
    LDR R0, =CCU40_2_IRQHandler
2000009c:	4821      	ldr	r0, [pc, #132]	; (20000124 <BCCU0_0_Veneer+0x68>)
    MOV PC,R0
2000009e:	4687      	mov	pc, r0

200000a0 <CCU40_3_Veneer>:
/* ======================================================================== */
.globl CCU40_3_Veneer
CCU40_3_Veneer:
    LDR R0, =CCU40_3_IRQHandler
200000a0:	4821      	ldr	r0, [pc, #132]	; (20000128 <BCCU0_0_Veneer+0x6c>)
    MOV PC,R0
200000a2:	4687      	mov	pc, r0
	...

200000b4 <LEDTS0_0_Veneer>:
    .long 0
    .long 0
/* ======================================================================== */
.globl LEDTS0_0_Veneer
LEDTS0_0_Veneer:
    LDR R0, =LEDTS0_0_IRQHandler
200000b4:	481d      	ldr	r0, [pc, #116]	; (2000012c <BCCU0_0_Veneer+0x70>)
    MOV PC,R0
200000b6:	4687      	mov	pc, r0

200000b8 <LEDTS1_0_Veneer>:
/* ======================================================================== */
.globl LEDTS1_0_Veneer
LEDTS1_0_Veneer:
    LDR R0, =LEDTS1_0_IRQHandler
200000b8:	481d      	ldr	r0, [pc, #116]	; (20000130 <BCCU0_0_Veneer+0x74>)
    MOV PC,R0
200000ba:	4687      	mov	pc, r0

200000bc <BCCU0_0_Veneer>:
/* ======================================================================== */
    .globl BCCU0_0_Veneer
BCCU0_0_Veneer:
    LDR R0, =BCCU0_0_IRQHandler
200000bc:	481d      	ldr	r0, [pc, #116]	; (20000134 <BCCU0_0_Veneer+0x78>)
    MOV PC,R0
200000be:	4687      	mov	pc, r0

/* ==================VENEERS VENEERS VENEERS VENEERS VENEERS=============== */
    .section ".XmcVeneerCode","ax",%progbits
.globl HardFault_Veneer
HardFault_Veneer:
    LDR R0, =HardFault_Handler
200000c0:	10001dd3 	.word	0x10001dd3
    .long 0
    
/* ======================================================================== */
.globl SVC_Veneer
SVC_Veneer:
    LDR R0, =SVC_Handler
200000c4:	10001dd5 	.word	0x10001dd5
    .long 0
    .long 0
/* ======================================================================== */
.globl PendSV_Veneer
PendSV_Veneer:
    LDR R0, =PendSV_Handler
200000c8:	10001dd7 	.word	0x10001dd7
    MOV PC,R0
/* ======================================================================== */
.globl SysTick_Veneer 
SysTick_Veneer:
    LDR R0, =SysTick_Handler
200000cc:	10001dd9 	.word	0x10001dd9
    MOV PC,R0
/* ======================================================================== */
.globl SCU_0_Veneer 
SCU_0_Veneer:
    LDR R0, =SCU_0_IRQHandler
200000d0:	10001ddb 	.word	0x10001ddb
    MOV PC,R0
/* ======================================================================== */
.globl SCU_1_Veneer 
SCU_1_Veneer:
    LDR R0, =SCU_1_IRQHandler
200000d4:	10001ddd 	.word	0x10001ddd
    MOV PC,R0
/* ======================================================================== */
.globl SCU_2_Veneer
SCU_2_Veneer:
    LDR R0, =SCU_2_IRQHandler
200000d8:	10001ddf 	.word	0x10001ddf
    MOV PC,R0
/* ======================================================================== */
.globl SCU_3_Veneer 
SCU_3_Veneer:
    LDR R0, =ERU0_0_IRQHandler
200000dc:	10001de1 	.word	0x10001de1
    MOV PC,R0
/* ======================================================================== */
.globl SCU_4_Veneer 
SCU_4_Veneer:
    LDR R0, =ERU0_1_IRQHandler
200000e0:	10001de3 	.word	0x10001de3
    MOV PC,R0
/* ======================================================================== */
.globl SCU_5_Veneer 
SCU_5_Veneer:
    LDR R0, =ERU0_2_IRQHandler
200000e4:	10001de5 	.word	0x10001de5
    MOV PC,R0
/* ======================================================================== */
.globl SCU_6_Veneer 
SCU_6_Veneer:
    LDR R0, =ERU0_3_IRQHandler
200000e8:	10001de7 	.word	0x10001de7
    .long 0
    .long 0
/* ======================================================================== */
.globl USIC0_0_Veneer
USIC0_0_Veneer:
    LDR R0, =USIC0_0_IRQHandler
200000ec:	10002b29 	.word	0x10002b29
    MOV PC,R0
/* ======================================================================== */
.globl USIC0_1_Veneer
USIC0_1_Veneer:
    LDR R0, =USIC0_1_IRQHandler
200000f0:	100013b5 	.word	0x100013b5
    MOV PC,R0
/* ======================================================================== */
.globl USIC0_2_Veneer
USIC0_2_Veneer:
    LDR R0, =USIC0_2_IRQHandler
200000f4:	10001a59 	.word	0x10001a59
    MOV PC,R0
/* ======================================================================== */
.globl USIC0_3_Veneer
USIC0_3_Veneer:
    LDR R0, =USIC0_3_IRQHandler
200000f8:	10001e03 	.word	0x10001e03
    MOV PC,R0
/* ======================================================================== */
.globl USIC0_4_Veneer
USIC0_4_Veneer:
    LDR R0, =USIC0_4_IRQHandler
200000fc:	10001e05 	.word	0x10001e05
    MOV PC,R0
/* ======================================================================== */
.globl USIC0_5_Veneer
USIC0_5_Veneer:
    LDR R0, =USIC0_5_IRQHandler
20000100:	10001e07 	.word	0x10001e07
    MOV PC,R0
/* ======================================================================== */
.globl VADC0_C0_0_Veneer 
VADC0_C0_0_Veneer:
    LDR R0, =VADC0_C0_0_IRQHandler
20000104:	10001de9 	.word	0x10001de9
    MOV PC,R0
/* ======================================================================== */
.globl VADC0_C0_1_Veneer
VADC0_C0_1_Veneer:
    LDR R0, =VADC0_C0_1_IRQHandler
20000108:	10001deb 	.word	0x10001deb
    MOV PC,R0
/* ======================================================================== */
.globl VADC0_G0_0_Veneer
VADC0_G0_0_Veneer:
    LDR R0, =VADC0_G0_0_IRQHandler
2000010c:	10001ded 	.word	0x10001ded
    MOV PC,R0
/* ======================================================================== */
.globl VADC0_G0_1_Veneer
VADC0_G0_1_Veneer:
    LDR R0, =VADC0_G0_1_IRQHandler
20000110:	10001def 	.word	0x10001def
    MOV PC,R0
/* ======================================================================== */
.globl VADC0_G1_0_Veneer
VADC0_G1_0_Veneer:
    LDR R0, =VADC0_G1_0_IRQHandler
20000114:	10001df1 	.word	0x10001df1
    MOV PC,R0
/* ======================================================================== */
.globl VADC0_G1_1_Veneer
VADC0_G1_1_Veneer:
    LDR R0, =VADC0_G1_1_IRQHandler
20000118:	10001df3 	.word	0x10001df3
    MOV PC,R0
/* ======================================================================== */
.globl CCU40_0_Veneer
CCU40_0_Veneer:
    LDR R0, =CCU40_0_IRQHandler
2000011c:	10001df5 	.word	0x10001df5
    MOV PC,R0
/* ======================================================================== */
.globl CCU40_1_Veneer
CCU40_1_Veneer:
    LDR R0, =CCU40_1_IRQHandler
20000120:	10001df7 	.word	0x10001df7
    MOV PC,R0
/* ======================================================================== */
.globl CCU40_2_Veneer
CCU40_2_Veneer:
    LDR R0, =CCU40_2_IRQHandler
20000124:	10001df9 	.word	0x10001df9
    MOV PC,R0
/* ======================================================================== */
.globl CCU40_3_Veneer
CCU40_3_Veneer:
    LDR R0, =CCU40_3_IRQHandler
20000128:	10001dfb 	.word	0x10001dfb
    .long 0
    .long 0
/* ======================================================================== */
.globl LEDTS0_0_Veneer
LEDTS0_0_Veneer:
    LDR R0, =LEDTS0_0_IRQHandler
2000012c:	10001e09 	.word	0x10001e09
    MOV PC,R0
/* ======================================================================== */
.globl LEDTS1_0_Veneer
LEDTS1_0_Veneer:
    LDR R0, =LEDTS1_0_IRQHandler
20000130:	10001e0b 	.word	0x10001e0b
    MOV PC,R0
/* ======================================================================== */
    .globl BCCU0_0_Veneer
BCCU0_0_Veneer:
    LDR R0, =BCCU0_0_IRQHandler
20000134:	10001e0d 	.word	0x10001e0d
