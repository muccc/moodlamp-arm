package CodeGenerator;

import java.util.*;
import com.ifx.davex.appjetinteract.App2JetInterface;

public class flash003c_template
{
  protected static String nl;
  public static synchronized flash003c_template create(String lineSeparator)
  {
    nl = lineSeparator;
    flash003c_template result = new flash003c_template();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = "/*CODE_BLOCK_BEGIN[FLASH003.c]*/" + NL + "" + NL + "/*******************************************************************************" + NL + "Copyright (c) 2014, Infineon Technologies AG                                  **" + NL + "All rights reserved.                                                          **" + NL + "                                                                              **" + NL + "Redistribution and use in source and binary forms, with or without            **" + NL + "modification,are permitted provided that the following conditions are met:    **" + NL + "                                                                              **" + NL + "*Redistributions of source code must retain the above copyright notice,       **" + NL + "this list of conditions and the following disclaimer.                         **" + NL + "*Redistributions in binary form must reproduce the above copyright notice,    **" + NL + "this list of conditions and the following disclaimer in the documentation     **" + NL + "and/or other materials provided with the distribution.                        **" + NL + "*Neither the name of the copyright holders nor the names of its contributors  **" + NL + "may be used to endorse or promote products derived from this software without ** " + NL + "specific prior written permission.                                            **" + NL + "                                                                              **" + NL + "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"   **" + NL + "AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE     **" + NL + "IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    **" + NL + "ARE  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE    **" + NL + "LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR          **" + NL + "CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF          **" + NL + "SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS     **" + NL + "INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN       **" + NL + "CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)        **" + NL + "ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE    **" + NL + "POSSIBILITY OF SUCH DAMAGE.                                                   **" + NL + "                                                                              **" + NL + "To improve the quality of the software, users are encouraged to share         **" + NL + "modifications, enhancements or bug fixes with Infineon Technologies AG        **" + NL + "dave@infineon.com).                                                           **" + NL + "                                                                              **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "**                                                                            **" + NL + "** PLATFORM : Infineon XMC1000 Series                                         **" + NL + "**                                                                            **" + NL + "** COMPILER : GCC                                                             **" + NL + "**                                                                            **" + NL + "** AUTHOR   : App Developer                                                   **" + NL + "**                                                                            **" + NL + "** MAY BE CHANGED BY USER [Yes/No]: Yes                                       **" + NL + "**                                                                            **" + NL + "** MODIFICATION DATE : Jan 06, 2014                                           **" + NL + "**                                                                            **" + NL + "*******************************************************************************/" + NL + "/* Revision History" + NL + " *****************************************************************************" + NL + " * Date          Version   Remarks" + NL + " * 28 June 2013  1.0.0     Initial Version" + NL + " * 28 Aug  2013  1.0.4     1.FLASH003_RegisterCallbackEvent," + NL + " *                           FLASH003_lEccInterrupt," + NL + " *                           FLASH003_lSeqInterrupt are added " + NL + " *                         2.Each api is edited to support Asynchronous mode" + NL + " *                           of Operation with interrupts." + NL + " *                         3.FLASH003_Read APIs are changed to read the data" + NL + " *                           with ECC errors also." + NL + " *                         4.Changed the naming convention of the ROM apis and" + NL + " * \t\t\t\t\t\t\t return status." + NL + " * 30 Oct  2013   1.0.6    1.In FLASH003_WriteMultipleBlocks()," + NL + " *                           FLASH003_WriteBlock() APIs corrected the macros to " + NL + " *                           read the Verification status from NVM_STATUS" + NL + " *                           Register." + NL + " *                         2.In FLASH003_Read APIs during checking for ECC " + NL + " *                           errors changed the condition check to return " + NL + " *                           Flash_error if any one is set." + NL + " * 27 Jan  2014   1.0.8    1.Defect fix 36939 :Whenever interrupts are enabled," + NL + " *                           the FLASH003_global_status is cleared if  wrong " + NL + " *                           parameter is passed as input to the APIs. " + NL + " *                         2.FLASH003_Init() changed to support auto " + NL + " *                           registration of the events configured in UI." + NL + " *                         3.FLASH003_RegisterCallbackEvent() api is changed to " + NL + " *                           support registration of 5 callbacks to each event." + NL + " */" + NL + "" + NL + "/**" + NL + " * @file FLASH003.c" + NL + " *" + NL + " * App Version FLASH003 <";
  protected final String TEXT_2 = ">" + NL + " *" + NL + " * @brief  Flash App implementation." + NL + " *" + NL + " */" + NL + "/*******************************************************************************" + NL + " ** INCLUDE FILES                                                             **" + NL + " ******************************************************************************/" + NL + "#include <DAVE3.h>" + NL + "#include \"../../inc/FLASH003/FLASH003_Conf.h\"" + NL + "/*******************************************************************************" + NL + "**                      Private Macro Definitions                             **" + NL + "*******************************************************************************/" + NL + "/*Macro to check the Block alignment of the input Address*/" + NL + "#define FLASH003_BLOCK_ALIGN_CHECK          0xFU" + NL + "/*Command for ONESHOT_WRITE_AUTOVERIFY*/" + NL + "#define FLASH003_ONESHOT_WRITE_AUTOVERIFY   0x51U" + NL + "/*Reset State*/" + NL + "#define FLASH003_RESET                      0x0000U" + NL + "/*Macro to check ECC and Verification error*/" + NL + "#define FLASH003_ECCVERRRST_IDLESET         0x3000U" + NL + "/*Delay of 10us for each block write*/" + NL + "#define FLASH003_DELAY                      0x2AAU" + NL + "/*Macro to check for NULL Event Handler*/" + NL + "#define FLASH003_NULL_HANDLER               0x0U" + NL + "/*Macro to check for Max. Call back Events*/" + NL + "#define FLASH003_MAX_CALLBACK               0x2U" + NL + "/*Macro to check the interrupt status*/" + NL + "#define FLASH003_INTR_ENABLED               0x1U" + NL + "/* ROM function Table */" + NL + "/*Start address of the ROM function table*/" + NL + "#define FLASH003_ROM_FUNCTION_TABLE_START   (0x00000100U)   " + NL + "/*Pointer to Erase Flash Page routine*/" + NL + "#define FLASH003_NvmErase            (FLASH003_ROM_FUNCTION_TABLE_START + 0x00U) " + NL + "/*Pointer to Erase, Program & Verify Flash Page routine*/" + NL + "#define FLASH003_NvmProgVerify       (FLASH003_ROM_FUNCTION_TABLE_START + 0x04U) " + NL + "/*Macro for Erase Flash Page routine*/" + NL + "#define FLASH003_NvmErasePage \\" + NL + "        (*((FLASH003_NVM_STATUS (**) (uint32_t * src_add)) FLASH003_NvmErase))" + NL + "/*Macro for ProgVerifyPage Flash Page routine*/" + NL + "#define FLASH003_NvmProgVerifyPage \\" + NL + "        (*((FLASH003_NVM_STATUS (**) (uint32_t * src_add, uint32_t * dst_add))\\" + NL + "        FLASH003_NvmProgVerify))" + NL + "/*******************************************************************************" + NL + "**                      Private Type Definitions                              **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                 Private Function Declarations                              **" + NL + "*******************************************************************************/" + NL + "/*Local function to write the Block of Data*/" + NL + "void FLASH003_lWriteBlock (uint32_t Address, const uint32_t pBuf[]);" + NL + "#if (FLASH003_SEQ_INTERRUPT == FLASH003_INTR_ENABLED)" + NL + "/*Local Handler for End of Sequence event to register with NVIC_SR001 App*/" + NL + "void FLASH003_lSeqInterrupt(uint32_t cbargs);" + NL + "#endif" + NL + "#if (FLASH003_ECC_INTERRUPT == FLASH003_INTR_ENABLED)" + NL + "/*Local Handler for ECC event to register with NVIC_SR001 App*/" + NL + "void FLASH003_lEccInterrupt(uint32_t cbargs);" + NL + "#endif" + NL + "/*******************************************************************************" + NL + "**                      Extern Declaration                                    **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Global Constant Definitions                           **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Global Variable Definitions                           **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Private Constant Definitions                          **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Private Function Definitions                          **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Public Function Definitions                           **" + NL + "*******************************************************************************/" + NL + "" + NL + "void FLASH003_Init()" + NL + "{";
  protected final String TEXT_3 = NL + "\tconst FLASH003_HandleType* Handle;" + NL + "\tHandle = &FLASH003_Handle";
  protected final String TEXT_4 = ";" + NL + "    /*Enabling flash Idle State*/" + NL + "\tHandle->FlashRegsPtr->NVMPROG = FLASH003_ECCVERRRST_IDLESET;" + NL + "    /*reset ECC2READ,ECC1READ in NVMSTATUS*/" + NL + "    SET_BIT(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_RSTECC_Pos);" + NL + "    /*reset Write protocol error in NVMSTATUS*/" + NL + "    SET_BIT(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_RSTVERR_Pos);" + NL + "" + NL + "\t#if (FLASH003_SEQ_INTERRUPT == FLASH003_INTR_ENABLED)" + NL + "\tFLASH003_RegisterCallbackEvent(FLASH003_FLCMPLTI,FLASH003_SEQ_EVENT,0);" + NL + "\tNVIC_SR001_RegisterCallback(NVIC_SR001_FLCMPLTI,FLASH003_lSeqInterrupt,0U);" + NL + "\t#endif" + NL + "    #if (FLASH003_ECC_INTERRUPT == FLASH003_INTR_ENABLED)" + NL + "\tFLASH003_RegisterCallbackEvent(FLASH003_FLECC2I,FLASH003_ECC_EVENT,0);" + NL + "\tNVIC_SR001_RegisterCallback(NVIC_SR001_FLECC2I,FLASH003_lEccInterrupt,0U);" + NL + "\t#endif" + NL + "\t";
  protected final String TEXT_5 = " /*This app is not mapped to any NVM module*/ ";
  protected final String TEXT_6 = NL + "}" + NL + "/*" + NL + " *  This function executes a 'Clear Status' Command" + NL + " *  A clear status command clears all error flags in the " + NL + " *  flash status register. " + NL + " */" + NL + "void FLASH003_ClearStatus(void)" + NL + "{" + NL + "\tconst FLASH003_HandleType* Handle;" + NL + "\tHandle = &FLASH003_Handle";
  protected final String TEXT_7 = ";" + NL + "\t/*clear error status*/" + NL + "    /*reset ECC2READ,ECC1READ in NVMSTATUS*/" + NL + "    SET_BIT(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_RSTECC_Pos);" + NL + "    /*reset Write protocol error in NVMSTATUS*/" + NL + "    SET_BIT(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_RSTVERR_Pos);" + NL + "}" + NL + "/*" + NL + " *  The function programs one Block of the Flash using" + NL + " *  WriteBlock command" + NL + " */" + NL + "status_t FLASH003_WriteBlock (uint32_t Address, const uint32_t pBuf[])" + NL + "{" + NL + "    FLASH003Status_Type status;" + NL + "\tconst FLASH003_HandleType* Handle;" + NL + "    uint32_t rd1;" + NL + "    uint32_t rd2;" + NL + "    uint32_t rd3;" + NL + "" + NL + "    #if (FLASH003_SEQ_INTERRUPT == FLASH003_INTR_ENABLED)" + NL + "      FLASH003_DynamicHandleType* DynamicHandle;" + NL + "      DynamicHandle = &FLASH003_DynamicHandle";
  protected final String TEXT_8 = ";" + NL + "      /*no of blocks will be only one,so while interrupt is called user handler " + NL + "        has to be called at first time itself*/" + NL + "      DynamicHandle->FLASH003_Blk_Cnt = 0U;" + NL + "      if(DynamicHandle->FLASH003_global_status != FLASH003_IDLE)" + NL + "      {" + NL + "        DynamicHandle->FLASH003_global_status = FLASH003_ERROR;" + NL + "      }" + NL + "      else" + NL + "    #endif" + NL + "      {" + NL + "    #if (FLASH003_SEQ_INTERRUPT == FLASH003_INTR_ENABLED)" + NL + "      DynamicHandle->FLASH003_global_status = FLASH003_IN_PROGRESS;" + NL + "    #endif" + NL + "      Handle = &FLASH003_Handle";
  protected final String TEXT_9 = ";" + NL + "      status = FLASH003_IN_PROGRESS;" + NL + "      " + NL + "      rd1 = RD_REG(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_ACTION_Msk,\\" + NL + "    \t\t                                            NVM_NVMPROG_ACTION_Pos);" + NL + "      rd2 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_BUSY_Msk,\\" + NL + "    \t\t                                            NVM_NVMSTATUS_BUSY_Pos);" + NL + "      rd3 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_SLEEP_Msk,\\" + NL + "    \t\t                                           NVM_NVMSTATUS_SLEEP_Pos);" + NL + "     /* <<<DD_FLASH003_API_3>>> */" + NL + "     /*validate the Address for Range and Block Alignment*/" + NL + "      if((Address < Handle->kStart_Address) || (Address > Handle->kEnd_Address)\\" + NL + "    \t\t                  || ((Address & FLASH003_BLOCK_ALIGN_CHECK) != 0U))" + NL + "      {" + NL + "        status = FLASH003_INVALID_ADDRESS;" + NL + "\t\t#if (FLASH003_SEQ_INTERRUPT == FLASH003_INTR_ENABLED)" + NL + "            DynamicHandle->FLASH003_global_status = FLASH003_IDLE;" + NL + "        #endif" + NL + "      }" + NL + "      /*Checking for the status of Flash for Idle and Sleep Mode*/" + NL + "      else if((rd1 == FLASH003_RESET) && (rd2 == FLASH003_RESET) && \\" + NL + "                                                        (rd3 == FLASH003_RESET))" + NL + "      {" + NL + "        /*Calling Write Block API*/" + NL + "        FLASH003_lWriteBlock (Address, pBuf);" + NL + "        /*Checking for verification flag for any writing errors*/" + NL + "        if(RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_VERR_Msk,\\" + NL + "        \t\t                      NVM_NVMSTATUS_VERR_Pos) == FLASH003_RESET)" + NL + "        {" + NL + "          status = FLASH003_COMPLETE;" + NL + "        }" + NL + "        else" + NL + "        {" + NL + "          status = FLASH003_ERROR;" + NL + "\t\t  /* need to be checked whether required or not*/" + NL + "\t\t  #if (FLASH003_SEQ_INTERRUPT == FLASH003_INTR_ENABLED)" + NL + "             DynamicHandle->FLASH003_global_status = FLASH003_IDLE;" + NL + "          #endif" + NL + "        }" + NL + "      }" + NL + "      else" + NL + "      {" + NL + "        status = FLASH003_ERROR;" + NL + "\t\t#if (FLASH003_SEQ_INTERRUPT == FLASH003_INTR_ENABLED)" + NL + "            DynamicHandle->FLASH003_global_status = FLASH003_IDLE;" + NL + "        #endif" + NL + "      }" + NL + "   }" + NL + "    return (uint32_t)status;" + NL + "}" + NL + "" + NL + "/*" + NL + " *  The function programs Multiple No_of_Blocks of the Flash using" + NL + " *  WriteMultipleBlocks command" + NL + " */" + NL + "status_t FLASH003_WriteMultipleBlocks(uint32_t Address,const uint32_t pBuf[],\\" + NL + "                                                          uint32_t No_of_Blocks)" + NL + "{" + NL + "    FLASH003Status_Type status;" + NL + "\tconst FLASH003_HandleType* Handle;" + NL + "\t" + NL + "    uint32_t lBlk_Cnt;" + NL + "    uint32_t lAddress;" + NL + "    uint32_t rd1;" + NL + "    uint32_t rd2;" + NL + "    uint32_t rd3;" + NL + "    /*This is to check weather the last byte of data is crossing the max limit" + NL + "     *of the flash or not." + NL + "     */" + NL + "    uint32_t final_blk_end_add;" + NL + "    " + NL + "    #if (FLASH003_SEQ_INTERRUPT == FLASH003_INTR_ENABLED)" + NL + "      FLASH003_DynamicHandleType* DynamicHandle;" + NL + "      DynamicHandle = &FLASH003_DynamicHandle";
  protected final String TEXT_10 = ";" + NL + "      DynamicHandle->FLASH003_Blk_Cnt = No_of_Blocks;" + NL + "      if(DynamicHandle->FLASH003_global_status != FLASH003_IDLE)" + NL + "      {" + NL + "        DynamicHandle->FLASH003_global_status = FLASH003_ERROR;" + NL + "      }" + NL + "      else" + NL + "    #endif" + NL + "      {" + NL + "    #if (FLASH003_SEQ_INTERRUPT == FLASH003_INTR_ENABLED)" + NL + "      DynamicHandle->FLASH003_global_status = FLASH003_IN_PROGRESS;" + NL + "    #endif" + NL + "      Handle = &FLASH003_Handle";
  protected final String TEXT_11 = ";" + NL + "      status = FLASH003_IN_PROGRESS;" + NL + "      /*calculation of the last byte address*/" + NL + "      final_blk_end_add = (uint32_t)((uint32_t)Address + \\" + NL + "                    (uint32_t)(No_of_Blocks*FLASH003_BLOCK_SIZE)) - 1U;" + NL + "      rd1 = RD_REG(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_ACTION_Msk,\\" + NL + "    \t\t                                            NVM_NVMPROG_ACTION_Pos);" + NL + "      rd2 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_BUSY_Msk,\\" + NL + "    \t\t                                            NVM_NVMSTATUS_BUSY_Pos);" + NL + "      rd3 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_SLEEP_Msk,\\" + NL + "    \t\t                                           NVM_NVMSTATUS_SLEEP_Pos);" + NL + "      /*validate the Address for Range and Block Alignment*/" + NL + "      if((Address < Handle->kStart_Address) || (Address > Handle->kEnd_Address)\\" + NL + "    \t\t                  || (final_blk_end_add > Handle->kEnd_Address) || \\" + NL + "                                 ((Address & FLASH003_BLOCK_ALIGN_CHECK) != 0U))" + NL + "      {" + NL + "        status = FLASH003_INVALID_ADDRESS;" + NL + "\t\t#if (FLASH003_SEQ_INTERRUPT == FLASH003_INTR_ENABLED)" + NL + "            DynamicHandle->FLASH003_global_status = FLASH003_IDLE;" + NL + "        #endif" + NL + "      }" + NL + "      /*Checking for the status of Flash for Idle and Sleep Mode*/" + NL + "      else if((rd1 == FLASH003_RESET) && (rd2 == FLASH003_RESET) && \\" + NL + "             (rd3 == FLASH003_RESET))" + NL + "      {" + NL + "        for(lBlk_Cnt = 0U;lBlk_Cnt < (uint32_t)No_of_Blocks;lBlk_Cnt++)" + NL + "        {" + NL + "          /*Updating the Address for each Block*/" + NL + "          lAddress = Address+(FLASH003_BLOCK_SIZE*lBlk_Cnt);" + NL + "          /*Calling Write Block API*/" + NL + "          FLASH003_lWriteBlock (lAddress, pBuf+(FLASH003_WORD_SIZE*lBlk_Cnt));" + NL + "          /*Checking for verification flag for any writing errors*/" + NL + "          if(RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_VERR_Msk,\\" + NL + "        \t\t                      NVM_NVMSTATUS_VERR_Pos) == FLASH003_RESET)" + NL + "          {" + NL + "            status = FLASH003_COMPLETE;" + NL + "          }" + NL + "          else" + NL + "          {" + NL + "            status = FLASH003_ERROR;" + NL + "\t\t\t#if (FLASH003_SEQ_INTERRUPT == FLASH003_INTR_ENABLED)" + NL + "                DynamicHandle->FLASH003_global_status = FLASH003_IDLE;" + NL + "            #endif" + NL + "            break;" + NL + "          }" + NL + "        }" + NL + "      }" + NL + "      else" + NL + "      {" + NL + "        status = FLASH003_ERROR;" + NL + "\t\t#if (FLASH003_SEQ_INTERRUPT == FLASH003_INTR_ENABLED)" + NL + "            DynamicHandle->FLASH003_global_status = FLASH003_IDLE;" + NL + "        #endif" + NL + "      }" + NL + "    }" + NL + "    return (uint32_t)status;" + NL + "}" + NL + "/*" + NL + " *  The function is local to Flash app " + NL + " *  used to write the block of data" + NL + " */" + NL + "void FLASH003_lWriteBlock (uint32_t Address, const uint32_t pBuf[])" + NL + "{" + NL + "    uint32_t lWord_Cnt;" + NL + "    const FLASH003_HandleType* Handle;" + NL + "\tHandle = &FLASH003_Handle";
  protected final String TEXT_12 = ";" + NL + "    /*updating the ACTION with Oneshot Write and Auto Verify*/" + NL + "    WR_REG(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_ACTION_Msk,\\" + NL + "    \t\t          NVM_NVMPROG_ACTION_Pos,FLASH003_ONESHOT_WRITE_AUTOVERIFY);" + NL + "    /*Writing a Block of Data*/" + NL + "    for(lWord_Cnt = 0U;lWord_Cnt < FLASH003_WORD_SIZE;lWord_Cnt++)" + NL + "    {" + NL + "      *((uint32_t *) (Address + (FLASH003_WORD_SIZE * lWord_Cnt) )) = \\" + NL + "                                                                pBuf[lWord_Cnt];" + NL + "    }" + NL + "" + NL + "    #if (FLASH003_SEQ_INTERRUPT != FLASH003_INTR_ENABLED)" + NL + "    /*Polling Busy Flag until Idle State*/" + NL + "    while(RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_BUSY_Msk,\\" + NL + "    \t\t                          NVM_NVMSTATUS_BUSY_Pos) != FLASH003_RESET)" + NL + "    {" + NL + "      ;" + NL + "    }" + NL + "    /*Wait for 10us to complete the verification(need to check)*/" + NL + "    WR_REG(SCU_CLK->CLKCR, SCU_CLK_CLKCR_CNTADJ_Msk, SCU_CLK_CLKCR_CNTADJ_Pos,\\" + NL + "                                                            FLASH003_DELAY);" + NL + "    while (SCU_CLK->CLKCR&(SCU_CLK_CLKCR_VDDC2LOW_Msk))" + NL + "    {" + NL + "      ;" + NL + "    }" + NL + "    #endif" + NL + "}" + NL + "/*" + NL + " *  The function uses the ROM api to Erase " + NL + " *  the one page of data" + NL + " */" + NL + "status_t FLASH003_ErasePage (uint32_t Address)" + NL + "{" + NL + "    FLASH003Status_Type status;" + NL + "    FLASH003_NVM_STATUS lstatus;" + NL + "\tconst FLASH003_HandleType* Handle;" + NL + "" + NL + "\t#if (FLASH003_SEQ_INTERRUPT == FLASH003_INTR_ENABLED)" + NL + "      FLASH003_DynamicHandleType* DynamicHandle;" + NL + "      DynamicHandle = &FLASH003_DynamicHandle";
  protected final String TEXT_13 = ";" + NL + "      if(DynamicHandle->FLASH003_global_status != FLASH003_IDLE)" + NL + "      {" + NL + "        DynamicHandle->FLASH003_global_status = FLASH003_ERROR;" + NL + "      }" + NL + "      else" + NL + "    #endif" + NL + "      {" + NL + "    #if (FLASH003_SEQ_INTERRUPT == FLASH003_INTR_ENABLED)" + NL + "      DynamicHandle->FLASH003_global_status = FLASH003_IN_PROGRESS;" + NL + "    #endif" + NL + "      status = FLASH003_IN_PROGRESS;" + NL + "      lstatus = FLASH003_NVM_E_FAIL;" + NL + "\t  Handle = &FLASH003_Handle";
  protected final String TEXT_14 = ";" + NL + "\t" + NL + "      /*validate the Address Range*/" + NL + "      if((Address < Handle->kStart_Address) || (Address > Handle->kEnd_Address))" + NL + "      {" + NL + "      \t status = FLASH003_INVALID_ADDRESS;" + NL + "  \t\t #if (FLASH003_SEQ_INTERRUPT == FLASH003_INTR_ENABLED)" + NL + "  \t\t\tDynamicHandle->FLASH003_global_status = FLASH003_IDLE;" + NL + "  \t\t #endif" + NL + "      }" + NL + "      else" + NL + "      {" + NL + "\t\t  /*Calling ROM API to Erase a Page*/" + NL + "\t\t  lstatus = FLASH003_NvmErasePage((uint32_t *)Address);" + NL + "\t\t  /*Mapping different status returned by ROM Api to Standard Return*/" + NL + "\t\t  if(lstatus == FLASH003_NVM_PASS)" + NL + "\t\t  {" + NL + "\t\t\tstatus = FLASH003_COMPLETE;" + NL + "\t\t  }" + NL + "\t\t  else if((lstatus == FLASH003_NVM_E_FAIL) ||" + NL + "\t\t\t\t (lstatus == FLASH003_NVM_E_NVM_FAIL) || \\" + NL + "\t\t\t\t (lstatus == FLASH003_NVM_E_VERIFY))" + NL + "\t\t  {" + NL + "\t\t\tstatus = FLASH003_ERROR;" + NL + "\t\t\t#if (FLASH003_SEQ_INTERRUPT == FLASH003_INTR_ENABLED)" + NL + "\t\t\t\tDynamicHandle->FLASH003_global_status = FLASH003_IDLE;" + NL + "\t\t\t#endif" + NL + "\t\t  }" + NL + "\t\t  else" + NL + "\t\t  {" + NL + "\t\t\tstatus = FLASH003_INVALID_ADDRESS;" + NL + "\t\t\t#if (FLASH003_SEQ_INTERRUPT == FLASH003_INTR_ENABLED)" + NL + "\t\t\t\tDynamicHandle->FLASH003_global_status = FLASH003_IDLE;" + NL + "\t\t\t#endif" + NL + "\t\t  }" + NL + "      }" + NL + "    }" + NL + "    return (uint32_t)status;" + NL + "}" + NL + "/*" + NL + " *  The function uses the ROM api to Program one Page " + NL + " *  which will Erase,Write and Verify" + NL + " */" + NL + "status_t FLASH003_ProgVerifyPage (uint32_t dstAddress,const uint32_t pBuf[])" + NL + "{" + NL + "    FLASH003Status_Type status;" + NL + "    FLASH003_NVM_STATUS lstatus;" + NL + "\tconst FLASH003_HandleType* Handle;" + NL + "" + NL + "    #if (FLASH003_SEQ_INTERRUPT == FLASH003_INTR_ENABLED)" + NL + "      FLASH003_DynamicHandleType* DynamicHandle;" + NL + "      DynamicHandle = &FLASH003_DynamicHandle";
  protected final String TEXT_15 = ";" + NL + "      DynamicHandle->FLASH003_Blk_Cnt = FLASH003_BLOCK_SIZE;" + NL + "" + NL + "      if(DynamicHandle->FLASH003_global_status != FLASH003_IDLE)" + NL + "      {" + NL + "        DynamicHandle->FLASH003_global_status = FLASH003_ERROR;" + NL + "      }" + NL + "      else" + NL + "    #endif" + NL + "      {" + NL + "    #if (FLASH003_SEQ_INTERRUPT == FLASH003_INTR_ENABLED)" + NL + "      DynamicHandle->FLASH003_global_status = FLASH003_IN_PROGRESS;" + NL + "    #endif" + NL + "      lstatus = FLASH003_NVM_E_FAIL;" + NL + "      status = FLASH003_IN_PROGRESS;" + NL + "      Handle = &FLASH003_Handle";
  protected final String TEXT_16 = ";" + NL + "    " + NL + "      /*validate the Address Range*/" + NL + "      if((dstAddress < Handle->kStart_Address) || (dstAddress > Handle->kEnd_Address))" + NL + "      {" + NL + "    \t  status = FLASH003_INVALID_ADDRESS;" + NL + "\t\t  #if (FLASH003_SEQ_INTERRUPT == FLASH003_INTR_ENABLED)" + NL + "\t\t\tDynamicHandle->FLASH003_global_status = FLASH003_IDLE;" + NL + "\t\t  #endif" + NL + "      }" + NL + "      else" + NL + "      {" + NL + "          /*Calling ROM API to Program a Page*/" + NL + "          lstatus = FLASH003_NvmProgVerifyPage((uint32_t *)pBuf ,\\" + NL + "                                                        (uint32_t *)dstAddress);" + NL + "          /*Mapping the status returned by ROM Api to Standard Return Defined*/" + NL + "          if(lstatus == FLASH003_NVM_PASS)" + NL + "          {" + NL + "            status = FLASH003_COMPLETE;" + NL + "          }" + NL + "          else if((lstatus == FLASH003_NVM_E_FAIL) ||\\" + NL + "                  (lstatus == FLASH003_NVM_E_NVM_FAIL) || \\" + NL + "                  (lstatus == FLASH003_NVM_E_VERIFY))" + NL + "          {" + NL + "            status = FLASH003_ERROR;" + NL + "    \t\t#if (FLASH003_SEQ_INTERRUPT == FLASH003_INTR_ENABLED)" + NL + "                DynamicHandle->FLASH003_global_status = FLASH003_IDLE;" + NL + "            #endif" + NL + "          }" + NL + "          else" + NL + "          {" + NL + "            status = FLASH003_INVALID_ADDRESS;" + NL + "    \t\t#if (FLASH003_SEQ_INTERRUPT == FLASH003_INTR_ENABLED)" + NL + "                DynamicHandle->FLASH003_global_status = FLASH003_IDLE;" + NL + "            #endif" + NL + "          }" + NL + "      }" + NL + "    }" + NL + "    return (uint32_t)status;" + NL + "}" + NL + "/*" + NL + " * This function used to read a word" + NL + " * from the specified address" + NL + " */" + NL + "status_t FLASH003_ReadWord(uint32_t Address,uint32_t* buf)" + NL + "{" + NL + "    FLASH003Status_Type status;" + NL + "\tconst FLASH003_HandleType* Handle;" + NL + "    uint32_t rd1;" + NL + "    uint32_t rd2;" + NL + "    uint32_t rd3;" + NL + "" + NL + "\tHandle = &FLASH003_Handle";
  protected final String TEXT_17 = ";" + NL + "    status = FLASH003_IN_PROGRESS;" + NL + "    rd1 = RD_REG(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_ACTION_Msk,\\" + NL + "    \t\t                                            NVM_NVMPROG_ACTION_Pos);" + NL + "    rd2 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_BUSY_Msk,\\" + NL + "    \t\t                                            NVM_NVMSTATUS_BUSY_Pos);" + NL + "    rd3 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_SLEEP_Msk,\\" + NL + "    \t\t                                           NVM_NVMSTATUS_SLEEP_Pos);" + NL + "    /*validate the Address for Range*/" + NL + "    if ((Address < Handle->kStart_Address) || (Address > Handle->kEnd_Address))" + NL + "    {" + NL + "      status = FLASH003_INVALID_ADDRESS;" + NL + "    }" + NL + "    /*Checking for the status of Flash for Idle and Sleep Mode*/" + NL + "    else if((rd1 == FLASH003_RESET) && (rd2 == FLASH003_RESET) && \\" + NL + "            (rd3 == FLASH003_RESET))" + NL + "    {" + NL + "      /* reads one word*/" + NL + "      *buf = *((uint32_t*)Address);" + NL + "      status = FLASH003_COMPLETE;" + NL + "        " + NL + "      rd1 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_ECC1READ_Msk,\\" + NL + "    \t\t                                        NVM_NVMSTATUS_ECC1READ_Pos);" + NL + "      rd2 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_ECC2READ_Msk,\\" + NL + "    \t\t                                        NVM_NVMSTATUS_ECC2READ_Pos); " + NL + "      /*Checking for ECC error flags*/" + NL + "      if((rd1 != FLASH003_RESET) || (rd2 != FLASH003_RESET))" + NL + "      {" + NL + "        status = FLASH003_ERROR;" + NL + "      }" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      status = FLASH003_ERROR;" + NL + "    }" + NL + "  return (uint32_t)status;" + NL + "}" + NL + "/*" + NL + " * This function used to read the Block " + NL + " * from the specified address" + NL + " */" + NL + "status_t FLASH003_ReadBlock(uint32_t Address,uint32_t buf[])" + NL + "{" + NL + "    FLASH003Status_Type status;" + NL + "    uint32_t lWord_Cnt;" + NL + "\tconst FLASH003_HandleType* Handle;" + NL + "    uint32_t rd1;" + NL + "    uint32_t rd2;" + NL + "    uint32_t rd3;" + NL + "    status = FLASH003_IN_PROGRESS;" + NL + "\tHandle = &FLASH003_Handle";
  protected final String TEXT_18 = ";" + NL + "" + NL + "    rd1 = RD_REG(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_ACTION_Msk,\\" + NL + "    \t\t                                            NVM_NVMPROG_ACTION_Pos);" + NL + "    rd2 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_BUSY_Msk,\\" + NL + "    \t\t                                            NVM_NVMSTATUS_BUSY_Pos);" + NL + "    rd3 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_SLEEP_Msk,\\" + NL + "    \t\t                                           NVM_NVMSTATUS_SLEEP_Pos);" + NL + "    /*validate the Address for Range and Block Alignment*/" + NL + "    if ((Address < Handle->kStart_Address) || (Address > Handle->kEnd_Address) \\" + NL + "    \t\t                  || ((Address & FLASH003_BLOCK_ALIGN_CHECK) != 0U))" + NL + "    {" + NL + "      status = FLASH003_INVALID_ADDRESS;" + NL + "    }" + NL + "    /*Checking for the status of Flash for Idle and Sleep Mode*/" + NL + "    else if((rd1 == FLASH003_RESET) && (rd2 == FLASH003_RESET) && \\" + NL + "           (rd3 == FLASH003_RESET))" + NL + "    {" + NL + "      /* reads one Block*/  " + NL + "      for(lWord_Cnt = 0U;lWord_Cnt < (uint32_t)FLASH003_WORD_SIZE;lWord_Cnt++)" + NL + "      {" + NL + "        /* reads one word*/" + NL + "        *(buf + lWord_Cnt) = *((uint32_t*)Address + lWord_Cnt);" + NL + "        status = FLASH003_COMPLETE;" + NL + "      }" + NL + "      " + NL + "      rd1 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,\\" + NL + "            NVM_NVMSTATUS_ECC1READ_Msk,NVM_NVMSTATUS_ECC1READ_Pos);" + NL + "      rd2 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,\\" + NL + "            NVM_NVMSTATUS_ECC2READ_Msk,NVM_NVMSTATUS_ECC2READ_Pos);" + NL + "      /*Checking for ECC error flags*/" + NL + "      if((rd1 != FLASH003_RESET) || (rd2 != FLASH003_RESET))" + NL + "      {" + NL + "        status = FLASH003_ERROR;" + NL + "      }" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      status = FLASH003_ERROR;" + NL + "    }" + NL + "  return (uint32_t)status;" + NL + "}" + NL + "/*" + NL + " * This function used to read the No_of_bytes" + NL + " * from the specified address" + NL + " */" + NL + "status_t FLASH003_ReadBytes(uint32_t Address, uint8_t buf[],\\" + NL + "                                                        uint32_t No_of_bytes)" + NL + "{" + NL + "    FLASH003Status_Type status;" + NL + "\tconst FLASH003_HandleType* Handle;" + NL + "    uint32_t lByte_Cnt;" + NL + "    uint32_t rd1;" + NL + "    uint32_t rd2;" + NL + "    uint32_t rd3;" + NL + "\tHandle = &FLASH003_Handle";
  protected final String TEXT_19 = ";" + NL + "" + NL + "    /*This is to check weather the last byte of data is crossing the max limit" + NL + "     *of the flash or not." + NL + "     */" + NL + "    uint32_t final_add_location;" + NL + "    status = FLASH003_IN_PROGRESS;" + NL + "    /*calculation of the last byte address*/" + NL + "    final_add_location = (uint32_t)((uint32_t)Address + \\" + NL + "                                      (uint32_t)No_of_bytes) - 1U;" + NL + "" + NL + "    rd1 = RD_REG(Handle->FlashRegsPtr->NVMPROG,NVM_NVMPROG_ACTION_Msk,\\" + NL + "    \t\t                                            NVM_NVMPROG_ACTION_Pos);" + NL + "    rd2 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_BUSY_Msk,\\" + NL + "    \t\t                                            NVM_NVMSTATUS_BUSY_Pos);" + NL + "    rd3 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_SLEEP_Msk,\\" + NL + "    \t\t                                           NVM_NVMSTATUS_SLEEP_Pos);" + NL + "    /*validate the Address for Range and Block Alignment*/" + NL + "    if ((Address < Handle->kStart_Address) || (Address > Handle->kEnd_Address)\\" + NL + "    \t\t                     || (final_add_location > Handle->kEnd_Address))" + NL + "    {" + NL + "      status = FLASH003_INVALID_ADDRESS;" + NL + "    }" + NL + "    /*Checking for the status of Flash for Idle and Sleep Mode*/" + NL + "    else if((rd1 == FLASH003_RESET) && (rd2 == FLASH003_RESET) && \\" + NL + "           (rd3 == FLASH003_RESET))" + NL + "    {" + NL + "      /* reads no of bytes specified*/  " + NL + "      for(lByte_Cnt = 0U;lByte_Cnt < (uint32_t)No_of_bytes;lByte_Cnt++)" + NL + "      {" + NL + "        /* reads one byte*/" + NL + "        *(buf + lByte_Cnt) = *((uint8_t*)Address + lByte_Cnt);" + NL + "        status = FLASH003_COMPLETE;" + NL + "      }" + NL + "      rd1 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_ECC1READ_Msk,\\" + NL + "    \t\t                                        NVM_NVMSTATUS_ECC1READ_Pos);" + NL + "      rd2 = RD_REG(Handle->FlashRegsPtr->NVMSTATUS,NVM_NVMSTATUS_ECC2READ_Msk,\\" + NL + "    \t\t                                        NVM_NVMSTATUS_ECC2READ_Pos);" + NL + "      /*Checking for ECC error flags*/" + NL + "      if((rd1 != FLASH003_RESET) || (rd2 != FLASH003_RESET))" + NL + "      {" + NL + "        status = FLASH003_ERROR;" + NL + "      }" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      status = FLASH003_ERROR;" + NL + "    }" + NL + "  return (uint32_t)status;" + NL + "}" + NL + "#if (FLASH003_SEQ_INTERRUPT == FLASH003_INTR_ENABLED)" + NL + "/*" + NL + " * This function used to call the user defined Event handler" + NL + " * for EndofSequence Interrupt" + NL + " */" + NL + "void FLASH003_lSeqInterrupt(uint32_t cbargs)" + NL + "{" + NL + "\t  FLASH003_CallbackType FLASH003_UserCallback;" + NL + "\t  FLASH003_DynamicHandleType* DynamicHandle = &FLASH003_DynamicHandle";
  protected final String TEXT_20 = ";" + NL + "\t  uint32_t CallbackArg = 0U;" + NL + "\t  uint32_t levents = 0U;" + NL + "" + NL + "\t  /* Checking for Block Count*/" + NL + "\t  if(1U < DynamicHandle->FLASH003_Blk_Cnt)" + NL + "\t  {" + NL + "\t\t  DynamicHandle->FLASH003_Blk_Cnt--;" + NL + "\t  }" + NL + "\t  else" + NL + "\t  {" + NL + "\t\t  for(levents = 0; levents < DynamicHandle->\\" + NL + "\t\t                              callback[1].FLASH003_CallBacks; levents++)" + NL + "\t\t  {" + NL + "\t\t\t  FLASH003_UserCallback = DynamicHandle->\\" + NL + "\t\t\t\t\t                            callback[1].CbListener[levents];" + NL + "\t\t\t  CallbackArg = DynamicHandle->callback[1].CbArg[levents];" + NL + "\t\t\t  if(FLASH003_NULL_HANDLER != FLASH003_UserCallback)" + NL + "\t\t\t  {" + NL + "\t\t\t  FLASH003_UserCallback(CallbackArg);" + NL + "\t\t\t  }" + NL + "\t\t  }" + NL + "\t\t  DynamicHandle->FLASH003_global_status = FLASH003_IDLE;" + NL + "\t  }" + NL + "}" + NL + "#endif" + NL + "" + NL + "#if (FLASH003_ECC_INTERRUPT == FLASH003_INTR_ENABLED)" + NL + "/*" + NL + " * This function used to call the user defined Event handler" + NL + " * for EndofSequence Interrupt" + NL + " */" + NL + "void FLASH003_lEccInterrupt(uint32_t cbargs)" + NL + "{" + NL + "\t  FLASH003_CallbackType FLASH003_UserCallback;" + NL + "\t  FLASH003_DynamicHandleType* DynamicHandle = &FLASH003_DynamicHandle";
  protected final String TEXT_21 = ";" + NL + "\t  uint32_t CallbackArg = 0U;" + NL + "\t  uint32_t levents = 0U;" + NL + "" + NL + "\t  for(levents = 0; levents < DynamicHandle->\\" + NL + "\t\t                              callback[0].FLASH003_CallBacks; levents++)" + NL + "\t\t  {" + NL + "\t\t\t  FLASH003_UserCallback = DynamicHandle->\\" + NL + "\t\t\t\t\t                            callback[0].CbListener[levents];" + NL + "\t\t\t  CallbackArg = DynamicHandle->callback[0].CbArg[levents];" + NL + "\t\t\t  if(FLASH003_NULL_HANDLER != FLASH003_UserCallback)" + NL + "\t\t\t  {" + NL + "\t\t\t  FLASH003_UserCallback(CallbackArg);" + NL + "\t\t\t  }" + NL + "\t\t  }" + NL + "\t\t  DynamicHandle->FLASH003_global_status = FLASH003_IDLE;" + NL + "}" + NL + "#endif" + NL + "/*" + NL + " * This is utility function to register Event Handler " + NL + " * for a given event." + NL + " */" + NL + "status_t FLASH003_RegisterCallbackEvent(FLASH003_InterruptId IntID,\\" + NL + "\t\t                     FLASH003_CallbackType userFunction,uint32_t CbArgs)" + NL + "{" + NL + "    FLASH003Status_Type status;" + NL + "    FLASH003_DynamicHandleType* DynamicHandle = &FLASH003_DynamicHandle";
  protected final String TEXT_22 = ";" + NL + "    status = FLASH003_ERROR;" + NL + "" + NL + "    switch(IntID)" + NL + "    {" + NL + "    case 0:" + NL + "      if(DynamicHandle->callback[0].FLASH003_CallBacks < FLASH003_MAX_CALLBACKS)" + NL + "      {" + NL + "         DynamicHandle->callback[0].CbListener[DynamicHandle->\\" + NL + "                                 callback[0].FLASH003_CallBacks] = userFunction;" + NL + "         DynamicHandle->callback[0].CbArg[DynamicHandle->\\" + NL + "                                       callback[0].FLASH003_CallBacks] = CbArgs;" + NL + "         DynamicHandle->callback[0].FLASH003_CallBacks++;" + NL + "         status = FLASH003_COMPLETE;" + NL + "      }" + NL + "      break;" + NL + "    case 1:" + NL + "      if(DynamicHandle->callback[1].FLASH003_CallBacks < FLASH003_MAX_CALLBACKS)" + NL + "      {" + NL + "         DynamicHandle->callback[1].CbListener[DynamicHandle->\\" + NL + "                                 callback[1].FLASH003_CallBacks] = userFunction;" + NL + "         DynamicHandle->callback[1].CbArg[DynamicHandle->\\" + NL + "                                       callback[1].FLASH003_CallBacks] = CbArgs;" + NL + "         DynamicHandle->callback[1].FLASH003_CallBacks++;" + NL + "         status = FLASH003_COMPLETE;" + NL + "      }" + NL + "      break;" + NL + "    default:" + NL + "      status = FLASH003_COMPLETE;" + NL + "    }" + NL + "" + NL + "  return (uint32_t)status;" + NL + "}" + NL + "/*CODE_BLOCK_END*/";
  protected final String TEXT_23 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
     App2JetInterface app = (App2JetInterface) argument; 
     String AppBaseuri = "app/flash003/";
    stringBuffer.append(TEXT_1);
    stringBuffer.append(app.getAppVersion(AppBaseuri) );
    stringBuffer.append(TEXT_2);
     String Fls_NVMUri = null; 
     String appInst  = null; 
     ArrayList<String> appsList = (ArrayList<String>)(app.getApps("app/flash003/"));
    for (String appIns : appsList ) {
        appInst = appIns.substring(appIns.lastIndexOf("/")+1);
     Fls_NVMUri = app.getMappedUri(AppBaseuri + appInst +"/nvm"); 
     if ((Fls_NVMUri != null) && (Fls_NVMUri.trim() != "")) { 
    stringBuffer.append(TEXT_3);
    stringBuffer.append(appInst);
    stringBuffer.append(TEXT_4);
    }else {
    stringBuffer.append(TEXT_5);
    }
    }
    stringBuffer.append(TEXT_6);
    stringBuffer.append(appInst);
    stringBuffer.append(TEXT_7);
    stringBuffer.append(appInst);
    stringBuffer.append(TEXT_8);
    stringBuffer.append(appInst);
    stringBuffer.append(TEXT_9);
    stringBuffer.append(appInst);
    stringBuffer.append(TEXT_10);
    stringBuffer.append(appInst);
    stringBuffer.append(TEXT_11);
    stringBuffer.append(appInst);
    stringBuffer.append(TEXT_12);
    stringBuffer.append(appInst);
    stringBuffer.append(TEXT_13);
    stringBuffer.append(appInst);
    stringBuffer.append(TEXT_14);
    stringBuffer.append(appInst);
    stringBuffer.append(TEXT_15);
    stringBuffer.append(appInst);
    stringBuffer.append(TEXT_16);
    stringBuffer.append(appInst);
    stringBuffer.append(TEXT_17);
    stringBuffer.append(appInst);
    stringBuffer.append(TEXT_18);
    stringBuffer.append(appInst);
    stringBuffer.append(TEXT_19);
    stringBuffer.append(appInst);
    stringBuffer.append(TEXT_20);
    stringBuffer.append(appInst);
    stringBuffer.append(TEXT_21);
    stringBuffer.append(appInst);
    stringBuffer.append(TEXT_22);
    stringBuffer.append(TEXT_23);
    return stringBuffer.toString();
  }
}
